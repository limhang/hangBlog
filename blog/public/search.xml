<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[谷歌插件推荐]]></title>
      <url>%2F2017%2F04%2F10%2FnormalSkill%2F%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
      <content type="text"><![CDATA[缘由：我自己经常使用的谷歌插件，推荐推荐 Vimium介绍：Vimium 这个名字是 Vim 和 Chromium 的合体。Vim 是 Linux 等平台上的一款文本编辑器，它可以让你彻底脱离鼠标，通过一系列快捷键，来操作任何一件事情，也有很多人称之为编辑器之神。 Vimium 继承了 Vim 中的常用键位，让你在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。想像一下，你再也不需要移动鼠标去打开一个链接，手指不用离开键盘，一切都是这么流畅。 功效：熟练使用后，可极大提升浏览器查阅的效率 使用：页面移动 j：向下滚动一点 k：向上滚动一点 g：到页面最底部 G：到页面最底部 d：向下翻一屏 u：向上翻一屏 打开新页面，关闭页面cmd+t打开页面，cmd+w关闭页面 打开页面中的任意链接按f键，出现各个链接的字母标记，输入指定链接的字母标记，完成跳转 在不同便签页中切换shift+j切换到左侧标签， shift+k切换到右侧标签 查找页面中文本cmd+f输入查找内容 dreamAfar介绍：个人最喜欢一款谷歌插件，又名远方，每次打开一个新标签，该插件可从自定义的图库（网络）中随机抽取一张，呈现在你眼前，每张图片都很精美，让你从繁杂的工作中，看到世界的美好，让你对生活，多一份期待 功效：美化浏览器，提升生活–A new way to explore the world. 使用：谷歌应用商店下载，可自定义图片源，也支持下载图片 划词翻译介绍：浏览外文网页的时候，遇到不懂的单词，怎么办？查找谷歌翻译，使用字典软件。。。太慢，太烦，可使用划词翻译插件，支持选择不同服务器解析外文单词，可选谷歌，百度，金山等 功效：在也不怕查看外文页面了。。 使用：设置解析源后，鼠标滑动，选中不懂得单词，或者句子，自动翻译 TextMode介绍：在工作中，查看网页，出现太多图片，被同事看到，不太好，有没有什么办法，可以只有文字，没有图片呢，，试试Text Mode 功效：上班看页面，只有文字，没图片，页面素雅 使用：谷歌应用商店下载，点击Text Mode图标，切换开关模式 Adguard广告拦截器介绍：屏蔽广告 功效：净化页面，屏蔽广告 使用：谷歌应用商店下载，打开使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[compilerandruntimeanalysis]]></title>
      <url>%2F2017%2F04%2F10%2FiOS%2Fcompilerandruntimeanalysis%2F</url>
      <content type="text"><![CDATA[缘由：iOS的编译和运行时一直都有混淆，在此，做个记录和总结 编译器的主要职责1、静态分析（静态的检查语法错误），更类似于翻译器，代码还未写入内存，所以该阶段也没有内存的概念。只能检查出很低级的错误。 2、将c家族的代码转换为llvm-ir中间码 llvm编译器详解 llvm编译器和运行时分析 运行时系统分析 比较基础的运行时解释文章 存在的不解与疑惑（下文为我的初步理解与分析）运行时————查看维基百科等很多资料，回顾以往开发经历，可以确定，所谓运行时，动态语言，就是在app运行在手机上的这个时间过程。 在这个过程中，可以进行消息的转发，类型的确定(id)，那么疑问来了。。。 梳理xcode编译到运行到手机的过程，xcode编译器clang，编译完成之后，到底生成的是什么，是机器码？是中间码？还是什么，google了很久之后，没什么答案，但是分析之后，我感觉是什么可能不重要，但是绝对不会是机器码。。。查看苹果官方文档和clang关于oc-runtime的文档，发现其实mac和iOS手机上面可以运行苹果应用，是因为操作系统上面有运行时库（可以维基百科这个词），所以编译之后应该是中间码，而且这个中间码可以被操作系统上面的运行时库解析，然后消息转发的时候，完成代码的定位和解释（类似解释器），没有找到就报错了（运行时错误）。 而我们在xcode中可以看到的运行时库，是苹果提供给开发者的，和操作系统中的运行时库是不一样的，操作系统（iOS和mac）提供的运行时库（c和汇编写的），我们应该是看不到的。xcode中可见的运行时库主要目的苹果给的说明是，链接不同语言的brige，在编译器最初阶段，会将所有的import导入翻译，其实我们所做的所谓runtime黑魔法，就是做的这一步。————对某些消息转发进行替换，在操作系统上(iOS和mac)运行的时候，操作系统的运行时库再来定位代码和操作（这步是不透明的）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS闭包和回调函数]]></title>
      <url>%2F2017%2F04%2F10%2FiOS%2FiOS%E9%97%AD%E5%8C%85%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[缘由：闭包和回调函数是很多编程语言中的难点和重点，iOS当然也不例外 闭包 block block也叫闭包，也称lamada，在iOS中，闭包主要有以下2点特性 匿名函数和截取自动变量，可以和c语言中的函数指针做类比。 回调函数 CallBackFunction CallBackFunction是回调函数，是函数式编程中很重要的一个特性，就是将函数作为参数传递给另外一个函数，或者将函数作为返回值。 总结在iOS中闭包和回调函数经常组合在一起使用，或者说iOS的回调函数是闭包的一种应用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS代码规范]]></title>
      <url>%2F2017%2F04%2F10%2FiOS%2FiOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[缘由：记录iOS代码书写规范，不定期更新 一、viewController代码结构 属性：@property(nonatomic,strong)UIButton *confirmButton VC生命周期：#pragma mark - life cycle 系统控件代理：#pragma mark - UITableViewDelegate 自定义代理：#pragma mark - CustomDelegate 事件响应：#pragma mark - event response 私有方法(一般都是时间控件外观小处理，也可以放在分类中)：#pragma mark - private methods setter和getter方法：#pragma mark - setters and getters 注：控件添加到view上面都是在viewDidLoad中，使用[self.view addSubview:self.firstLabel];调用getter方法 很好的架构资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用clang分析oc源码]]></title>
      <url>%2F2017%2F04%2F10%2FiOS%2F%E4%BD%BF%E7%94%A8clang%E5%88%86%E6%9E%90oc%E6%BA%90%E7%A0%81%2F</url>
      <content type="text"><![CDATA[缘由：如果要深入理解oc，分析其运行时源码是非常有必要的，在此给出分析方式，和必要的基础知识 一、分析方法使用clang编译器，查看oc代码指令：clang -rewrite-objc xxx.m 二、基础知识2-1、理解结构体和结构体指针结构体：123struct 结构体名&#123; 结构体所包含的变量或数组&#125;; 既然结构体是一种数据类型，那么就可以用它来定义变量。例如：struct stu stu1, stu2; 你也可以在定义结构体的同时定义结构体变量：1234567struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125; stu1, stu2; 如果只需要 stu1、stu2 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名，如下所示：1234567struct&#123; //没有写 stu char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125; stu1, stu2; 结构体指针：123456789struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125; stu1 = &#123; "Tom", 12, 18, 'A', 136.5 &#125;;//结构体指针struct stu *pstu = &amp;stu1; 也可以在定义结构体的同时定义结构体指针：1234567struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125; stu1 = &#123; "Tom", 12, 18, 'A', 136.5 &#125;, *pstu = &amp;stu1; 注意，结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&amp;，所以给 pstu 赋值只能写作：struct stu *pstu = &stu1;参考 2-2、C++构造函数123456789101112131415class Counter&#123; public: // 类Counter的构造函数 // 特点：以类名作为函数名，无返回类型 Counter() &#123; m_value = 0; &#125; private: // 数据成员 int m_value;&#125; 参考 2-3、函数指针1234567891011121314#include &lt;stdio.h&gt;void say_hello(const char *str); void (*fptr)(const char *); int main(void) &#123; void (*fptr)(const char *) = say_hello; fptr("KingPlesk"); return 0; &#125; void say_hello(const char *str) &#123; printf("Hello %s\n", str); &#125; 参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xcode相关]]></title>
      <url>%2F2017%2F04%2F10%2FiOS%2Fxcode%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[缘由：在此总结归纳xcode的使用技巧和xcode编译相关内容 一、xcode基本使用1-1、xcode中创建文件夹如果在xcode工程中new group，只是在视觉效果上分好了几个文件夹，方便分类管理，但在finder中并不会创建新的文件夹，在硬盘目录还是所有文件都并列在一个文件夹内，更恶心的是当你重新打开工程后，会发现刚才new的group已经不见了。那应该怎样建立文件夹呢？ 正确的方法是：在finder找到把工程，新建一个文件夹aa，然后在xcode里面－－右键－－add files to “xxx”－－找到把文件夹aa－－完成，以后若要创建文件，在aa文件夹－－new file即可把文件添加进来，以后在包那里新建文件自然在这个包内。 1-2、xcode快捷键1、打开了2个工程项目，怎么在2个工程项目中切换 Q：’command’ + ‘~’ 2、在.m和.h文件之间快速切换 Q：’command’ + ‘ctrl’ + ‘上/下’ 3、折叠代码操作 Q：‘command’ + ‘option’ + ‘左/右’ 1-3、iOS系统升级后，xcode适配iOS新系统发布后，xcode需要在添加支持文件，步骤如下： 1234567（1）Xcode右击－选项－在Finder显示（2）右击Xcode－显示包内容（3）Contents--&gt;Developer--&gt;Platforms--&gt;iPhoneOS.platform--&gt;DeviceSupport（4）网络下载的文件放入上述位置，完成 1-4、xcode真机调试错误一、账号已绑定最大ID数 解决办法：说明开发账号已绑定超过5台手机，目前解决办法就是重新注册一个账号。 使用注意：所有自己跑的app都可以使用同一个bundleID，前提是使用相同的开发者账号，运行的BuddleID不要随便的更改 1-5、xcode8上架xcode8上架与7有较多不一样的地方，目前整理不是很详细，参考。 二、xcode编译器2-1、背景2-1-1、GCC编译器GCC（GNU Compiler Collection，GNU编译器套装），是一套由 GNU 开发的编程语言编译器。它是一套以 GPL 及 LGPL 许可证所发行的自由软件，也是 GNU计划的关键部分，亦是自由的类Unix及苹果电脑 Mac OS X 操作系统的标准编译器。 GCC 原名为 GNU C 语言编译器，因为它原本只能处理 C语言。GCC 很快地扩展，变得可处理 C++。之后也变得可处理 Fortran、Pascal、Objective-C、Java, 以及 Ada与其他语言。 2-1-2、LLVM编译器Apple（包括中后期的NeXT）一直使用GCC作为官方的编译器。GCC作为开源世界的编译器标准一直做得不错，但Apple对编译工具会提出更高的要求。 一方面，是Apple对Objective-C语言（甚至后来对C语言）新增很多特性，但GCC开发者并不买Apple的帐——不给实现，因此索性后来两者分成两条分支分别开发，这也造成Apple的编译器版本远落后于GCC的官方版本。另一方面，GCC的代码耦合度太高，不好独立，而且越是后期的版本，代码质量越差，但Apple想做的很多功能（比如更好的IDE支持）需要模块化的方式来调用GCC，但GCC一直不给做。甚至最近，《GCC运行环境豁免条款 （英文版）》从根本上限制了LLVM-GCC的开发。 2-1-3、clang编译器Apple吸收Chris Lattner的目的要比改进GCC代码优化宏大得多——GCC系统庞大而笨重，而Apple大量使用的Objective-C在GCC中优先级很低。此外GCC作为一个纯粹的编译系统，与IDE配合得很差。加之许可证方面的要求，Apple无法使用LLVM 继续改进GCC的代码质量。于是，Apple决定从零开始写 C、C++、Objective-C语言的前端 Clang，完全替代掉GCC。 2-2、应用2-2-1、@synthesize,@property和@dynamic区别和联系@synthesize告诉编译器，自动生成@property的setter和getter方法，@dynamic告诉编译器，@property的setter和getter不用自动生成，会在子类实现，或者运行时的时候生成 2-2-2、三者和编译器的纠葛早先的xcode编译器使用的是GCC，所以用户需要手动的写@synthesize someThing = _something;后期使用clang编译器后，这个步骤在声明属性的时候，编译器自动就生成了，最早期的时候，属性的setter和getter都需要用户自己手动生成 2-2-3、常用的属性声明方法早期的属性和成员变量声明是，头文件中interface{NSString _name;},@property NSString name;，实现文件中implement,@synthesize name = _name;这样成员变量就和属性绑定在一起了，可以直接使用下划线的成员变量，如果将@synthesize name = _name;改为@synthesize name;这样相当于@synthesize name = name;成员变量就是name了，这样是很不好的写法，在clang编译器中，不用在写@synthesize的语法了，只有当需要更改成员变量名字的时候，才需要写@synthesize的语法 二者还有一个小区别，如果使用老版的写法，在interface{}大括号中写，成员变量，这样子类可以直接使用_xxx访问到父类的成员变量，如果使用现在的写法，直接声明属性的话，需要使用self.xxx才能访问到父类定义的成员变量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS类的本质]]></title>
      <url>%2F2017%2F04%2F10%2FiOS%2FiOS%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
      <content type="text"><![CDATA[缘由：理解iOS中类和对象的关系，理顺oc这门语言的一些设计理念 一、类的本质 类的本质其实也是一个对象(类对象) 程序中第一次使用该类的时候被创建，在整个程序中只有一份。 此后每次使用都是这个类对象，它在程序运行时一直存在。 类对象是一种数据结构,存储类的基本信息:类大小,类名称,类的版本，继承层次，以及消息与函数的映射表等 类对象代表类,Class类型,对象方法属于类对象 如果消息的接收者是类名,则类名代表类对象 所有类的实例都由类对象生成,类对象会把实例的isa的值修改成自己的地址,每个实例的isa都指向该实例的类对象 二、OC实例对象 类对象 元对象之间关系 元类保存了类方法的列表。当一个类方法被调用时,元类会首先查找它本身是否有该类方法的实现,如果没有则该元类会向它的父类查找该方法,直到一直找到继承链的头。元类(metaclass)也是一个对象,那么元类的isa指针又指向哪里呢?为了设计上的完整,所有的元类的isa指针都会指向一个根元类(root metaclass)。根元类(root metaclass)本身的isa指针指向自己,这样就行成了一个闭环。上面说􏰀到,一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中,我们几乎不会遇到向元类发消息的情况,那它的isa 指针在实际上很少用到。不过这么设计保证了面向对象的干净,即所有事物都是对象,都有isa指针。由于类方法的定义是保存在元类(metaclass)中,而方法调用的规则是,如果该类没有一个方法的实现,则向它的父类继续查找。所以为了保证父类的类方法可以在子类中可以被调用,所以子类的元类会继承父类的元类,换而言之,类对象和元类对象有着同样的继承关系。 三、详细讲解：（GSPerson类） 1.程序启动后，系统会将所有类加载进内存-即代码区。 2.当需要用到GSPerson类时，系统会先在堆中创建一个对象，俗称类对象。 2.1.内部创建一个isa指针指向源类对象 2.2系统会在类对象中包含该类的所有成员属性、对象方法 2.3源类对象： 2.3.1内部创建一个isa指针指向根源类对象－NSObject 2.3.2系统会在类对象中包含该类对象方法 2.3.3根源类对象－NSObject 2.3.3.1内部创建一个isa指针指向自己本身 3.[[GSPerson alloc] init]系统做了三件事： 3.1.alloc: 3.1.1.内部创建一个isa指针指向类对象 3.1.2.在堆中分配一块存储空间 3.1.3.初步初始化，将成员变量初始化为零 3.1.4.返回对象 3.2.init：对成员变量进行初始化 3.3.返回对象 四、核心图解元类，对象，实例，根元类举例： 实际应用情况举例： 参考简书上很好的讲解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python开发环境配置(window&mac)]]></title>
      <url>%2F2017%2F04%2F10%2Fpython%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[缘由：现在用的mac电脑上系统自带的是2.7版本的python，想用python3.5，需要自行安装，电脑上可以同时有2.7和3.5的版本2个版本的兼容可以使用，虚拟环境的方式（virtualenv）【python三大神器virtualenv, fabric, pip】。 一、python在mac上的安装与配置1-1、安装操作1-1-1、使用homebrew安装python -&gt;brew install python3遇到的问题： 1、 【Error: The `brew link` step did not complete successfully The formula built, but is not symlinked into /usr/local Could not symlink . /usr/local/opt is not writable. You can try again using:【brew link gdbm】 参考信息： 【Following Alex&apos; answer I was able to resolve this issue; seems this to be an issue non specific to the packages being installed but of the permissions of homebrew folders. sudo chown -R `whoami`:admin /usr/local/bin】 FROM: http://stackoverflow.com/questions/26647412/homebrew-could-not-symlink-usr-local-bin-is-not-writable 我的尝试： sudo chown -R `whoami`:admin /usr/local/bin 2、 【python3 You must `brew link pkg-config gdbm` before python3 can be installed】 参考信息： http://www.dongcoder.com/detail-293244.html 我的尝试：输入：【brew link pkg-config gdbm】 出现：/usr/local/share/man/man3 is not writable. 输入：【sudo chown -R het /usr/local/share/man/man3/】 出现：/usr/local/opt is not writable. 输入：【sudo chown -R het /usr/local/opt/】 出现：Error: Could not symlink . 输入：brew link gdbm 出现：Linking /usr/local/Cellar/gdbm/1.12… 12 symlinks created 输入：brew install python3等待安装。。。心得：【查找Google，按照英文提示尝试】 3、 【Error: Your Xcode (8.0) is outdated.Please update to Xcode 8.2 (or delete it).Xcode can be updated from the App Store.】 参考信息： 【It was an overly strict move, and after some debate the decision has been vastly loosened in 12aad5c136. It will be made generally available with the 1.0.4 release, which will be cut fairly soon. For now there are at least three workarounds: Probably the easiest: set the TRAVIS environment variable: export TRAVIS=1 Manually check out the master branch; Manually check out the 1.0.2 tag. Sorry for the inconvenience.】 我的尝试： export TRAVIS=1 结果：出现问题4 4、 【Error: Permission denied - /usr/local/etc/openssl/misc/c_hash Warning: Bottle installation failed: building from source.】 参考信息： FROM:---http://www.jianshu.com/p/d96feb47b05b 我的尝试： 【chmod -R 755 /usr/local/etc/openssl/misc】 结果：还是有蛮多问题的，但是基本都是按照提示来处理就好，大多出现权限不够等等，如果755还是不可以，可以尝试777安装homebrew和python3基本耗时2个钟头，安装记录都在这里了，这个习惯需要坚持，这个习惯很好@——@ 1-2、虚拟开发环境，隔离版本1.安装Virtualenv，pip3 install virtualenv tip：在安装的时候，应该存在pip2和pip3，python2和python3，但是修改路径不是很好，所以我采用添加版本号的方式，不加的话，mac系统会逐层查找，所有会找到系统自带的python2 参考信息 1-3、虚拟开发环境使用创建虚拟环境：virtualenv caogao ##创建一个caogao的文件夹 也可以指定虚拟环境的版本 virtualenv caogao –python=python3.6 激活虚拟环境：source ./bin/activate 关闭虚拟环境：deactivate 二、python在window上的安装与配置2-1、安装配置 1、官网下载最新版的python，http://www.python.org/download/【python3.5自带pip】 2、修改python的环境配置，有2种方法，方法一：寻常的修改方法，我的计算机，属性…其实方法一还是挺简单的，直接在环境变量中的系统变量里面设置path为安装路径就可以了方法二，使用cmd操作，path=%path%;C:\Python ，其中 C:\Python 是Python的安装目录。注意：需要进入到C:\Python目录下操作，在cmd中进入的操作是【D:】 3、在cmd中使用python –version，查看是否有安装好 4、使用pip安装文件，pip install aiohttp，安装第三包【pip install aiohttp】包的时候容易报错【小坑】：在pip install的过程中，一直出现 Retrying (Retry(total=4, connect=None, read=None, redirect=None)) after connection broken by ‘ReadTimeoutError(“HTTPSConnectionPool(host=’pypi.python.org’, port=443): Read timed out. (read timeout=15)”,)’: /simple/netifaces/ the above should download, then fail as we don’t have python-dev .. but it can’t download it to start with times-out ReadTimeoutError: HTTPSConnectionPool(host=’pypi.python.org’, port=443): Read timed out. 其实就是外网被墙的原因【解法】：开始谷歌翻墙插件就好了。。。多用谷歌参考：https://github.com/pypa/pip/issues/1805【小坑】：在pip install 过程中，在python下的Scripts文件下运行，因为pip不是python的解释型下运行的 2-2、在git bash中使用python在git bash中使用python，需要在前面加上winpty python，才可以 在git bash中用pip安装插件，也需要在script下进行(最好的办法就是在环境变量中添加D:\python\Scripts;)，但是需要加上winpty，eg:winpty pip3 install virtualenv 但是这个都是很大，所以很慢，可以使用镜像来解决，winpty pip3 install -i url virtualenv 可使用:https://pypi.tuna.tsinghua.edu.cn/simple 参考1 在git bash中使用pip 的virtualenv，使用source venv/scripts/activate参考2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python]]></title>
      <url>%2F2017%2F04%2F10%2Fpython%2F</url>
      <content type="text"><![CDATA[缘由：我所了解的python 一、python常用模块1-1、requests更多请参考 1-2、lxml英文资料 中文参考 1-3、mysqlclient【python于mysql的使用】 使用mysql-python包比较麻烦，其对python3的支持很不友好，在各种尝试和比较之后，选择使用mysqlclient包，这个包也是diagong所推荐的,其实mysqlclient包是mysql-python的一个分支 mysqlclient使用参考 1-4、系统自带模块1-4-1、datetime模块时间处理相关的模块，可参考 1-4-2、urlparse模块网址信息分析截取模块，可参考 1-4-3、re正则匹配模块正则匹配模块，和perl脚本的正则匹配很像可参考 正则匹配的demo What is the difference between .? and . regular expressions It is the difference between greedy and non-greedy quantifiers. Consider the input 101000000000100. Using 1.1, is greedy - it will match all the way to the end, and then backtrack until it can match 1, leaving you with 1010000000001..? is non-greedy. will match nothing, but then will try to match extra characters until it matches 1, eventually matching 101. All quantifiers have a non-greedy mode: .*?, .+?, .{2,6}?, and even .??. 二、项目2-1、美味不用等2-1-1、background周五下午要去吃海底捞，但是人太多要排队，生意太多火爆，所以借助美味不用等，这个应用来提前预约，然后用这个的人也多，而且不知道什么时候可以下预约的，所以需要自动通知提醒我 2-1-2、技术点一爬虫，这个我也写了一些了，基本没什么难度，但是要找到数据这才是爬虫难的，好嘛，这个美味不用等，没有网页端，在微信中内嵌的html5 用charles抓包，分析了这个请求，然后发现是post的，我不知道怎么去分析post的参数在手机端上，所以借助了一个网站 http请求在线分析网站 然后找出这个关键的参数是shopId，最后在去找所以的和美味不用等相关的接口，然后找到了这个字段的值 2-1-3、技术点二爬取到数据之后，定时运行这个脚本就可以了，但是怎么通知我呢，采用邮件和短信通知都是可以的 2-1-4、赶着吃饭，粗糙的源码1234567891011121314151617181920212223242526272829303132333435363738394041#-*- coding:utf-8 -*-import http.clientimport urllibimport requestsimport jsonimport timeurl = 'http://c-api.mwee.cn/wx_queue/shop/detail'payload = &#123;'shopId':'127113'&#125;host = "106.ihuyi.com"sms_send_uri = "/webservice/sms.php?method=Submit" #用户名是登录ihuyi.com账号名（例如：cf_demo123）account = "C1869xxxx"#密码 查看密码请登录用户中心-&gt;验证码、通知短信-&gt;帐户及签名设置-&gt;APIKEYpassword = "7e46204054e54435141546xxxxx" def send_sms(text, mobile): params = urllib.parse.urlencode(&#123;'account': account, 'password' : password, 'content': text, 'mobile':mobile,'format':'json' &#125;) headers = &#123;"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"&#125; conn = http.client.HTTPConnection(host, port=80, timeout=30) conn.request("POST", sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read().decode() conn.close() return response_str if __name__ == '__main__': mobile = "手机号码" text = "您的验证码是：000000。请不要把验证码泄露给其他人。" r = requests.post(url,data=payload) binary = r.content.decode() data = json.loads(binary) out = data['data']['queueInfo']['queueList'][1]['name'] print(out) if out == '中桌(晚市)': print(send_sms(text, mobile)) 参考资料模块参考资料系统自带库的官方文档 爬虫参考资料参考书籍《用python写网络爬虫》，可在脚本之家下载，使用微信关注，然后百度云下载 网络资源豆瓣电影top250爬虫 python学习资料 python中文开发社区 python学习教程 github-spider-dmoe python爬虫教程 python爬虫git版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[window系统使用]]></title>
      <url>%2F2017%2F04%2F10%2FnormalSkill%2Fos%2Fwindow%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[缘由：虽然目前很少使用window系统，但是最近安装ssd，又重新安装了一次window系统，自己虽装过很多次，但是发现每次还是要网上找不少资料，这里一并总结，以慰来者。 一、ssd与操作系统安装1-1、ssd安装 拆开电脑底盖，更换硬盘 开机后提示，无法找到相应的启动盘 华硕电脑按f2进入bios中，找到advance（高级），在里面找到sata设置项，然后设置为AHCI模式，保存退出 插入U盘启动盘，进入U启动页面，选择列表的第二项，进入可视化安装系统中，warning：这里的进入列表第二项，不是直接安装了，而是进入可视化的操作系统中，进行安装，第二项一般是推荐的 进入可视化的安装系统中后，可以对硬盘进行分区，使用该系统中提供的DiskGenius进行分区操作，分区时，勾选对齐到下列扇区数的整数倍，完成以上操作后，可进行系统的安装。 1-2、window系统安装上述SSD安装过程，基本涵盖了接下来的window安装，只需注意以下几点即可： 自制的U盘启动盘，不要在做其他用途，不可再进行保存资料，删除资料等U盘操作 window镜像文件采用的是风火山林的版本，开机后，发现显示比较奇怪，可以设置win主题为azro主题 1-3、参考U启动使用指南 什么是分区什么是逻辑分区 DiskGenius使用指南 固态硬盘装系统 华硕进bios]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac系统使用]]></title>
      <url>%2F2017%2F04%2F10%2FnormalSkill%2Fos%2Fmac%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[缘由：mac系统使用，该文档主要记录日常中使用的各种小技巧 一、mac终端使用1-1、自定义外观依据自己的审美，设置自己的外观 颜色：我选择黑底白字 字体sf mono regular 13 透明度：85% 背景图片：依据自己口味， 1-2、常用操作 进入全屏模式：cmd + ctrl + f 缩放到低栏：cmd + m 1-3、自定义快捷操作最能体现终端功效的，莫过于定义.bash_profile文件 查找自己电脑是否有此文件，终端输入cd，到根目录，然后输入ls -a，查看是否有.bash_profile文件，没有自己创建，设置自定义alias命令，保存后，输入source ~/.bash_profile，运行文件，然后才能生效。 我自己的配置文件在github上的软件配置文件夹中。 二、文件操作相关2-1、强写ReadOnly文件有些文件系统设置为只读属性，这个时候chmod模式改写后，还是不行，这时，可以尝试使用vim打开，然后命令模式下输入： 1:w !sudo tee % &gt; /dev/null 参考 2-2、修改文件默认打开的方式右键点击需要修改的文件，点击显示简介，然后点击打开方式，最后设置完成。 三、软件操作相关3-1、设置xx软件直接在终端打开以sublime为例子 1alias subl=\&apos;&apos;/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl&apos;\&apos; alias为linux的个人偏好设置文件，silicongo中有用到过 四、mac软件使用推荐 macdown 编写markdown的一款软件 charles 抓包工具，设置相关配置后，可抓取https请求]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sublime3安装使用]]></title>
      <url>%2F2017%2F04%2F10%2FnormalSkill%2Fsublime3%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[缘由：换一个电脑，换一个工作环境，都需要重新配置一次sublime，这里做下记录，以便以后方便移植配置 一、偏好设置1-1、setting user的配置1234567&#123; &quot;font_size&quot;: 16.0, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ]&#125; 1-2、key bindings user的配置1234567891011121314151617181920212223242526272829303132333435363738[ &#123; &quot;keys&quot;: [&quot;super+shift+a&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;command_palette&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;super+g&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;, &#123; &quot;keys&quot;: [ &quot;super+e&quot; ], &quot;args&quot;: &#123; &quot;action&quot;: &quot;expand_abbreviation&quot; &#125;, &quot;command&quot;: &quot;run_emmet_action&quot;, &quot;context&quot;: [&#123; &quot;key&quot;: &quot;emmet_action_enabled.expand_abbreviation&quot; &#125;] &#125;, &#123; &quot;keys&quot;: [&quot;tab&quot;], &quot;command&quot;: &quot;expand_abbreviation_by_tab&quot;, &quot;context&quot;: [&#123; &quot;operand&quot;: &quot;source.js&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;match_all&quot;: true, &quot;key&quot;: &quot;selector&quot; &#125;, &#123; &quot;key&quot;: &quot;preceding_text&quot;, &quot;operator&quot;: &quot;regex_contains&quot;, &quot;operand&quot;: &quot;(\\b(a\\b|div|span|p\\b|button)(\\.\\w*|&gt;\\w*)?([^&#125;]*?&#125;$)?)&quot;, &quot;match_all&quot;: true &#125;, &#123; &quot;key&quot;: &quot;selection_empty&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true, &quot;match_all&quot;: true &#125;] &#125;] 1-3、建立软链1ln -s &quot;/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/sublime 如果之前有过软链，终端会提示exit，直接删除即可，rm XXX 二、插件相关 package control sublime安装插件的包管理工具安装：参考、我的简书 emmet 前端编写神器 sublimeCodeIntel 代码自动补全插件，配置 sublimelinter 代码检错插件，配置1、配置2 babel 支持es6与jsx语法高亮]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络基础]]></title>
      <url>%2F2017%2F04%2F10%2Fnetworking%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[缘由：网络通信中很多概念，比较容易弄混，一直没有系统整理过，在此，归纳网络通信中基本的概念和术语 一、通信协议介绍1-1、七层通信协议 应用层 –文件传输，电子邮件，文件下载上传等服务，HTTP,FTP,SMTP，DNS等 表示层 –数据格式化，代码转换，数据加密，没有协议 会话层 –解除或建立与别的接点的联系，没有协议 传输层 –提供端对端的接口，TCP，UDP 网络层 –为数据包选择路由 IP协议等 数据链路层 物理层 1-2、五层通信协议七层协议比较复杂，所以后续推出五层协议 应用层 传输层 网络层 数据链路层 物理层 二、http2-1、http简介http协议属于应用层的协议，用于web端和服务器端的数据交互和通信。HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充。 Keep-Alive是通知服务器，在这个HTTP Request/Responset结束后，不要立即断开TCP连接（注意是TCP连接，和HTTP没有关系），后面的HTTP Request仍然可以通过这个TCP连接继续传送。 但是！这只是个建议，服务器可能不支持，也可能忽略掉这个建议。也可能因为时间太久而直接断开TCP连接，下图展示了http几种不同链接： 三、socketsocket中文也译作套字节，是TCP/UDP通信协议的一层封装，这样让开发者，可以更快捷的使用tcp协议。 Socket 是电脑网络中进程间数据流的端点，也是传输层网络通信的 API。HTTP 作为一个应用层的协议，一般是基于传输层的 TCP 协议的。因此我们要在 TCP 协议上构建我们的程序，也就是使用 Socket 传输 HTTP 的消息。 下图展示了Socket TCP 通信的步骤： 四、websocketWebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算） 4-1、Websocket是什么样的协议，具体有什么优点首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。 简单的举个例子吧，用目前应用比较广泛的生命周期来解释。 HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。 在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。（但是服务器端，支不支持，这个看服务器端，节省建立tcp连接的成本） 但是请记住 Request = Response，在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。 其次，Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手 4-2、Websocket的作用，与HTTP的长轮询和ajax的比较在讲Websocket之前，我就顺带着讲下 long poll 和 ajax轮询 的原理。 ajax轮询 ，ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 场景再现： 客户端：啦啦啦，有没有新信息(Request) 服务端：没有（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：没有。。（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：你好烦啊，没有啊。。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：好啦好啦，有啦给你。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：。。。。。没。。。。没。。。没有（Response） —- loop long poll long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。 场景再现 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） 服务端：额。。 等待到有消息的时候。。来 给你（Response） 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop 从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。 说完这个，我们再来说一说上面的缺陷从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）所以ajax轮询 和long poll 都有可能发生这种情况。 客户端：啦啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 客户端：。。。。好吧，啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 所以在这种情况下出现了，Websocket出现了。 他解决了HTTP的这几个难题。 首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。 所以上面的情景可以做如下修改。 客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request） 服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched） 客户端：麻烦你有信息的时候推送给我噢。。 服务端：ok，有的时候会告诉你的。 服务端：balabalabalabala 服务端：balabalabalabala 服务端：哈哈哈哈哈啊哈哈哈哈 服务端：笑死我了哈哈哈哈哈哈哈 就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。 五、tcp/iptcp建连需要通过3次握手协议，具体图解： 在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据. eg: IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: S 3626544836:3626544836 IP 192.168.1.123.7788 &gt; 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837 IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: ack 1739326487,ack 1 第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机; 第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包; 第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。 六、反向代理，隧道，网关，DNS6-1、正向代理和反向代理 正向代理 A同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。 我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。 反向代理 大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理，客户不知道真正提供服务的人是谁。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。 七、应用：搭建翻墙服务器（vpn,vps,虚拟主机）嗯，确实这几个概念挺饶人的。VPS，虚拟主机，云主机，独立服务器…… 独立服务器，顾名思义，就是一个躺在机房的实实在在的物理服务器，也可理解为你的游戏主机一样。优点：性能高缺点：价格高，高可用性低（比如断电，硬盘坏了……） VPSVirtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。优点：价格便宜缺点：性能低，高可用性低（除了其所在的物理机出问题了会收到影响，虚拟化技术出问题也会收到影响） 云服务器Elastic Compute Service, 简称ECS 好多人理解云服务器和VPS一样，更有甚者说以前的VPS现在的说法就是云服务器，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合。优点：价格适中，使用灵活，高可用性（单个或多个物理离线不会对整个服务造成太大的影响）缺点：性能相对较低 虚拟主机Virtual hosts （Vhost）虚拟主机是通过，物理服务器，VPS或者云服务器安装例如CPanel，Plesk等面板搭建的。虚拟主机市场比较混乱，不同的厂商价格一般会有很大的差异，一般来说看一个虚拟主机的好坏可以从以下几点来看，主机系统：CloudLinux 更适合多租户虚拟主机，CPanel，Plesk 面板在市场上最受市场欢迎，一般来说价格相对较贵，使用云服务器最好（比如阿里云），物理服务器也可，一般不选择VPS作为虚拟主机的服务器。优点：价格低，使用方便缺点：一般来说只能做网站，或应用后端服务器，市场杂乱比较难选购总结：如过只是做一个小网站，个人博客等用虚拟主机就可，大点的应用建议用云服务器 VPN 虚拟专用网（英语：Virtual Private Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果。这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。需要注意的是，加密消息与否是可以控制的。没有加密的虚拟专用网消息依然有被窃取的危险。 以日常生活的例子来比喻，虚拟专用网就像：甲公司某部门的A想寄信去乙公司某部门的B。A已知B的地址及部门，但公司与公司之间的信不能注明部门名称。于是，A请自己的秘书把指定B所属部门的信（A可以选择是否以密码与B通信）放在寄去乙公司地址的大信封中。当乙公司的秘书收到从甲公司寄到乙公司的信件后，该秘书便会把放在该大信封内的指定部门信件以公司内部邮件方式寄给B。同样地，B会以同样的方式回信给A。 在以上例子中，A及B是身处不同公司（内部网路）的计算机（或相关机器），通过一般邮寄方式（公用网络）寄信给对方，再由对方的秘书（例如：支持虚拟专用网的路由器或防火墙）以公司内部信件（内部网络）的方式寄至对方本人。请注意，在虚拟专用网中，因应网络架构，秘书及收信人可以是同一人。许多现在的操作系统，例如Windows及Linux等因其所用传输协议，已有能力不用通过其它网络设备便能达到虚拟专用网连接。 搭建ss翻墙软件vps参考 八、应用：搭建web端多人在线聊天室参考《图解http》 《tcp/ip协议详解-卷一》 个人知乎网络相关收藏 websocket解释 知乎用户：Ovear http-socket解释 知乎用户：冯昱尧 tcp解释]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图解http学习笔记]]></title>
      <url>%2F2017%2F04%2F10%2Fnetworking%2F%E5%9B%BE%E8%A7%A3http%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[缘由：一开始的时候一直都未对http做过太多研究，只是将就够用，但是在写爬虫，被人反爬虫之后，发现不能熟悉掌握http协议，将在互联网世界举步维艰。 一、了解web及网络基础1-1、URI(统一资源标识符)URL(统一资源定位符)，我们比较熟悉，URI是3个单词的缩写，Uniform Resource Identifier URI用字符串表示某一互联网资源，而URL表示资源的地点，可见URL是URI的子集；采用HTTP协议时，协议方案就是http，除此之外，还有ftp、file等，标准的URI协议有30种方案左右。 登录信息：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证），可选项。 查询字符串：针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，可选项。 片段标识符：使用片段标识符通常可标识出已获取资源中的子资源，可选项。 1-2、HTTP协议基本规定一、HTTP发送规则：HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回，换句话说，服务器端在没有收到请求的时候，不会发送响应，所以肯定是从客户端开始建立通信的。 二、HTTP无状态：HTTP是一种不保存状态，即无状态协议，不会对之前发送过的请求进行信息的保存。这样做的好处是可以快速处理大量事务。但是随着网络的不断发展，这种无状态的模式，出现了瓶颈，比如购物网站需要保持用户的登录状态，这样服务器才能知道是谁发送的请求。虽然HTTP1.1是无状态的协议，但是使用了cookie技术，可以保存用户的登录状态 1-3、使用方法下达命令 1-4、HTTP持久化链接在HTTP协议的初期版本中，每进行一次HTTP通信都要断开一次tcp链接，在早些时候，传输的都是文本类信息，但是目前请求都是含有大量图片的信息，这样tcp的不断断开重连会造成很大的开销。 为了解决上述tcp链接的问题，HTTP1.1和部分HTTP1.0相出了持久连接（HTTP keep-alive）的方法，持久化链接的特点是：只要任意一端没有明确提出断开链接，则保持TCP链接状态。http1.1默认都支持keep-alive 1-5、cookie的状态管理cookie会根据服务端发送的一个叫做Set-Cookie的首部字段信息，通知客服端保存Cookie，当下次客服端在往服务端发送请求的时候，客服端会自动在请求报文中加入Cookie然后发送过去，服务端接收到Cookie之后，对Cookie进行解析，然后找出是哪个用户。 eg: 一、请求报文（没有Cookie信息的状态） 123GET /reader/HTTP/1.1Host:hackr.jp*首部字段没有cookie的相关信息 二、响应报文（服务器端生成Cookie信息） 12345HTTP/1.1 200 OKDate:Thu ,12 JUl 2012 07:12:20 GMTServer: Apache&lt;Set-Cookie:sid=1342077140;path=/;expires=wed&gt;Content-Type:text/plain;charset=UTF-8 三、请求报文（自动发送保存的Cookie信息） 123GET /image/ HTTP/1.1Host hackr.jpCookie:sid=1342077140 二、HTTP报文内的信息2-1、HTTP报文用于HTTP协议交互的信息 请求行：包含用于请求的方法，请求的URI和HTTP版本 状态行：包含表明响应结果的状态码，原因短语和HTTP版本 首部字段：包含表示请求和响应的各种条件和属性的各类首部，一般有4中首部，通用首部，请求首部，响应首部，实体首部。 2-2、编码提升传输效率常用的内容编码有这几种: gzip (GNU zip) compress (UNIX 系统的标准压缩) deflate (zlib) identity (不进行编码) 2-3、分割发送的分块传输编码在传输大容量数据的时候，经常采用分块传输的方式 2-4、发送多种数据的多部分对象集合例如在写邮件的时候，可以在邮件中插入音频和视频，还有文字多种不同类型的数据，这个时候就需要用到多种数据的多部分对象集合发送 2-5、获取指定范围的请求数据例如在下载电影的时候，突然断网了，之前是需要重新下载的，但是可以使用Range: bytes=5001-，从5001字节之后开始下载 2-6、内容协商，返回最合适的内容同一个网站，有多份内容相同的页面，比如中文和英文，虽然内容是一样的，但是使用的语言不同，这个时候需用内容协商。Accept，Accept-Charset等等 三、HTTP首部字段 四、HTTPS协议4-1、HTTPS协议介绍http协议未对信息进行加密，所以需要采用加密的形式进行传输，常用的加密方法有：ssl,tls，（secure socket layer）(transport layer security)，在http协议上使用ssl就是https协议。 4-2、不验证通信方的身份可能遇到身份伪装http通信不会进行身份的确认，所以可能出现双方身份的伪装，比如客户端使用URI访问服务器的时候，响应的数据一定是指定的服务器发出的数据嘛？服务器发送给客服端，一定是指定的客户端嘛？ 比如常见的DoS攻击，就算是无意义的请求，也会响应。 ssl不仅可以加密信息，还有身份验证的作用（证书验证） 4-3、信息完整性收到的信息，可能被人为篡改，http无法证明通信的完整性。像这种，在响应传输的过程中发起的攻击，称为中间人攻击（man in the middle attack,MITM） 常用的http协议为了保证信息完整性，一般采用MD5或者证书签名，但是当签名证书和md5信息被人篡改，则无法保证信息完整性。 4-4、HTTP+加密+认证+信息完整性=HTTPS 五、确认访客的身份确认http使用的身份认证： BASIC认证（基本认证）–服务端放回401说明需要认证，然后输入用户名和密码，使用base64加密，发送给服务端，然后进行身份认证。 DIGEST认证（摘要认证）–服务端发送随机数，客户端发送摘要和计算结果。 SSL客服端认证 FormBase认证（基于表单认证） 由于使用上的便利性和安全性的问题，http协议标准提供的basic认证和digest认证几乎不怎么使用，另外ssl使用成本高，一般使用基于表单认证。 5-1、基于表单认证基于表单的认证标准规范尚未有定论，一般会使用cookie管理session（会话） 六、网站安全5-1、跨站脚本攻击5-2、SQL脚本注入攻击]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我所了解的git]]></title>
      <url>%2F2017%2F04%2F09%2FnormalSkill%2F%E6%88%91%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84git%2F</url>
      <content type="text"><![CDATA[缘由：git相关资料，我自己写的比较杂乱，在此合并一处，以后git看这里就够了 一、git基本使用1-1、常用操作 查看分支：git branch 创建分支：git branch 远端拉取分支到本地：git checkout -b master origin/master 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 关联邮箱：git config –global user.email “你的邮件地址” 关联用户名：git config –global user.name “你的Github用户名” 1-2、版本回退与放弃修改 放弃本地所有修改：git checkout . 回退到指定版本：git reset –hard commit_id 1-3、推送远端操作 拉取更新操作：git pull 本地代码更新或有新文件加入：git add . 查看git的状态：git status 提交修改的文件到远端：git commit -m “xxx(备注)” 推送到远端服务器：git push 二、提升git clone的办法2-1、使用浅复制1git clone --depth=1 [url] 这样的操作，不会记录历史的版本，只会下载最新的版本，所有下载下来的内容会小的多 2-2、使用终端代理的方法git-clone太慢怎么办 三、遇到的问题3-1、vps的ssh中使用git遇到的坑3-1-1、一些没注意到的知识git的clone其实是分2种的，网上很多的说法也不靠谱，最靠谱的还是需要自己去理解其原理，追本溯源，方得始终。 git的clone操作有ssh模式和https模式，在vps操作下其实使用的是ssh，故clone的时候需要选中ssh模式的外链 github的ssh模式和https模式 3-1-2、在vps中使用git提交不上去一、修改.git中的config文件，将https改为ssh 二、查看.ssh文件夹下面有没有id_rsh.pub文件，就是ssh加密的公钥文件，git使用ssh加密上传的，这里我目前也不太懂，有空自己搭建一个git就知道了 .ssh配置相关 在有官方的参考文件后，我还是一直遇到坑，就是一直报我提交的公钥有问题，自己没有办法解决，还是网上找的，有时候遇到问题自己还是先搜搜吧，就是应为vim复制的问题 使用cat命令打印到终端，然后在复制就好了，orz 【cat ~/.ssh/id_rsa.pub】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js疑难点总结]]></title>
      <url>%2F2017%2F04%2F09%2Fweb%2Fjs%E7%96%91%E9%9A%BE%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[缘由：javascript的疑难点大概有闭包、作用域、this指向、回调函数和原型链等等，在此做个总结 一、js作用域1-1、概览 块级作用域 （es6才支持的）=&gt;{}，在大括号内的就是块级作用域 函数作用域 =&gt;就是在函数的实现中的，变量 全局作用域 =&gt;在外部声明的变量，如果声明变量的时候，不添加var关键字，则都是全局作用域 本地作用域（函数作用域）的优先级高于全局作用域 1-2、常见认知误区1-2-1、在es6之前，块级作用域的一个常见认知错误1234567891011for (var i = 1; i &lt;= 10; i++) &#123; console.log (i); // outputs 1, 2, 3, 4, 5, 6, 7, 8, 9, 10;​&#125;;​​// The variable i is a global variable and it is accessible in the following function with the last value it was assigned above ​​function aNumber () &#123;console.log(i);&#125;​​// The variable i in the aNumber function below is the global variable i that was changed in the for loop above. Its last value was 11, set just before the for loop exited:​aNumber (); // 11​ ​解释：在es6之前没有块级作用域这个概念，所以在块级作用域中声明的变量和赋值的变量，其实就是全局变量。 1-2-2、setTimeout中的函数在全局scope中执行123456789101112131415161718// The use of the "this" object inside the setTimeout function refers to the Window object, not to myObj​​​var highValue = 200;​var constantVal = 2;​var myObj = &#123; highValue: 20, constantVal: 5, calculateIt: function () &#123; setTimeout (function () &#123; console.log(this.constantVal * this.highValue);&#125;, 2000); &#125;&#125;​​// The "this" object in the setTimeout function used the global highValue and constantVal variables, because the reference to "this" in the setTimeout function refers to the global window object, not to the myObj object as we might expect.​​myObj.calculateIt(); // 400​​// This is an important point to remember. 1-3、注意事项1-3-1、不要过多的声明全局变量wrong way 123456// These two variables are in the global scope and they shouldn't be here​​var firstName, lastName;​​function fullName () &#123; console.log ("Full Name: " + firstName + " " + lastName );&#125; right way 1234567// Declare the variables inside the function where they are local variables​​​function fullName () &#123; var firstName = "Michael", lastName = "Jackson";​ console.log ("Full Name: " + firstName + " " + lastName );&#125; 1-3-2、使用变量的时候，需要提前声明，虽然有声明提前的功能，但是建议不要这么做1234567891011121314151617181920212223function showName () &#123;console.log ("First Name: " + name);​var name = "Ford";console.log ("Last Name: " + name);&#125;​showName (); ​// First Name: undefined​​// Last Name: Ford​​​// The reason undefined prints first is because the local variable name was hoisted to the top of the function​​// Which means it is this local variable that get calls the first time.​​// This is how the code is actually processed by the JavaScript engine:​​​function showName () &#123; var name; // name is hoisted (note that is undefined at this point, since the assignment happens below)​console.log ("First Name: " + name); // First Name: undefined​​name = "Ford"; // name is assigned a value​​​// now name is Ford​console.log ("Last Name: " + name); // Last Name: Ford​&#125; 外文原稿 二、闭包2-1、闭包的基本概念闭包就是内部函数获取外部函数的变量（来自scope chain），闭包有3中scope chain，一种是自身的作用域，还有一种是外部函数的作用域，最后是全局的作用域。 闭包（inner function）不仅可以获取外部函数（outer function）的变量还可以获取外部函数的参数。 最简单的闭包如下： 123456789function showName (firstName, lastName) &#123;​var nameIntro = "Your name is "; // this inner function has access to the outer function's variables, including the parameter​​function makeFullName () &#123;​ return nameIntro + firstName + " " + lastName;&#125;​return makeFullName ();&#125;showName ("Michael", "Jackson"); // Your name is Michael Jackson 2-2、闭包的规则和副作用2-2-1、闭包可以获取外部函数的变量，即使外部函数调用完成（就是执行完成）后。1234567891011121314function celebrityName (firstName) &#123; var nameIntro = "This celebrity is "; // this inner function has access to the outer function's variables, including the parameter​ function lastName (theLastName) &#123; return nameIntro + firstName + " " + theLastName; &#125; return lastName;&#125;​​var mjName = celebrityName ("Michael"); // At this juncture, the celebrityName outer function has returned.​​​// The closure (lastName) is called here after the outer function has returned above​​// Yet, the closure still has access to the outer function's variables and parameter​mjName ("Jackson"); // This celebrity is Michael Jackson 2-2-2、闭包获取的外部函数的变量值，会实时改变Closures store references to the outer function’s variables; they do not store the actual value.Closures get more interesting when the value of the outer function’s variable changes before the closure is called. And this powerful feature can be harnessed in creative ways, such as this private variables example first demonstrated by Douglas Crockford: 12345678910111213141516171819202122function celebrityID () &#123; var celebrityID = 999; // We are returning an object with some inner functions​ // All the inner functions have access to the outer function's variables​ return &#123; getID: function () &#123; // This inner function will return the UPDATED celebrityID variable​ // It will return the current value of celebrityID, even after the changeTheID function changes it​ return celebrityID; &#125;, setID: function (theNewID) &#123; // This inner function will change the outer function's variable anytime​ celebrityID = theNewID; &#125; &#125;​&#125;​​var mjID = celebrityID (); // At this juncture, the celebrityID outer function has returned.​mjID.getID(); // 999​mjID.setID(567); // Changes the outer function's variable​mjID.getID(); // 567: It returns the updated celebrityId variable 2-2-3、最常见的循环导致闭包出的bug需要结合2来看，因为闭包获取的外部函数的变量会实时改变 这个例子需要仔细看，其实就是结合了例子1和例子2，最后形成的一个套路1234567891011121314​function celebrityIDCreator (theCelebrities) &#123; var i; var uniqueID = 100; for (i = 0; i &lt; theCelebrities.length; i++) &#123; theCelebrities[i]["id"] = function () &#123; return uniqueID + i; &#125; &#125; return theCelebrities;&#125;var actionCelebs = [&#123;name:"Stallone", id:0&#125;, &#123;name:"Cruise", id:0&#125;, &#123;name:"Willis", id:0&#125;];​var createIdForActionCelebs = celebrityIDCreator (actionCelebs);​var stalloneID = createIdForActionCelebs[0];​console.log(stalloneID.id()); // 103 解决办法：核心就是使用立即执行函数，这样返回的就不是一个函数了，而是执行完成的结果12345678910111213141516171819202122function celebrityIDCreator (theCelebrities) &#123; var i; var uniqueID = 100; for (i = 0; i &lt; theCelebrities.length; i++) &#123; theCelebrities[i]["id"] = function (j) &#123; // the j parametric variable is the i passed in on invocation of this IIFE​ return function () &#123; return uniqueID + j; // each iteration of the for loop passes the current value of i into this IIFE and it saves the correct value to the array​ &#125; () // BY adding () at the end of this function, we are executing it immediately and returning just the value of uniqueID + j, instead of returning a function.​ &#125; (i); // immediately invoke the function passing the i variable as a parameter​ &#125;​ return theCelebrities;&#125;​​var actionCelebs = [&#123;name:"Stallone", id:0&#125;, &#123;name:"Cruise", id:0&#125;, &#123;name:"Willis", id:0&#125;];​​var createIdForActionCelebs = celebrityIDCreator (actionCelebs);​​var stalloneID = createIdForActionCelebs [0];console.log(stalloneID.id); // 100​​var cruiseID = createIdForActionCelebs [1];​console.log(cruiseID.id); // 101 三、回调函数3-1、基本概念在javascript语法中，函数即使对象，就像String,Array,Number等其他对象一样。所以: function可以被赋值给变量，可以作为函数的参数进行传递，可以在函数内创建新的function，可以被函数作为返回值，这些情况其实就是回调函数。 因为函数是first-class对象，我们可以将其作为参数传递给其他函数，然后在该函数内部执行传递进去的函数，也可以将其作为返回值，然后在执行该返回值函数。 3-2、常见的回调函数12345var friends = ["Mike", "Stacy", "Andy", "Rick"];​friends.forEach(function (eachName, index)&#123;console.log(index + 1 + ". " + eachName); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick​&#125;); 3-3、实现回调函数的基本准则3-3-1、Use Named OR Anonymous Functions as Callbacks12345678910111213141516171819202122232425262728293031// global variable​​var allUserData = [];​​// generic logStuff function that prints to console​​function logStuff (userData) &#123; if ( typeof userData === "string") &#123; console.log(userData); &#125; else if ( typeof userData === "object") &#123; for (var item in userData) &#123; console.log(item + ": " + userData[item]); &#125;​ &#125;​&#125;​​// A function that takes two parameters, the last one a callback function​​function getInput (options, callback) &#123; allUserData.push (options); callback (options);​&#125;​​// When we call the getInput function, we pass logStuff as a parameter.​​// So logStuff will be the function that will called back (or executed) inside the getInput function​getInput (&#123;name:"Rich", speciality:"JavaScript"&#125;, logStuff);​// name: Rich​​// speciality: JavaScript 3-3-2、Make Sure Callback is a Function Before Executing It123456789function getInput(options, callback) &#123; allUserData.push(options);​ // Make sure the callback is a function​ if (typeof callback === "function") &#123; // Call it, since we have confirmed it is callable​ callback(options); &#125;&#125; 3-3-3、Problem When Using Methods With The this Object as Callbacks12345678910111213141516171819202122232425// Define an object with some properties and a method​​// We will later pass the method as a callback function to another function​​var clientData = &#123; id: 094545, fullName: "Not Set", // setUserName is a method on the clientData object​ setUserName: function (firstName, lastName) &#123; // this refers to the fullName property in this object​ this.fullName = firstName + " " + lastName; &#125;&#125;​​function getUserInput(firstName, lastName, callback) &#123; // Do other stuff to validate firstName/lastName here​​ // Now save the names​ callback (firstName, lastName);&#125;getUserInput ("Barack", "Obama", clientData.setUserName);​console.log (clientData.fullName);// Not Set​​​// The fullName property was initialized on the window object​console.log (window.fullName); // Barack Obama Use the Call or Apply Function To Preserve this 123456789101112//Note that we have added an extra parameter for the callback object, called "callbackObj"​​function getUserInput(firstName, lastName, callback, callbackObj) &#123; // Do other stuff to validate name here​​ // The use of the Apply function below will set the this object to be callbackObj​ callback.apply (callbackObj, [firstName, lastName]);&#125; // We pass the clientData.setUserName method and the clientData object as parameters. The clientData object will be used by the Apply function to set the this object​getUserInput ("Barack", "Obama", clientData.setUserName, clientData);// the fullName property on the clientData was correctly set​console.log (clientData.fullName); // Barack Obama 译文参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6语法特性总结]]></title>
      <url>%2F2017%2F04%2F09%2Fweb%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[缘由：es6的书籍从来还没有系统的看过，这几天系统看看es6吧，顺便写写总结 一、let和const命令1-1、块级作用域在es6之前js是没有块级作用域的，es6之后，js引入块级作用域 使用let申明变量的时候就有隐形的块级作用域，使用const定义常量也有块级作用域 具体的细节我在《你不知道的js》学习笔记中已经写过了 二、变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解（Destructuring）。 2-1、数组的解构赋值本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 2-2、对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 2-3、字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 2-4、数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 2-5、函数参数的解构赋值12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 三、字符串的扩展3-1、基础知识–UTF-8、Unicode和ASCIIASCII：（American Standard Code for Information Interchange，美国信息互换标准代码），开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 unicode：随着时代的发展，很多非英语国家都有了计算机，各国也需要保存自己的文字，所以各地区都有自己的标准。正在这时，大天使加百列及时出现了——一个叫 ISO，（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。 UTF：unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。 eg: 12345678910unicode编码方式：I 0049t 0074&apos; 0027s 0073 0020知 77e5乎 4e4e日 65e5报 62a5 12345678910UTF-8编码方式：I 01001001t 01110100&apos; 00100111s 01110011 00100000知 11100111 10011111 10100101乎 11100100 10111001 10001110日 11100110 10010111 10100101报 11100110 10001010 10100101 3-2、模板字符串实例代码如下，一看便明了： 12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量var name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 四、函数的扩展4-1、函数参数的默认值4-1-1、基本用法es5用法： 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World es6用法： 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 4-1-2、注意事项参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 4-1-3、与解构赋值默认值结合使用12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5foo(&#123;x: 1&#125;) // 1, 5foo(&#123;x: 1, y: 2&#125;) // 1, 2foo() // TypeError: Cannot read property 'x' of undefined 上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。如果参数对象没有y属性，y的默认值5才会生效。 4-1-4、函数length属性的影响123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 4-2、rest参数ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 下面是一个 rest 参数代替arguments变量的例子。 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 4-3、扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 实例使用： 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers) // 42 替代数组的apply方法 12345678910111213// ES5的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f(...args); 4-4、箭头函数123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 使用注意事项： （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 五、对象的扩展5-1、属性和方法的简洁表示法5-1-1、属性的简洁表示ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 123456var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于var baz = &#123;foo: foo&#125;; 注：上述的{}其实就是表示这是个对象而已，和[]表示数组一样。 下面是另一个例子： 1234567891011function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 5-1-2、方法的简洁表示12345678910111213var o = &#123; method() &#123; return "Hello!"; &#125;&#125;;// 等同于var o = &#123; method: function() &#123; return "Hello!"; &#125;&#125;; 另一个例子： 12345678910111213var birth = '2000/01/01';var Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; 5-2、Object.assignObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 5-3、对象的扩展运算符5-3-1、解构赋值对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 5-3-2、扩展运算符扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 六、SymbolSymbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 七、Promise对象Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 7-1、基本用法ES6规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 下面是异步加载图片的例子。 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; var image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的Ajax操作的例子。 1234567891011121314151617181920212223242526272829var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 八、Class8-1、概述JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 注意： ES6的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // "function"Point === Point.prototype.constructor // true 构造函数的prototype属性，在ES6的“类”上面继续存在。【事实上，类的所有方法都定义在类的prototype属性上面。】 1234567891011121314151617181920class Point &#123; constructor()&#123; // ... &#125; toString()&#123; // ... &#125; toValue()&#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;; 在类的实例上面调用方法，其实就是调用原型上的方法。 1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 8-2、私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 8-3、this的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。 123456789class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。 12345678910111213141516171819function selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); 8-4、Class的继承Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 1class ColorPoint extends Point &#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 8-5、Class继承详解（es5、es6）8-5-1、es5时代下的继承123456789101112131415161718192021222324252627282930313233343536function Boss(name,money)&#123; this.name = name ; this.money = money ;&#125;;Boss.prototype = &#123; constructor:Boss , business:function()&#123; console.log(this.name+"生意做的不错") ; &#125;&#125; ;function RichSecondGeneration(name,money,graceful)&#123; Boss.call(this,name,money) ; this.graceful = graceful ;&#125; ;RichSecondGeneration.prototype = new Boss() ;RichSecondGeneration.prototype.pickUpGirl = function()&#123; if(this.graceful)&#123; console.log(this.name + "把妹很厉害") ; &#125;else&#123; console.log(this.name + "把妹方式很下流") ; &#125;&#125; ;var wangsicong = new RichSecondGeneration("王思聪",100000000000,true) ; console.log(wangsicong.name,wangsicong.money,wangsicong.graceful) ; wangsicong.business() ; wangsicong.pickUpGirl() ;var lizongrui = new RichSecondGeneration("李宗瑞",1000000000,false) ; console.log(lizongrui.name,lizongrui.money,lizongrui.graceful) ; lizongrui.business() ; lizongrui.pickUpGirl() ; console.log(lizongrui.__proto__); 上述代码是es5时候的写法 继承 常用的继承方式是 原型链继承加借用构造函数构造函数继承 构造函数可以使得实例对象的属性互不相干，原型链继承可以使得实例对象共享已定义好的方法 ； 【属性继承原理】：(new + call); 【方法继承原理】：原型链 8-5-2、es6时代下的继承12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 上述代码是es6下的写法 （1）子类的proto属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 8-5-3、综述其实es5和es6下的继承实现原理是一样的，es6更多的是语法糖 下面，讨论三种继承的情况： 第一种情况，子类继承Object类 12345class A extends Object &#123;&#125;A.__proto__ === Object // trueA.prototype.__proto__ === Object.prototype // true 第二种情况，不存在任何继承。 12345class A &#123;&#125;A.__proto__ === Function.prototype // trueA.prototype.__proto__ === Object.prototype // true [特别注意]：这个情况其实困惑我好久，关于这个情况详见我做的笔记 第三种情况，子类继承null。 12345class A extends null &#123;&#125;A.__proto__ === Function.prototype // trueA.prototype.__proto__ === undefined // true 九、Module9-1、概述历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 9-2、模块的基本使用9-2-1、export命令使用模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。【也可以输出函数和类】 1234// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; || export &#123;firstName, lastName, year&#125;; 9-2-2、import命令使用123456// main.jsimport &#123;firstName, lastName, year&#125; from './profile';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 9-3、跨模块常量本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。 1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from './constants';console.log(A); // 1console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 123456789// constants/db.jsexport const db = &#123; url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'&#125;;// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator']; 然后，将这些文件输出的常量，合并在index.js里面。 123// constants/index.jsexport &#123;db&#125; from './db';export &#123;users&#125; from './users'; 使用的时候，直接加载index.js就可以了。 12// script.jsimport &#123;db, users&#125; from './constants';]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你不知道的js（读书笔记）]]></title>
      <url>%2F2017%2F04%2F08%2Fweb%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%89%2F</url>
      <content type="text"><![CDATA[缘由：初期学习JavaScript的时候，一直对其运行源码十分感兴趣，但是网上关于这些的博客或者说资源都写的太随意，有阅读过一个JavaScript的编译器源码（小型），更对底层点的js更感兴趣，无意间看到此书，隧写点读书笔记。 一、作用域和闭包1-1、基本概念1-1-1、引擎—-从头到尾负责整个 JavaScript 程序的编译及执行过程1-1-2、作用域引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 1-1-3、编译器—-引擎的好朋友之一，负责语法分析及代码生成等脏活累活编译主要有3个部分构成如下： 1、词法分析 这个过程将输入的代码（字符串）转换成词法单元，栗子：var a = 2; 转换成”var” “a” “=” “2” “;”这些词法单元 2、语法分析 这个阶段主要将上一个阶段生成的词法单元，转换成“抽象语法树”，类似于html文档结构中的，父节点，子节点之类的概念。 3、代码生成 这个阶段将抽象语法树转换成机器可以理解的机器执行码 总结： 上述编译3个步骤，是大部分编译器所执行的主要工作流，JavaScript引擎不会花费太多时间来优化编译过程，因为它不像其他编译器，编译是发生在执行前。JavaScript编译是发生在执行前的几微秒。 简单地说，任何 JavaScript 代码片段在执行前都要进行编译(通常就在执行前)。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且 通常马上就会执行它。 1-2、块级作用域的重认识1-2-1、let的块级作用域使用123for (var i=0; i&lt;10; i++) &#123; console.log( i );&#125; 我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域(函数或全局)中的事实。 这就是块作用域的用处。变量的声明应该距离使用的地方越近越好，并最大限度地本地化。作用域泡都是用完就丢掉的，变量应该尽量本地化，不能污染其他作用域。 反面案例： 1234567var a = 2;function bar (c) &#123; a = 3; console.log(c+a);&#125;bar(1);console.log(a); let的块级作用域使用，栗子： 1234for (let i=0; i&lt;10; i++) &#123; console.log( i );&#125;console.log( i ); // ReferenceError 1-2-2、const块级作用域使用除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的 (常量)。之后任何试图修改值的操作都会引起错误。 123456789var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常! b = 4; // 错误! &#125;console.log( a ); // 3console.log( b ); // ReferenceError! 1-3、作用域提升其实我一开始的时候，也只是知其然，不知其所以然，但是看了这本书介绍后，还是有点明白了，这个问题需要从编译器的角度看，还记得第一章的时候说过，js引擎，不会对编译阶段做过多的优化，因为编译的阶段就是执行前的几微秒，所以，编译器，第一步的词法分析就是找到所有所有的变量和函数定义，然后在运行阶段，执行代码，所以变量和函数的声明都会进行提升。 1-4、闭包，何为闭包1-4-1、闭包基本认识之前在学习iOS初期的时候，也一直有这个疑问，在oc中什么叫做闭包呢，在第一遍看oc内存管理的书籍时候，看完觉得晦涩难懂，之后每隔一段时间又重看一遍，基本没次都有新的感悟，对闭包有了诸多的理解，其实js的闭包和oc的闭包的核心思想是一致的，只是语法和实现上有点不同。 我觉得闭包和回调函数一起理解和消化才是最好的，或者说回调函数是一种利用闭包的技术，是回调函数最大程度的发挥了闭包的作用。 下面一起来看一个栗子（js）： 123456789function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar; &#125;var baz = foo();baz(); // 2 —— 朋友，这就是闭包的效果。 在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃 圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行回收。 而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域?原来是 bar() 本身在使用。 拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。 bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 因此，在几微秒之后变量 baz 被实际调用(调用内部函数 bar)，不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。 1-4-2、闭包联合块级作用域的demo12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。 但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。 这是为什么? 首先解释 6 是从哪里来的。这个循环的终止条件是 i 不再 &lt;=5。条件首次成立时 i 的值是 6。因此，输出显示的是循环结束时 i 的最终值。 仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上， 当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循 环结束后才会被执行，因此会每次输出一个 6 出来。 【代码运行起来很快，延迟函数放在另一队列中，等到循环5次后，才来的急执行队列中的函数】 解决办法： 12345for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 1-5、模块1234567891011121314151617function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother()&#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;; &#125;var foo = CoolModule(); foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露， 这里展示的是其变体。 ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。浏览 器或引擎有一个默认的“模块加载器”(可以被重载，但这远超出了我们的讨论范围)可 以在导入模块时异步地加载模块文件。 12345678910111213141516171819202122232425bar.jsfunction hello(who) &#123; return "Let me introduce: " + who;&#125; export hello; foo.js // 仅从 "bar" 模块导入 hello() import hello from "bar";var hungry = "hippo";function awesome() &#123; console.log( hello( hungry ).toUpperCase() );&#125; export awesome;baz.js// 导入完整的 "foo" 和 "bar" 模块module foo from "foo";module bar from "bar";console.log( bar.hello( "rhino" )); // Let me introduce: rhinofoo.awesome(); // LET ME INTRODUCE: HIPPO import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上(在我们的例子里是 hello)。module 会将整个模块的 API 导入并绑定到一个变量上(在 我们的例子里是 foo 和 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公 共 API。这些操作可以在模块定义中根据需要使用任意多次。 二、this和对象原型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack基本使用]]></title>
      <url>%2F2017%2F04%2F08%2Fweb%2Fwebpack%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[缘由：webpack是一个很不错的前端流程化的解决方案，但是配置也需要花点时间掌握，在此做个小总结 1、基本概念了解 webpack WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 glup与grunt 其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。 Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。 2、最基本的webpack环境搭建2-1、初始化webpack环境//全局安装 npm install -g webpack //安装到你的项目目录 npm install --save-dev webpack 2-2、创建package.json配置文件package.json包括当前的依赖模块，自定义的脚本任务 使用npm init，自动创建package.json文件 2-3、创建项目目录，文件回到之前的空文件夹，创建app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。在这里还需要创建三个文件，index.html 文件放在public文件夹中，两个js文件（Greeter.js和main.js）放在app文件夹中 index.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&apos;root&apos;&gt; &lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Greeter.js只包括一个用来返回包含问候信息的html元素的函数。 123456// Greeter.jsmodule.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = &quot;Hi there and greetings!&quot;; return greet;&#125;; main.js用来把Greeter模块返回的节点插入页面。 123//main.js var greeter = require(&apos;./Greeter.js&apos;);document.getElementById(&apos;root&apos;).appendChild(greeter()); 2-4、正式开始运行webpack12//webpack非全局安装的情况node_modules/.bin/webpack app/main.js public/bundle.js 在node_modules文件夹下存在.bin文件夹 2-5、通过配置文件来使用webpackWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。 还是继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，如下所示，它包含入口文件路径和存放打包后文件的地方的路径。 1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 操作:现在如果你需要打包文件只需要在终端里你运行webpack(非全局安装需使用node_modules/.bin/webpack)命令就可以了，这条命令会自动参考webpack.config.js文件中的配置选项打包你的项目。 warning：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 2-6、更快捷的执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下： 12345678910111213&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, &quot;author&quot;: &quot;zhang&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^1.12.9&quot; &#125;&#125; warning:package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。 npm的start是一个特殊的脚本名称，它的特殊性表现在，在命令行中使用npm start就可以执行相关命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build。 3、webpack进阶使用1、生成Source Maps（使调试更容易） 2、使用webpack构建本地服务器 3、Loaders–（可以使用react开发） 【详细步骤移步参考资料】 参考资料简书基本资料参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reflux基本使用]]></title>
      <url>%2F2017%2F04%2F08%2Fweb%2Freflux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[缘由：写项目的时候需要用到这个第三方，故在这里总结一下 一、简介12345+---------+ +--------+ +-----------------+¦ Actions ¦------&gt;¦ Stores ¦------&gt;¦ View Components ¦+---------+ +--------+ +-----------------+ ^ ¦ +--------------------------------------+ 组件（视图），接收到用户手势操作后（点击，滑动），触发Actions，eg：Actions.someAction Actions被触发后，然后激发Stores中写好的方法，eg：OnSomeAction(Actions组件只是声明，具体的实现在Stores) Stores中有存储view中的state数据，写好的方法更新state数据，新版本的reflux.Compoment组件有直接继承react.Compoment，所以新版的reflux可以同步存储view的state，具体的看例子 更新的state触发view中的render方法，然后重新渲染view 二、基本组件介绍2-1、组件Actions使用12345var Actions = Reflux.createActions([ &quot;statusUpdate&quot;, &quot;statusEdited&quot;, &quot;statusAdded&quot;]); 2-2、组件Stores使用123456789101112131415class StatusStore extends Reflux.Store&#123; constructor() &#123; super(); this.state = &#123;flag:&apos;OFFLINE&apos;&#125;; // &lt;- set store&apos;s default state much like in React this.listenTo(statusUpdate, this.onStatusUpdate); // listen to the statusUpdate action &#125; onStatusUpdate(status) &#123; var newFlag = status ? &apos;ONLINE&apos; : &apos;OFFLINE&apos;; this.setState(&#123;flag:newFlag&#125;); &#125;&#125; 三、使用demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var Actions = Reflux.createActions([ &apos;increment&apos;, &apos;decrement&apos;, &apos;changeBy&apos;]);class CounterStore extends Reflux.Store&#123; constructor() &#123; super(); this.state = &#123;count: 0&#125;; this.listenables = Actions; &#125; onIncrement() &#123; this.setState(&#123;count: this.state.count+1&#125;); &#125; onDecrement() &#123; this.setState(&#123;count: this.state.count-1&#125;); &#125; onChangeBy(amount) &#123; this.setState(&#123;count: this.state.count+amount&#125;); &#125;&#125;class Counter extends Reflux.Component&#123; constructor(props) &#123; super(props); this.store = CounterStore; &#125; render() &#123; return &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt;; &#125;&#125;ReactDOM.render( &lt;Counter/&gt;, document.querySelector(&apos;#react-root&apos;));setInterval(Actions.increment, 1000); 官方demo地址–亲测有效 四、遇到的问题4-1、Actions无法被触发详细描述：按照官方给的demo进行修改后，发现点击写好的div后，无法触发方法 问题定位：使用react官方给的工具，在google浏览器中安装插件，然后右键找到源码，在源码处打断点，发现不走这个断点，逐步排除，发现是onsomeAction写错，应该大写，onSomeAction 问题解决：定位出来后，直接解决]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css基础]]></title>
      <url>%2F2017%2F04%2F08%2Fweb%2Fcss%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[缘由：前期有看过一些css相关的书籍，但是一直都没有做总结和记录，现在开始吧~~ 1.Html标记与文档结构1-1.Html标记基础1-1-1.html标签的2种写法 闭合标签 &lt;标签名 属性_1=”属性值” 属性_2=”属性值”&gt;文本内容&lt;/标签名&gt; 12&lt;h1&gt;Words by Dogsworth&lt;/h1&gt;&lt;p&gt;I wandered lonely as a dog.&lt;/p&gt; 自闭合标签 &lt;标签名 属性_1=”属性值” 属性_2=”属性值” /&gt; 1&lt;img src="images/cisco.jpg" alt="My dog Cisco" /&gt; 1-1-2.基本的块级标签和行内标签 块级标签 12345&lt;h1&gt;-&lt;h6&gt; :6 级标签，&lt;h1&gt;表示最重要 &lt;p&gt;:段落&lt;ol&gt;:有序列表&lt;li&gt;:列表项&lt;blockquote&gt;:独立引用 行内标签 1234567&lt;a&gt;:链接(anchor，锚) &lt;img&gt;:图片&lt;em&gt;:斜体&lt;strong&gt;:重要&lt;abbr&gt;:简写&lt;cite&gt;:引证&lt;q&gt;:文本内引用 1-2.Html文档结构 Html文档结构概览（流布局，块级元素，行内元素） 所谓“文档流”的效果，也就是 HTML 元素会按照它们各自在标记中 出现的先后顺序，依次从页面上方“流向”下方。 几乎所有 HTML 元素的 display 属性值要么为 block，要么为 inline。最明显的一 个例外是 table 元素，它有自己特殊的 display 属性值。 块级元素(比如标题和段落)会相互堆叠在一起沿页面向下排列，每个元素分别占 一行。而行内元素(比如链接和图片)则会相互并列，只有在空间不足以并列的情 况下才会折到下一行显示。 块级元素（块级元素盒子会扩展到与父元素同宽） 显示块级元素的轮廓之后，可以发现元素盒子比它们包含的文本要 大一些。每个盒子的高度比内容稍微高一点，而宽度跟浏览器窗口一样宽! 在简易页面中，所有块级元素的父元素都是 body，而它的宽度默认与浏览器窗 口一样宽(当然有少量边距)。因此，所有块级元素就与浏览器窗口一样宽了。说到 这，相信你就能理解为什么块级元素始终会占一行了。对了，就是因为它们始终会 保持与浏览器窗口同宽。这样一来，一个块级元素旁边也就没有空间容纳另一个块 级元素了。 行内元素（行内元素盒子会“收缩包裹”其内容，并且会尽可能包紧） 说到这，你就可以理解为什么几个行内元素会并排显示在一行，而每个块级元素都 会另起一行了。 2、css工作原理2-1.css基本使用2-1-1.Html添加样式的3种方法(代码放在何处) 行内样式 1&lt;p style="font-size: 12px; font-weight:bold; font-style:italic; color:red;"&gt;By adding inline CSS styling to this paragraph, you override the default styles.&lt;/p&gt; 嵌入样式 1234567&lt;head&gt; &lt;!-- 其他 head 元素(如 meta、title)放在这里 --&gt; &lt;style type="text/css"&gt; h1 &#123;font-size:16px;&#125; p &#123;color:blue;&#125; &lt;/style&gt;&lt;/head&gt; 链接样式 1&lt;link href="styles.css" rel="stylesheet" type="text/css" /&gt; 2-1-2.css命名使用规则（最简单的例子） 类似键值对的形式 1p &#123;color:red; font-size:12px; font-weight:bold;&#125; 多个选择符组合在一起使用 1h1, h2, h3 &#123;color:blue; font-weight:bold;&#125; 2-2.选中Html标签的方法（id,属性，上下文选择符）2-2-1.上下文选择符上下文选择符（后代组合式选择符）的格式如下: 标签 1 标签 2 {声明} 其中，标签 2 就是我们想要选择目标，而且只有在标签 1 是其祖先元素(不一定是父元素)的情况下才会被选中。无论从该标签到作为 祖先的上下文之间隔着多少层次都没有关系。 1article p &#123;font-weight:bold;&#125; 2-2-2.子选择符&gt;标签 1 &gt; 标签 2 标签 2 必须是标签 1 的子元素，或者反过来说，标签 1 必须是标签 2 的父元素。与常 规的上下文选择符不同，这个选择符中的标签 1 不能是标签 2 的父元素之外的其他 祖先元素。 1section &gt; h2 &#123;font-style:italic;&#125; 2-2-3.紧邻同胞选择符+标签 1 + 标签 2 标签 2 必须紧跟在其同胞标签 1 的后面。 1h2 + p &#123;font-variant:small-caps;&#125; 2-2-4.通用选择符*通用选择符*(常被称为星号选择符)是一个通配符，它匹配任何元素，因此下面这条规则 1* &#123;color:green;&#125; 会导致所有元素(的文本和边框)都变成绿色。 2-2-5.ID 和类选择符ID 和类为我们选择元素提供了另一套手段，利用它们可以不用考虑文档的层次结构。 只要你在 HTML 标记中为元素添加了 id 和 class 属性，就可以在 CSS 选择符中使用 ID 和类名，直接选中文档中特定的区域。 ID 的用途是在页面中唯一地标识一个元素。正因为如此，同一个页面中的每一个 ID 属性，都必须有独一无二的值(名字)。好吧，换一个角度讲，每个 ID 名在页面中 都只能用一次。 类的目的是为了标识一组具有相同特征的元素，比如本章前面例子中的那个specialtext 类。 类选择符 1.通用类选择符 12&lt;p class="specialtext"&gt; When a tag has a class attribute, you can target it&lt;span&gt;regardless&lt;/span&gt; of its position in the hierarchy.&lt;/p&gt;.specialtext &#123;font-style:italic;&#125; 2.标签带类选择符 12345p &#123;font-family:helvetica, sans-serif; font-size:1.2em;&#125;.specialtext &#123;font-style:italic;&#125;p.specialtext &#123;color:red;&#125;该规则只选择带 specialtext 类的段落。像这样组合标签 名和类选择符，可以让你更精确地选择特定的标签。 ID选择符 ID 与类的写法相似，而且表示 ID 选择符的#(井号)的用法，也跟表示类选择符的. (句号)类似。如果有一个段落像下面这样设定了 ID 属性 12345&lt;p id="specialtext"&gt;This is the special text.&lt;p&gt;那么，相应的 ID 选择符就是这样的:#specialtext &#123;CSS样式声明&#125;或者这样的:p#specialtext &#123;CSS样式声明&#125; 2-3.伪类和伪元素2-3-1.伪类伪类这个叫法源自它们与类相似，但实际上并没有类会附加到标记中的标签上。伪类分两种。 1.UI(User Interface，用户界面)伪类会在 HTML 元素处于某个状态时(比如鼠标 指针位于链接上)，为该元素应用 CSS 样式。 2.结构化伪类会在标记中存在某种结构上的关系时(如某个元素是一组元素中的第 一个或最后一个)，为相应元素应用 CSS 样式。 UI伪类 1、链接伪类 Link。此时，链接就在那儿等着用户点击。 Visited。用户此前点击过这个链接。 Hover。鼠标指针正悬停在链接上。 Active。链接正在被点击(鼠标在元素上按下，还没有释放)。 a:link {color:black;} a:visited {color:gray;} a:hover {text-decoration:none;} a:active {color:red;} warning：一个冒号(:)表示伪类，两个冒号(::)表示 CSS3 新增的伪元素。尽管浏览器目 前都支持对 CSS 1 和 CSS 2 的伪元素使用一个冒号，但希望你能习惯于用双冒号代 替单冒号，因为这些单冒号的伪元素最终可能都会被淘汰掉。 2、:focus 伪类 input:focus {border:1px solid blue;} 会在光标位于 input 字段中时，为该字段添加一个蓝色边框。这样可以让用户明确地知道输入的字符会出现在哪里。 3、:target 伪类 如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标(target)，可以 用:target 伪类选中它。 结构化伪类 1、:first-child 和:last-child :first-child 代表一组同胞元素中的第一个元素，而:last-child 则代表最后一个。 2、:nth-child e:nth-child(n) e 表示元素名，n 表示一个数值(也可以使用 odd 或 even)。 2-3-2.伪元素顾名思义，伪元素就是你的文档中若有实无的元素。以下我们介绍几个最有用的伪 元素 1、::first-letter 伪元素 p::first-letter {font-size:300%;} 段落首字符放大的效果。 2、::first-line 伪元素 p::first-line {font-variant:small-caps;} 可以把第一行以小型大写字母显示 3、::before 和::after 伪元素 &lt;p class=&quot;age&quot;&gt;25&lt;/p&gt; p.age::before {content:&quot;Age: &quot;;} p.age::after {content:&quot; years.&quot;;} Age: 25 years. 3、定位元素3-1、盒子模型3-1-1、盒子模型属性1、边框(border)。可以设置边框的宽窄、样式和颜色。 宽度(border-width)。可以使用 thin、medium 和 thick 等文本值，也可以使用 除百分比和负值之外的任何绝对值。 样式(border-style)。有 none、hidden、dotted、dashed、solid、double、groove、 ridge、inset 和 outset 等文本值。 颜色(border-color)。可以使用任意颜色值，包括 RGB、HSL、十六进制颜色 值和颜色关键字。 2、内边距(padding)。可以设置盒子内容区与边框的间距。 3、外边距(margin)。可以设置盒子与相邻元素的间距。 垂直方向上的外边距会叠加，这可是你必须得知道的一件事。 p {height:50px; border:1px solid #000; backgroundcolor:#fff; margin-top:50px;margin-bottom:30px;} warning： 由于第一段的下外边距与第二段的上外边距相邻，你自然会认为它们之间的外边距 是 80 像素(50+30)，但是你错啦!它们实际的间距是 50 像素。像这样上下外边距 相遇时，它们就会相互重叠，直至一个外边距碰到另一个元素的边框。就上面的例 子而言，第二段较宽的上外边距会碰到第一段的边框。也就是说，较宽的外边距决 定两个元素最终离多远，没错——50 像素。这个过程就叫外边距叠加。 外边距的左右边距则和外边距的上下边距原理相反，左右边距是2者相加。 3-1-2、盒子有多大首先，谈一谈设定盒子的宽度，因为控制元 素的宽度是创建多栏布局的头等大事。一开始我们会看到给没有宽度的元素添加边 框、内边距和外边距的效果，然后再看看通过 CSS 给它设置了宽度之后，它的行为有什么不同。 没有宽度的盒子 盒模型结论一:没有(就是没有设置 width 的)宽度的元素始终会扩展到填满其父 元素的宽度为止。添加水平边框、内边距和外边距，会导致内容宽度减少，减少量 等于水平边框、内边距和外边距的和。 有宽度的盒子 盒模型结论二:为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展 得更宽。实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子要占 据的水平宽度。 3-2、浮动与清除3-2-1、浮动CSS 设计 float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属 性居然也成了创建多栏布局最简单的方式。 说得形象一点，在你浮动一张图片或者其他元素时，你是在要求浏览器把它往上方 推，直到它碰到父元素(也就是 body 元素)的内边界。后面的段落(带灰色边框) 不再认为浮动元素在文档流中位于它的前面了，因而它会占据父元素左上角的位置。 不过，它的内容(文本)会绕开浮动的图片。 接下来我们再看看浮动的另一面，这也是必须得理解的。浮动元素位于“文档流外 部”，因而它已经不被包含在标记中的父元素之内了。正因为如此，它对布局可能产 生破坏性影响。 围住浮动元素的三种方法 1、为父元素添加 overflow:hidden &lt;section&gt; &lt;img src=&quot;images/rubber_duck2.jpg&quot;&gt; &lt;p&gt;It&apos;s fun to float.&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; Here is the footer element that runs across the bottom of the page. &lt;/footer&gt; section {border:1px solid blue; margin:0 0 10px 0; overflow:hidden;} img {float:left;} p {border:1px solid red;} 2、同时浮动父元素 section {border:1px solid blue; float:left; width:100%;} img {float:left;} footer {border:1px solid red; clear:left;} 3、添加非浮动的清除元素 方案一： &lt;section&gt; 4 &lt;img src=&quot;images/rubber_duck.jpg&quot;&gt; &lt;p&gt;It&apos;s fun to float.&lt;/p&gt; &lt;div class=&quot;clear_me&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;footer&gt; Here is the footer element...&lt;/footer&gt; section {border:1px solid blue;} img {float:left;} .clear_me {clear:left;} footer {border:1px solid red;} 方案二： &lt;section class=&quot;clearfix&quot;&gt; &lt;img src=&quot;images/rubber_duck.jpg&quot;&gt; &lt;p&gt;It&apos;s fun to float.&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; Here is the footer element...&lt;/footer&gt; .clearfix:after { content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:both; } 3-2-3、浮动与清除的例子（源码中也有解释）浮动与清除Demo 3-3、定位3-3-1、相对定位相对定位是相对哪里定位的呢？相对的是原来它在文档流中的位置，发生移动，不影响其他的元素布局，原来自身所在的空间保留不动，也可能超过body的边界 3-3-2、绝对定位与相对定位相反，绝对定位是将元素连根拔起，然后在相对定位上下文（默认是body,当将其某个祖先元素设置为position:relative之后，该元素就是定位上下文了），来进行位置确定。 3-3-3、固定定位和绝对定位类似，也是完全将元素连根拔起，但是它参考的浏览器的边界或者手机的屏幕，不会随着滚动发生偏移。 3-3-4、显示属性（display：inline||block） 把块级元素变成行内元素(或者相反)的魔法如下 /*默认为 block*/ p {display:inline;} /*默认为 inline*/ a {display:block;} warning： Top的值表示对象相对原位置向下偏移的距离，bottom的值表示对象相对原位置向上偏移的距离，两者同时存在时，只有Top起作用。 left的值表示对象相对原位置向右偏移的距离，right的值表示对象相对原位置向左偏移的距离，两者同时存在时，只有left起作用。 4、页面布局4-1、布局的基本概念4-1-1、多栏布局的实现方案 固定宽度 流动（主流） 弹性（较为复杂，暂不考虑） 4-1-2、布局高度和布局宽度 布局高度 多数情况下，布局高度不需要我们考虑，事实上，我们不应该给元素设置高度。 布局宽度 布局宽度比较重要，需要仔细考虑设置 4-2、三栏布局只要掌握了创建三栏布局的技术，你想搞多少栏就 能搞多少栏。 4-2-1、三栏固定宽度布局例子详解 4-2-2、三栏中栏流动布局例子详解 4-3、多栏布局参考1、网络资源css布局-dispaly,position,float css布局-float详解，英文 css相对定位和绝对定位 关于css position: absolute、relative定位问题 HTML、CSS知识点总结，浅显易懂 2、书籍相关css设计指南3 3、练手项目百度前端技术学院]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客搭建]]></title>
      <url>%2F2017%2F04%2F07%2FnormalSkill%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[缘由：一直都想有一个自己的博客，可以记录下自己的学习和生活，也尝试过好几种搭建博客的方式，今天在此总结记录下吧。 方案一我最早的博客是用的hostinger，一个免费的虚拟主机搭建的。第一个版本是用的WordPress，搭建完成后还是挺开心的，但是根本都没用几天。之后另外一个版本是用php做后端，自己手写前端界面，但是自己做的界面一直都不能让自己满意 方案二随着技能树的增多，我想有一个自己的vps，这样方便开发，方便多平台无缝隙切换，这次我是在vps上搭建的博客，起初第一个版本是用的python搭建的后端，之后因为python3在centos6上环境有问题，所以还是作罢，采用php的codeigniter框架从写了博客，前端采用react，做到前后端分离，基本的框架和想法以及自己的技能都够了，但是我发现这还不是我想要的，我写博客，只是方便记录自己而已。没必要弄这么复杂，文字在博客中重要性才是第一的 方案三好的。我现在选用hexo与next来搭建了，下面记录下我使用它遇到的一些问题。 ico图标设置问题使用官网的文档，很快就搭建完成了，但是想用自己设计的ico，但是一直弄不成功 解决办法： favicon.ico放在主题的source\images下 修改主题配置文件：的favicon为images/favicon.ico 设置项失效 很多的设置项我开始设置的时候都是无效的 解决办法： 配置文件中如： 1234language:zh-Hans上述设置就将无效language: zh-Hans上述设置将成功，区别在于冒号后的空格！！！]]></content>
    </entry>

    
  
  
</search>
