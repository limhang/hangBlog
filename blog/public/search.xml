<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[小程序组件化方案01]]></title>
      <url>%2Fwxmini%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%8801.html</url>
      <content type="text"><![CDATA[缘由此方案采用wux开源版本，本章节，主要概览框架和核心基类。 一、框架整体介绍12345678910Components|____button -- 带有滑动效果的button| |____button.js -- 组件代码(统一实例自component.js)| |____button.wxml -- 模板代码|____styles -- 样式文件| |____animate.wxss -- 所有关于动画的复用样式| |____widget -- 存放所有组件的样式| | |____button.wxss -- button组件的样式文件|____component.js -- 统一使用的component类|____wux.js -- 导出Components文件夹下，所写的组件 上述树状图就是整体目录和架构。 二、component.js基类文件，代码解读2-1、基类构造函数123456constructor(options = &#123;&#125;) &#123; Object.assign(this, &#123; options, &#125;) this.__init()&#125; 接受一个options(一般为字典对象)参数，然后将参数再转为{options}字典，赋值给this，最终变为this.options 2-2、整体初始化12345678910111213141516171819202122232425262728293031323334353637__init() &#123; //获取当前页面 this.page = getCurrentPages()[getCurrentPages().length - 1] //生成新的setData函数，bind当前页面作为上下文 const setData = this.page.setData.bind(this.page) // 检查版本库是否高于或等于 1.5.0，setData 方法才有回调函数，否则采用 setTimeout 模拟 const checkSDKVersion = () =&gt; &#123; let has = false try &#123; const res = wx.getSystemInfoSync() const SDKVersion = res.SDKVersion.split('.') has = Number(SDKVersion[0]) &gt; 1 || Number(SDKVersion[1]) &gt;= 5 &#125; catch (e) &#123;&#125; return has &#125; // 重写 setData 方法，支持回调，兼容低版本 this.setData = (obj = &#123;&#125;, cb = () =&gt; (&#123;&#125;)) =&gt; &#123; const fn = () =&gt; &#123; if (typeof cb === 'function') &#123; cb() &#125; &#125; if (checkSDKVersion()) &#123; setData(obj, fn) &#125; else &#123; setData(obj) setTimeout(fn, 0) &#125; &#125; this.__initState() &#125; 上述代码中的注释，已经大体说明该函数的作用，getCurrentPages()为小程序提供的获取页面堆栈的接口。checkSDKVersion为版本判断函数，以便兼容setData函数。在小程序api1.5.0版本中，才有setData的回调函数，所以需要做兼容。最后调用__initState函数，完成属性和方法的绑定。 2-3、绑定组件的属性，将options中非函数部分setData123456789101112131415161718192021222324__initData() &#123; const scope = this.options.scope const data = this.options.data this._data = &#123;&#125; // 筛选非函数类型，更改参数中函数的 this 指向 if (!this.isEmptyObject(data)) &#123; for (let key in data) &#123; if (data.hasOwnProperty(key)) &#123; if (typeof data[key] === `function`) &#123; data[key] = data[key].bind(this) &#125; else &#123; this._data[key] = data[key] &#125; &#125; &#125; &#125; // 将数据同步到 page.data 上面方便渲染组件 this.page.setData(&#123; [`$&#123;scope&#125;`]: this._data, &#125;)&#125; 上面的代码可能仍对读者，产生部分困惑，主要是options.data中的函数，被弄到哪里去了。其实这是该组件库，做的不太好的一个地方。component基类，其实不处理options.data中的函数。我们需要自己定义组件的时候，在options.methods中，处理options.data里面的函数。 2-4、组件方法设置123456789101112131415161718192021__initMethods() &#123; const scope = this.options.scope const methods = this.options.methods // 筛选函数类型 if (!this.isEmptyObject(methods)) &#123; for (let key in methods) &#123; if (methods.hasOwnProperty(key) &amp;&amp; typeof methods[key] === `function`) &#123; this[key] = methods[key] = methods[key].bind(this) // // 将 methods 内的方法重命名并挂载到 page 上面，否则 template 内找不到事件 this.page[`$&#123;scope&#125;.$&#123;key&#125;`] = methods[key] // 将方法名同步至 page.data 上面，方便在模板内使用 &#123;&#123; method &#125;&#125; 方式绑定事件 this.setData(&#123; [`$&#123;scope&#125;.$&#123;key&#125;`]: `$&#123;scope&#125;.$&#123;key&#125;`, &#125;) &#125; &#125; &#125;&#125; 获取options中的methods项，挂载到page和page.data上。这里可能存在二个迷惑点。 挂载到page上是什么意思？ 挂载到page上是方便wxml上的bindtap等方法可以找到对应函数 挂载到page.data上是什么意思？ 挂载到this.setData上面，是方便template可以直接使用 简而言之，上述两个是协同起来，一起工作的。 2-5、共用函数1234567891011121314151617181920212223/** * 设置元素显示 */setVisible(className = `wux-animate--fade-in`) &#123; this.setData(&#123; [`$&#123;this.options.scope&#125;.animateCss`]: className, [`$&#123;this.options.scope&#125;.visible`]: !0, &#125;)&#125;/** * 设置元素隐藏 */setHidden(className = `wux-animate--fade-out`, timer = 300) &#123; this.setData(&#123; [`$&#123;this.options.scope&#125;.animateCss`]: className, &#125;) setTimeout(() =&gt; &#123; this.setData(&#123; [`$&#123;this.options.scope&#125;.visible`]: !1, &#125;) &#125;, timer)&#125; 上述代码为所有组件共用的函数，有元素的显示和元素的隐藏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[制作centos69box]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2F%E5%88%B6%E4%BD%9Ccentos69box.html</url>
      <content type="text"><![CDATA[缘由：制作centos69box，方便以后日常使用，集成各种开发环境 一、准备工作1-1、资源centos69box，网上下载最简洁的centos69资源【已上传到百度云】 1-2、技能 shell命令 – 【待充电】 vagrant配置命令【参考官网】 以上2个技能，在1-3和1-4中都会有详解 1-3、shell技能快速点亮1-3-1、基本知识a、shell脚本添加注释sh里没有多行注释，只能每一行加一个#号 b、获取当前执行环境的路径1currentPath=$(cd `dirname $0`; pwd); c、判断一个文件是否存在12345678#!/bin/bashfile="/etc/hosts"if [ -f "$file" ]then echo "$file found."else echo "$file not found."fi d、导入一个文件内容到另外一个文件，or逐行read1234567# usage : [a.sh xx.txt]touch load.txtwhile IFS='' read -r line || [[ -n "$line" ]]; do # echo "Text read from file: $line" echo "Text read from file: $line" echo "$line" &gt;&gt; load.txtdone &lt; "$1" 1-4、vagrant配置相关操作，查看之前文档二、github库补充文档2-1、步骤e、python-virtualenv integrated &amp;&amp; mysql configure补充2-1-1、python-virtualenv搭建在进行到这一步的时候，我们已经安装好了python3.5。在这个基础上，我们安装virtualenv，用它来做python开发环境的隔离。执行sudo pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple virtualenv，如果报错找不到pip3，那么执行sudo ln -s /usr/local/bin/pip3 /usr/bin/pip3，如果报错有某个库文件找不到，那么执行sudo ln -s /usr/local/lib/lib_name_wanted /usr/lib/lib_name_wanted，对于vagrant虚拟机，需要在执行上述软链命令后，重启vagrant配置vagrant reload --provision；如果是购买的vps，应该不用重启的操作。 上述操作进行后，已经将python的virtualenv扩展包，安装好了。执行virtualenv python35 --python=python3.5命令，就可以创建名为python35的文件夹，该文件将的python开发环境被指定为python3.5。开始虚拟环境source ./bin/activate，关闭虚拟环境deactivate。 2-1-2、mysql配置在执行到该步骤的时候，已经安装好了mysql，但是还没有进行配置。执行mysql_secure_installation，回车，输入y，然后填写密码，就修改了root的账户信息。 2-2、步骤f步骤f – make the python scratch workflow work well. include python-virtualenv-lib &amp;&amp; scratch-demo-script f步骤，主要是搭建一个python爬虫开发环境，在进行到该步骤时，我们已经安装好了mysql，python3.5，virtualenv。其实一切都已经准备就绪。我们只需要将这些工具软件，串起来。为了方便测试，我写了一个拉钩的简单爬虫，该爬虫脚本，可以将数据信息写入，数据库(库名自己填)，表名为lagou。该脚本依赖一个库，这个库是链接mysql和python，我之前的文章多次提到这个库。但是，我发现我之前的文章写的不对，以后就看这篇文章了，执行pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pymysql命令就可以了，一切其实很简单的。 三、最终结果代码、配置文件，以及所有需要的资源都在我的github上]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react开发环境搭建]]></title>
      <url>%2Fweb%2Freact%2Freact%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
      <content type="text"><![CDATA[缘由这个是web-react的step by step教程，主要介绍搭建react开发环境的各种配置，包含各种sdk配置，第三方包配置 一、需要理解的几个名词1-1、npm1-1-1、npm是什么？npm 可以理解成类似于pod的一个包管理工具，方便我们添加删除各种依赖包 1-1-2、package.json是什么？npm包中有一个package.json文件，这个文件是说明项目依赖的第三方库。在该文件中，有一个是devDependencies配置项，一个是dependencies配置项，我们知道的，dev是开发环境的意思，我们使用npm和webpack的目的是什么，是需要弄一个bundle文件出来，所以，项目中需要使用的包，我们是用开发环境模式，像css loader ，webpack之类的，是用于打包的，不是用于开发的，所以使用开发模式dev。 package.json，类似于xcode的podfile。这个文件，说明需要依赖的第三方库，一般将项目中需要使用的放在dependencies这个对象下，将解释编译项目需要用到的第三方放在devDependencies对象下，如babel-core,webpack,webpack-dev-server，这些就是解释编译项目需要用到的。此外，这个文件，还有脚本配置项，scripts对象，主要存放，运行的脚本，npm run scriptName，就可以运行。 1-2、webpack1-2-1、webpack是什么？在初学的时候，一直有一个疑惑，npm和webpack到底什么关系，既然有了npm包管理工具了，也就是有了类似pod的工具了，为什么还需要webpack，不能像xcode一样，直接运行跑起来嘛？ 其实，我们虽然有了npm包管理工具，可以很方便的下载第三方使用，但是我们现在写的很多es6语法，是不能被浏览器运行的，例如，谷歌浏览器，也只能做到支持50%的es6语法。而我们常用的import，export语法，其实是es6才支持的，所以我们需要将我们的es6代码转换成es5代码。webpack自带的最基础功能，就是转换es6语法为es5语法。可以理解为，webpack是一个特殊的强大的第三方库。 1-2-2、webpack.config.js是什么？webpack的配置文件，是叫做webpack.config.js。这个里面的配置项，比较多，每个配置项，可以看webpack官方文档，必须看外文的，看中文的，只会更浪费时间。主要的配置，module下的rule，可以添加各种文件(css,jsx,js,scss)的解析，devServer+HotModuleReplacementPlugin热更新。 二、配置文件，运行环境2-1、package.json配置在项目目录下，创建package.json，填写以下配置项 1234567891011121314151617181920212223242526272829303132 &quot;name&quot;: &quot;wxminicode&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;./node_modules/.bin/webpack --config webpack.config.js&quot;, &quot;start&quot;: &quot;./node_modules/.bin/webpack-dev-server&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.26.0&quot;, &quot;babel-loader&quot;: &quot;^7.1.2&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;, &quot;css-loader&quot;: &quot;^0.28.7&quot;, &quot;node-sass&quot;: &quot;^4.7.2&quot;, &quot;sass-loader&quot;: &quot;^6.0.6&quot;, &quot;style-loader&quot;: &quot;^0.19.0&quot;, &quot;webpack&quot;: &quot;^3.8.1&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.4&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;eventemitter3&quot;: &quot;^1.1.1&quot;, &quot;lodash&quot;: &quot;^4.17.4&quot;, &quot;react&quot;: &quot;^16.1.1&quot;, &quot;react-dom&quot;: &quot;^16.1.1&quot;, &quot;react-transition-group&quot;: &quot;^1.2.1&quot; &#125;&#125; 其中react-transition-group是我组件化中依赖的库，版本为1.2.1然后执行npm install warning:由于防火长城的存在，所以一定要配置npm的镜像。 2-2、webpack.config.js配置在项目目录下，创建webpack.config.js，填写以下配置项 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;);module.exports = &#123; entry: &apos;./src/index.js&apos;, devServer: &#123; contentBase: &apos;./dist&apos;, hot: true &#125;, plugins: [ new webpack.NamedModulesPlugin(), new webpack.HotModuleReplacementPlugin() ], output: &#123; filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) &#125;, devtool: &quot;eval-source-map&quot;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125;, &#123; test: /\.scss$/, use: [&#123; loader: &quot;style-loader&quot; // creates style nodes from JS strings &#125;, &#123; loader: &quot;css-loader&quot; // translates CSS into CommonJS &#125;, &#123; loader: &quot;sass-loader&quot; // compiles Sass to CSS &#125;] &#125;, &#123; test: /\.(js|jsx)$/, exclude: /node_modules/, // 这里面的不解析 loader: &apos;babel-loader&apos;, query: &#123; presets:[&apos;es2015&apos;, &apos;react&apos;] &#125; &#125; ] &#125;,&#125;; 2-3、安装上述配置文件，完善工程目录配置仔细看上述的webpack.config.js文件，我们可以知道，入口文件是当前目录下的./src/index.js，然后生成的bundle.js位于dist中。 这里需要介绍下整个webpack工作流程，可自行参考webpack官网。 webpack首先进入entry配置下的文件，也就是./src/index.js。运行该文件后，可以得知项目所有依赖关系，然后生成一个bundle文件。上述的webpack.config.js中有配置devServer，其中指定dist为开始路径文件，故在dist文件中找index执行。 2-3-1、入口文件配置经过上述webpack运行原理阐述之后，我们需要创建一个./src/index.js入口文件，该文件就是我们es6，react写法的开端。示例如下： 123456789import ReactDOM from &apos;react-dom&apos;;import React from &apos;react&apos;;let first = &apos;xiaozuo&apos;;ReactDOM.render( &lt;div&gt;&#123;first&#125;&lt;/div&gt;, document.getElementById(&apos;root&apos;)); 2-3-2、启动文件（index.html）这里开始添加devservice启动文件： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;xxx&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2-4、配置完成，检验效果在项目根目录下，执行npm run build命令，生成bundle文件，然后执行npm run start命令，开始devservice服务，在没开全局网络代理下，浏览器输入localhost:8080，就能看到xiaozuo这个结果了。 如果一切顺利，您就搭建完成了基本的react开发环境了。如遇不顺，可参考官方文档，逐条排查，切记，混英文社区。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[laravel后端api实现教程]]></title>
      <url>%2Fphp%2FwxminiBackendProject.html</url>
      <content type="text"><![CDATA[缘由：写这篇文章，主要是想记录常见的api后台接口实现步骤，以后按照该文档，step by step就可以实现我其他项目的api接口了。其作用等同于前端的组件化方案【所以必须尽可能详尽】。 开始前工作 laravel/homestead.box文件 virtualbox和vagrant软件 phpstorm软件和xdebug配置 – 【已写了详细文档】 一、在虚拟机中搭建laravel应用1-1、laravel应用安装在虚拟机中，执行composer create-project --prefer-dist laravel/laravel wxminibackend命令，生成一个wxminibackend的文件夹【就是我们的应用】，在浏览器中输入，我们配置好的网址，如果出现laravel官方页面，则配置成功。 warning:如果配置了xdebug，需要重新启动phpstorm 1-2、mvc整体框架在应用搭建过程中，我们选择主流的方案，mvc，由于我们是写api接口，所以不会涉及到view，所以重点在于controller和model。 1-3、model搭建a、数据库设置laravel应用中，数据库设置项位于.env中，我们自定义数据库名称，管理员账号和密码，这里设置数据库名称为wxminicode b、使用cli生成数据库表的模板执行php artisan make:model wxuser -m命令，生成wxuser表，我们可以使用php artisan help make:model命令查看刚刚-m参数是什么意思。其实-m就是migrations的意思，生成一个数据表模板，为实际生成数据库表，做准备。 c、完善刚刚生成的数据库模板在b中，我们生成了wxminibackend/database/migrations/time_wxusers文件，其中已经有3个列的数据项，created_at,updated_at,id,其中increments函数是控制id的，timestamps函数是控制另外两个时间项的。由于，我们项目需要userId，userName，vip这三个数据项，所以添加代码如下： 12345678910public function up()&#123; Schema::create('w_x_users', function (Blueprint $table) &#123; $table-&gt;increments('id'); $table-&gt;timestamps(); $table-&gt;string('userId'); $table-&gt;string('userName'); $table-&gt;boolean('vip'); &#125;);&#125; d、生成数据表由于，我们使用了新的数据库，wxminicode，但是用户homestead可能没有权限新建这个数据库，所以我们需要在虚拟机中，手动创建该数据库。执行php artisan migrate命令，则在数据库中，生成WXUser表。 e、数据字段安全对于数据库安全，可以设置过滤条件，将下面代码添加到wxuser.php中1protected $fillable = [&apos;userName&apos;, &apos;userId&apos;, &apos;vip&apos;]; f、重新归档文件位置将wxuser.php统一放到app\model下 1-4、路由搭建路由就是用户输入请求的接口，路由的设计，也就是整个后端设计的体现。12//上传用户个人信息，将数据处理部分，下发给控制器 -- 【联动UserController中的insertUser方法】Route::post(&apos;user&apos;,&apos;UserController@insertUser&apos;); 1-5、控制器设计执行php artisan make:controller UserController，生成UserController，以便处理user路由下发的逻辑。在app/Http/Controllers/UserController.php中添加下面代码 123456789use App\Model\wxuser;class UserController extends Controller&#123; public function insertUser(Request $request) &#123; $info = wxuser::create($request-&gt;all()); return response()-&gt;json($info,200); &#125;&#125; 二、参考useful information about laravel framework 2-1、service container &amp; service provider [practice]how to register &amp; use laravel service provider Through this article you could understand what is service container and what is service provider.Read it step by step you can register service provider and use it accurately. 2-2、routers [Built a react APP with a laravel restful backend]part 1,laravel 5.5API Through this article you will create your own restful API .]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[laravel开发环境配置]]></title>
      <url>%2Fphp%2Flaravel%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      <content type="text"><![CDATA[缘由：laravel环境配置，准备工作都在这里了 软件工程中，学习一门技能，主要分2部分 一是。搭建环境，学习语言； 二是。熟悉框架，使用框架。做好上述2步，基本就算会了这门技能，提升主要体现在对框架源码的认知高度，对语言实现运行时的理解。概括为，入门体现在会用该技能解决现实中某种问题；提升体现在知道为什么这样做怎样做到的。 本文主要总结归纳php-laravel，这门技能【我之前使用过的】 – 环境搭建部分 一、vagrant，virtualbox，homestead.box1-1、准备工作下载vagrant，virtualbox，homestead.box，这三个文件，在我的U盘中，都长期有备份。virtualbox和vagrant的使用，可参考之前写过的vagrant&amp;virtualbox的文章 1-2、安装laravel官网，配置homestead.box我们进入laravel官网,查看homestead.box的配置。为了以后方便，这里指定接下来使用的box版本号和homestead库分支号。homestead.box-v5.0.1,Homestead库分支-v7.0.1 1.fork下homestead库，这里面有vagrant软件配置项【针对homestead】 我已经fork了一份，以后可以做完常用配置文件，修改保存，地址 2.使用homestead库配置homestead.box 进入homestead库文件夹，切换好branch dev 【这个分支，是我自己使用的】1git checkout dev 运行脚本，生成Homestead.yaml,aliases,after.sh，这3个文件12345// Mac / Linux...bash init.sh// Windows...init.bat 3.配置Homestead.yaml文件 a、设置Homestead.yaml中的Provider配置项1provider: virtualbox b、配置共享文件夹设置Homestead.yaml中的folders配置项123folders: - map: ~/code to: /home/vagrant/code c、配置nginx站点设置Homestead.yaml中的sites配置项123sites: - map: hang.com to: /home/vagrant/code/Laravel/public 设置本地hosts文件1192.168.10.10 hang.com 4.加载Vagrant Box在homestead文件夹中，运行vagrant up这里一般会出现二个错误，1.提示找不到laravel/homestead的box;2.还是提示找不到laravel/homestead的box 对于问题一12在我们使用vagrant box add xx_name file:///xx的时候，我们需要将xx_name 填为laravel/homestead，因为在scripts/homestead.rb文件中有名称约束 对于问题二我们需要修改scripts/homestead.rb文件中的约束12345 # Configure The Box config.vm.define settings[&quot;name&quot;] ||= &quot;homestead-7&quot; config.vm.box = settings[&quot;box&quot;] ||= &quot;laravel/homestead&quot;#config.vm.box_version = settings[&quot;version&quot;] ||= &quot;&gt;= 4.0.0&quot; config.vm.hostname = settings[&quot;hostname&quot;] ||= &quot;homestead&quot; 由于我们本地使用的version是0，所以应该将box的版本约束去掉 5.一些问题a、进行到4步之后，可能遇到一些问题，一般是由于网络因素，所以设置终端走代理，小飞机开全局 b、我们如果修改homestead中配置项的话，需要执行vagrant reload --provision命令 二、配置laravel开发环境【虚拟机中】2-1、修改虚拟机中的composer镜像在虚拟机终端执行下面代码，配置镜像1composer config -g repo.packagist composer https://packagist.phpcomposer.com 2-2、开始体验laravel正常情况下，你只需要在浏览器中，输入hang.com就可以了。如果有一些文件夹权限的问题，按照错误信息，修改文件夹权限就可以了 三、学习框架最好的办法是看源码3-1、看源码最好的办法，是断点调试[web]3-1-1、homestead虚拟机装xdebug我使用的homestead【php7.2】虚拟机中，没有安装xdebug，这个可以使用php -i，然后导出代码，填写到xdebug检测，就可以知道自己有没有安装xdebug了。如果没有安装，顺着官网指导，安装。 3-1-2、配置xdebug新建/etc/php/7.2/fpm/conf.d/20-xdebug.ini,添加内容如下：12345zend_extension=xdebug.soxdebug.remote_enable = 1xdebug.remote_connect_back = 1xdebug.remote_port = 9000xdebug.max_nesting_level = 512 重启php7.2 sudo service php7.0-fpm restart 3-1-3、 Chrome xDebug plugin下载谷歌xdebug插件，配置该插件【选中debug模式，在插件配置中，设置phpstorm】 3-1-4、刷新网页这个时候，我们应该在phpstorm中，可以看到一个弹窗，设置名字，loaclhost，本地地址 warning:地址设置，一定要注意是输入最外层地址，就是映射地址codephpstorm右上侧，有一个listen xdebug按钮，选中它 3-1-5、参考资料整体安装思路 xdebug安装 3-1、看源码最好的办法，是断点调试[api]我们在laravel中写api接口的时候，也有断点调试的需求，比如我们使用postman发送post请求，那么怎么断点调试呢，在上面配置的基础上，只需要将postman中的url加上?XDEBUG_SESSION_START=PHPSTORM，然后在header中加上字段XDEBUG_SESSION=PHPSTORM，例子： 12url :: hang.com/api/user?XDEBUG_SESSION_START=PHPSTORMheaders :: XDEBUG_SESSION=PHPSTORM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[why should i learn english ?]]></title>
      <url>%2Fenglish%2Fwhy_should_i_learn_english.html</url>
      <content type="text"><![CDATA[缘由：所做之事，不问前程，但求因果 背景：2017年6月18号，参加TechCrunch举办的深圳区hackathon活动，我意识到2个问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reactNative使用全解]]></title>
      <url>%2FreactNative%E4%BD%BF%E7%94%A8%E5%85%A8%E8%A7%A3.html</url>
      <content type="text"><![CDATA[缘由：使用reactNative开发跨端项目（iOS,android,wechat） 快速概览主要使用的技术：react es6 dva(redux,redux-sagas),ant-design reactNative reactNative-Navigation 一、环境搭建默认安装：node npm react-native-cli 1-1、初始项目搭建123【创建一个reactNative项目】react-native init reactPhoto --version 0.44.3cd reactPhoto【创建导航插件(官方推荐)】npm install --save react-navigation【目前使用1.0.0-beta.11】 1-2、初步整理项目，运行项目为了共用一套代码，修改index.android.js和index.ios.js内容为:1import &apos;./app.js&apos;; 新建文件app.js在里面写逻辑【注意：】1AppRegistry.registerComponent(&apos;reactPhoto&apos;, () =&gt; reactPhoto); 上述代码中的注册名字必须和开始生成项目的名字一致【reactPhoto】. 1-3、参考资料react-navigation代码库reactNative中文入门文档 二、配置项目结构和第三方插件2-1、集成dva框架在这里推荐以下配置：1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "name": "DvaStarter", "version": "0.0.1", "private": true, "scripts": &#123; "start": "node node_modules/react-native/local-cli/cli.js start", "test": "jest", "prettier": "prettier --write --single-quote --no-semi --trailing-comma es5 --print-width 80 \"app/**/*.js\"", "lint": "eslint app", "format": "yarn prettier &amp;&amp; yarn lint -- --fix", "precommit": "yarn format" &#125;, "dependencies": &#123; "dva": "1.3.0-beta.4", "react": "16.0.0-alpha.6", "react-native": "^0.44.3", "react-navigation": "^1.0.0-beta.11", "redux-persist": "^4.8.0" &#125;, "devDependencies": &#123; "babel-eslint": "^7.2.3", "babel-jest": "^20.0.3", "babel-plugin-transform-decorators-legacy": "^1.3.4", "babel-preset-react-native": "^1.9.2", "eslint": "^3.19.0", "eslint-config-airbnb": "^15.0.1", "eslint-config-prettier": "^2.1.1", "eslint-plugin-babel": "^4.1.1", "eslint-plugin-import": "^2.3.0", "eslint-plugin-jsx-a11y": "^5.0.3", "eslint-plugin-prettier": "^2.1.1", "eslint-plugin-react": "^7.0.1", "husky": "^0.13.4", "jest": "^20.0.4", "prettier": "^1.4.4", "react-test-renderer": "^16.0.0-alpha.6" &#125;, "jest": &#123; "preset": "react-native" &#125;&#125; 2-2、参考资料dva-reactNative官方例子 三、在iOS真机上运行3-1、修改General目录左侧的targets下的reactPhoto的signing3-2、修改General目录左侧的targets下的reactPhotoTests的signing]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Lumen配合WorkerMan实现长链接]]></title>
      <url>%2Fproject%2FLumen%E9%85%8D%E5%90%88WorkerMan%E5%AE%9E%E7%8E%B0%E9%95%BF%E9%93%BE%E6%8E%A5.html</url>
      <content type="text"><![CDATA[缘由：Lumen框架下长链接的使用 一、所用工具 后端相关： 1234lumen框架redis数据库workerman(gatewayworker&amp;&amp;gatewayclient)事件通知，广播 前端相关： 12dvareact 二、流程图三、lumen框架下redis使用（lumen5.4）3-1、安装依赖1234567&quot;require&quot;: &#123; &quot;php&quot;: &quot;&gt;=5.6.4&quot;, &quot;laravel/lumen-framework&quot;: &quot;5.4.*&quot;, &quot;vlucas/phpdotenv&quot;: &quot;~2.2&quot;, &quot;illuminate/redis&quot;: &quot;^5.4&quot;, &quot;predis/predis&quot;: &quot;1.1.*&quot; &#125;, 执行composer install 3-2、修改配置项在bootstrap/app.php文件中把123$app-&gt;withFacades();$app-&gt;withEloquent(); 注释取消并且注册redis类代码如下1$app-&gt;register(Illuminate\Redis\RedisServiceProvider::class); 在.env下，修改配置如下：1CACHE_DRIVER=redis 在config文件夹下，查看database.php是否有如下代码：12345678910&apos;redis&apos; =&gt; [ &apos;cluster&apos; =&gt; env(&apos;REDIS_CLUSTER&apos;, false), &apos;default&apos; =&gt; [ &apos;host&apos; =&gt; env(&apos;REDIS_HOST&apos;, &apos;127.0.0.1&apos;), &apos;port&apos; =&gt; env(&apos;REDIS_PORT&apos;, 6379), &apos;database&apos; =&gt; env(&apos;REDIS_DATABASE&apos;, 0), &apos;password&apos; =&gt; env(&apos;REDIS_PASSWORD&apos;, null), ], 3-3、基本使用1234use Illuminate\Support\Facades\Cache;Cache::put(&apos;roomId&apos;, $roomId, 60);Cache::put(&apos;userName&apos;,$userName,60); 详细见参考资料3-3-2 3-4、参考资料1、lumen5.4下redis使用配置2、lumen官方cache使用3、lumen缓存使用介绍 四、GatewayWorker&amp;&amp;GatewayClient使用4-1、基本介绍五、lumen框架的事件和广播六、reactJS中使用webSocket七、项目代码仓库1https://github.com/limhang/LandLord]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis使用]]></title>
      <url>%2Fredis%E4%BD%BF%E7%94%A8.html</url>
      <content type="text"><![CDATA[缘由：主要介绍redis使用 一、redis基础知识回顾]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XCODE项目重命名]]></title>
      <url>%2FiOS%2FXCODE%E9%A1%B9%E7%9B%AE%E9%87%8D%E5%91%BD%E5%90%8D.html</url>
      <content type="text"><![CDATA[缘由：重命名xcode项目，这里涉及到很多的依赖和关联，所以其实很容易出错的，在此记录一下 step 1–修改项目名打开xcode项目，修改右侧中的name，详细见下图：填写完成之后，点击其他位置，这个时候，系统会给一个弹窗，点击弹窗中的rename按钮 step 2–Rename the Scheme点击左侧栏的【edit schemes】位于【stop】按钮旁边，点击下方的manager schemes，修改schemes,点击一下，选中，然后回车修改名字，关闭xcode 如果使用pod，这里需要多加一步，回到文件夹中，修改OLD.xcworkspace to NEW.xcworkspace step 3–修改文件夹，所有旧文件名这里主要修改，oldNameUItests，oldnaemTests，oldname这3个文件夹的名字 打开oldname.xcodeproj【注意是这个文件，不是pod生成的那个文件】 然后依次对那3个文件进行修改名字的操作，和修改路径的操作，具体位置见下图 step 4–修改plist文件点击Build Settings，修改plist文件路径和bundleid名字 step 5–修改pod相关删除所有与pod相关文件，重新pod install 打开【SoilDetector.xcworkspace】,删除红色失去关联的SoilDetector.xcworkspace文件 在Build phases中，点击Link Binary With Libraries,删除old name的pod文件 command + shift + k ，然后run，ok！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络是怎样连接的读书笔记]]></title>
      <url>%2F%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
      <content type="text"><![CDATA[缘由：系统整理下计算机网络的知识吧-_- 一、浏览器生成消息，探索浏览器内部URL和URI的区别URL uniform resource location(统一资源位置)URI uniform resource identification(统一资源定位符)HTTP的基本思路：客户端发送http请求，主要告诉服务器2个东西，一个是在哪里（URI），一个是怎么操作（GET,POST），其中POST操作的URI一般是index.php之类的可执行脚本文件，然后可执行的文件收到发送的请求参数，并进行处理。 二、ip以太包的收发操作2-1、基本概念1、数据包由2部分组成，包头和数据（内容）；例子(tcp/ip包)如下：123以太包：MAC头部+IP头部+TCP头部+数据块ip包：IP头部+TCP头部+数据块MAC头部：以太控制信息；IP头部：IP控制信息；一般来说TCP头部和数据块加起来就是包的内容。 2、集线器(hub)和交换机(switch)的区别之前看过一个youtube的视频，一个光头橙色衣服的大叔讲解网络，hub和switch的区别，经过他讲解后清楚明了，hub是比较久远的设备了，目前基本已经不用了，取而代之的是switch。举个例子：我现在有一个8端口的hub，如果我在端口1要和端口8进行通信，那么端口1在检测到hub上没有数据传播后，开始广播，呼叫端口8，端口8听到后请回到，这个广播包会传递到所有端口上，造成通信拥堵。我现在有一个8端口的switch，如果我在端口1要和端口8进行通信，如果端口1已经和端口8进行过通信后，端口1可以直接在地址对应表上找到端口8的地址，直接通信，如果2者之前没有进行过通信，那么会重复hub的操作。【注意：】上述的广播操作就是：ARP协议 3、路由器和集线器的区别路由器：路由器根据目标地址判断下一个路由器的位置集线器：集线器在子网中将网络包传输到下一个路由实际上，集线器是按照以太网规则传输包的设备，而路由器是按照 IP 规则传输包的设备，因此我们也可以作如下理解。(1)IP 协议根据目标地址判断下一个 IP 转发设备的位置(2)子网中的以太网协议将包传输到下一个转发设备 要理解两者之间的关系，关键点在于计算机在发送网络包时，或者是 路由器在转发网络包时，都需要在前面加上 MAC 头部。之前的讲解都是 说在开头加上 MAC 头部，如果看图 3.16 大家可以发现，准确的说法应该 是将 IP 包装进以太网包的数据部分中。也就是说，给包加上 MAC 头部并 发送，从本质上说是将 IP 包装进以太网包的数据部分中， 托以太网去传 输这些数据。IP 协议本身没有传输包的功能，因此包的实际传输要 托以 太网来进行。路由器是基于 IP 设计的，而交换机是基于以太网设计的，因 此 IP 与以太网的关系也就是路由器与交换机的关系。换句话说，路由器将 包的传输工作 托给交换机来进行 A。当然，这里讲的内容只适用于原原本 本实现 IP 和以太网机制的纯粹的路由器和交换机，实际的路由器有内置交 换机功能的，比如用于连接互联网的家用路由器就属于这一种，对于这种 路由器，上面内容可能就不适用了。但是，如果把这种“不纯粹”的路由 器拆分成“纯粹”的路由器和“纯粹”的交换机，则它们各自都适用上面 的内容。 从包的转发目标也可以看出路由器和交换机之间的 托关系。IP 并不 是 托以太网将包传输到最终目的地，而是传输到下一个路由器。在创建 MAC 头部时，也是从 IP 的路由表中查找出下一个路由器的 IP 地址，并通过 ARP 查询出 MAC 地址，然后将 MAC 地址写入 MAC 头部中的，这表 示 IP 对以太网的 托只是将包传输到下一个路由器就行了。当包到达下 一个路由器后，下一个路由器又会重新 托以太网将包传输到再下一个 路由器。随着这一过程反复执行，包就会最终到达 IP 的目的地，也就是 通信的对象。 到这里我们已经梳理了路由器与交换机之间的关系。简单来说，IP (路由器)负责将包发送给通信对象这一整体过程，而其中将包传输到下一个路由器的过程则是由以太网(交换机)来负责的。 2-2、tcp/ip传输过程1、tcp/ip包包含以下2个头部(a)MAC 头部(用于以太网协议) (b)IP 头部(用于 IP 协议)这两个头部分别具有不同的作用。首先，发送方将包的目的地，也就 是要访问的服务器的 IP 地址写入 IP 头部中。这样一来，我们就知道这个 包应该发往哪里，IP 协议就可以根据这一地址查找包的传输方向，从而找 到下一个路由器的位置，也就是图 2.16 中的路由器 R1。接下来，IP 协议 会 托以太网协议将包传输过去。这时，IP 协议会查找下一个路由器的以 太网地址(MAC 地址)，并将这个地址写入 MAC 头部中。这样一来，以太 网协议就知道要将这个包发到哪一个路由器上了。 网络包在传输过程中(图 2.16 1)会经过集线器，集线器是根据以太 网协议工作的设备。为了判断包接下来应该向什么地方传输，集线器里有 一张表(用于以太网协议的表)，可根据以太网头部中记录的目的地信息查 出相应的传输方向。这张图中只有一个集线器，当存在多个集线器时，网 络包会按顺序逐一通过这些集线器进行传输。 接下来，包会到达下一个路由器(图 2.16 2)。路由器中有一张 IP 协 议的表，可根据这张表以及 IP 头部中记录的目的地信息查出接下来应该发 往哪个路由器。为了将包发到下一个路由器，我们还需要查出下一个路由 器的 MAC 地址，并记录到 MAC 头部中，大家可以理解为改写了 MAC 头 部 A。这样，网络包就又被发往下一个节点了。 再往后的过程图上就没有画出来了。网络包会通过路由器到达下一个 路由器 R2。这个过程不断重复，最终网络包就会被送到目的地，当目的地 设备成功接收之后，网络包的传输过程就结束了。 【简单概述】：ip头部信息可以获取数据包传输方向，并且获取下一个目的地的mac地址，并且加入到（修改）mac头部信息，以太网协议根据mac头部，负责将数据传递到目的地。 图解如下： 三、TCP与UDP3-1、tcp3-1-1、tcp三次握手我初学tcp的时候就有这个疑问，为什么是三次握手？2次不行嘛？这里做个通俗的讲解，通信双方是甲和乙第一次握手：甲发出请求，并附带加密确认消息（确保是乙收到）第二次握手：乙回复甲的请求，并回复加密消息，附加乙的加密消息第三次握手：甲回复乙请求，并回复加密消息 仔细思考一下，是不是第二次握手的时候，甲收到乙的消息后，甲就已经可以确认双方可正常通信呢？当然，这个时候，甲知道自己发送的数据可达乙处，乙发动的消息可达甲处，这不就是可接受可发送嘛。但是乙呢？乙并不知道自己的消息可到达甲处，乙只能确定自己可接受甲的消息，所以对于乙，通信只能是可接受不一定可达，所以进行第三次我握手，网上也有人说是信道不稳定，确认稳定性，但是从逻辑上看，我觉得我说的很有道理的。 3-1-2、tcp协议头部格式Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接； Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题； Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题； Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节； TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下： 1234567891011URG：此标志表示TCP包的紧急指针域（后面马上就要说到）有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。 Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制；这是一个复杂的问题，这篇博文中并不会进行总结的； ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1 SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。 FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。 四、RSA、数字签名、数字证书4-1、基本概念 数字证书：证书中心(certificate agent)用自己的私钥对某个公钥和该公钥相关信息加密的生成的(digital certificate)，数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。数字证书还有一个重要的特征就是只在特定的时间段内有效。 数字签名：通信中，私钥拥有者用私钥加密信息摘要（信息hash函数生成）产生的(digital signature)，用来保证身份。接收者，拿到传递的信息和数字签名后，用公钥解码数字签名，用hash函数解码信息，对比2个解码后的数据，如果一致，则说明信息来源可靠 RSA非对称加密算法：该名称来自于发明这个算法的3人名字的首字母，核心是利用一个最基本的数学原理，2个大质数相乘，所得的大质数，很难逆向分解得出这2个质数。(在量子计算和分布式日益成熟的今天，也不知道还能保证多久) 4-2、实际应用上述的基本概念中，数字证书的出现，其实是防止一种情况发生，如果小A和小B通信，小A首先用hash函数生成信息的摘要，然后对摘要进行私钥加密生成数字签名，将信息+hash函数+数字签名发送给小B，小B拿到后，用小A的公钥解码数字签名，然后用hash函数加密信息，将上述2种操作得到的摘要进行比对，相同，则证明信息是完整，没有被篡改的。 这个时候小C如果在小B不注意的时候，修改了小B保留的小A的公钥，换成自己的公钥，冒充小A给小B发送信息，这个时候小B就被欺骗了，所以公钥应该在通信的时候保证其正确性，这个时候就有了(certificate agent)证书机构和数字证书。 小A的公钥不再由小A发送给小B了，而由小B直接去证书机构申请，例子如下： 123456A与B安全通信认证过程1 A 向CA请求B的数字证书2.1 CA把B的数字证书做输入参数，生成一个Hash2.2 CA用自己的私钥加密Hash，生成一个数字签名（Digital Signature）2.3 CA把数字签名附在B的数字证书之后，即 B的数字证书 + CA 数字签名，发给A3 A拥有CA的公钥（预装或者离线方式获得），可以解密CA的数字签名（CA私钥加密），得到Hash，同时对接收到的B的数字证书做Hash运算，也得到一个Hash，如果两个Hash 相等，则认为此证书安全可靠，在传输途中没有被篡改，我们称这个过程为数据完整性（Data Integrity ）保护 比较详细的参考说明 参考资料书籍《网络是怎么连接的》 网络tcp协议通俗讲解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数据结构与算法]]></title>
      <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.html</url>
      <content type="text"><![CDATA[缘由：复习总结一下常用数据结构与算法，长期更新 一、数据结构1-1、基础知识物理存储结构：线性存储，链式存储 逻辑结构：线性表，二叉树，图 时间复杂度计算，空间复杂度计算 1-2、队列，栈，优先队列（堆）1-2-1、List12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function List() &#123; this.listSize = 0; this.pos = 0; this.dataStore = []; this.clearList = clearList; this.find = find; this.toString = toString; this.insert = insert; this.append = append; this.remove = remove; // this.front = front; // this.end = end; // this.prev = prev; // this.nextElement = nextElement; // this.lengthList = List; // this.currPos = currPos; // this.moveTo = moveTo; // this.getElement = getElement;&#125;function append(element) &#123; this.dataStore[this.listSize++] = element;&#125;function find(element) &#123; for(var i = 0; i &lt; this.dataStore.length; ++i) &#123; if (this.dataStore[i] == element) &#123; return i; &#125; &#125; return -1;&#125;function remove(element) &#123; var foundAt = this.find(element); if (foundAt &gt; -1) &#123; this.dataStore.splice(foundAt,1); --this.listSize; return true; &#125; return false;&#125;function lengthlist() &#123; return this.listSize;&#125;function toString() &#123; return this.dataStore;&#125;function insert(element,after) &#123; var insertPos = this.find(after); if (insertPos &gt; -1) &#123; this.dataStore.splice(insertPos + 1,0,element); --this.listSize; return true; &#125; return false;&#125;function clearList() &#123; delete this.dataStore; this.dataStore = []; this.pos = this.listSize = 0;&#125;var names = new List();names.append('jacob');names.append('raistlin');names.append('jetty');names.append('bruce');// print(names.toString());console.log(names.toString());names.remove('raistlin');// print(names.toString());console.log(names.toString());names.insert('raist','bruce');console.log(names.toString());names.clearList();console.log(names.toString()); 1-2-2、单向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566function Node(element) &#123; this.element = element; this.next = null;&#125;function LList() &#123; this.head = new Node('head'); this.find = find; this.findPre = findPre; this.insert = insert; this.remove = remove; this.display = display;&#125;function find(item) &#123; var currentNode = this.head; while (currentNode.element != item) &#123; currentNode = currentNode.next; &#125; return currentNode;&#125;function insert(newElement,item) &#123; var newNode = new Node(newElement); var currentNode = this.find(item); newNode.next = currentNode.next; currentNode.next = newNode;&#125;function display() &#123; var currentNode = this.head; while (!(currentNode.next == null)) &#123; console.log(currentNode.element); currentNode = currentNode.next; &#125;&#125;function findPre(item) &#123; var currentNode = this.head; while (currentNode.next.element != item) &#123; currentNode = currentNode.next; &#125; return currentNode;&#125;function remove(item) &#123; var currentNode = this.head; while (currentNode.element != item) &#123; currentNode = currentNode.next; &#125; if (currentNode.element == item) &#123; this.findPre(item).next = currentNode.next; currentNode.next = null; return; &#125;&#125;var names = new LList();names.insert('jacob','head');names.insert('jetty','jacob');names.insert('raistlin','jetty');names.insert('bruce','raistlin');names.insert('raistlin','bruce');names.remove('raistlin');names.display(); 1-2-3、双向链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function Node (element) &#123; this.element = element; this.next = null; this.previous = null;&#125;function LList (item) &#123; this.head = new Node('head'); this.disReverse = disReverse; this.display = display; this.findLast = findLast; this.find = find; this.insert = insert; this.remove = remove; &#125;function disReverse () &#123; var currentNode = this.head; currentNode = this.findLast(); while (!(currentNode.previous == null)) &#123; console.log(currentNode); currentNode = currentNode.previous; &#125;&#125;function findLast () &#123; var currentNode = this.head; while (!(currentNode.next==null)) &#123; currentNode = currentNode.next; &#125; return currentNode;&#125;function find (item) &#123; var currentNode = this.head; while (!(currentNode.element == item)) &#123; currentNode = currentNode.next; &#125; return currentNode;&#125;function insert (newElement,item) &#123; var currentNode = this.find(item); newNode = new Node(newElement); if (currentNode.next == null) &#123; currentNode.next = newNode; newNode.previous = currentNode; newNode.next = null; &#125; else &#123; newNode.next = currentNode.next; currentNode.next.previous = newNode; currentNode.next = newNode; newNode.previous = currentNode; &#125;&#125;function remove (item) &#123; var currentNode = this.find(item); var previousNode = currentNode.previous; var nextNode = currentNode.next; nextNode.previous = previousNode; previousNode.next = nextNode;&#125;function display () &#123; var currentNode = this.head; while (currentNode.next != null) &#123; console.log(currentNode.element); currentNode = currentNode.next; &#125;&#125;var names = new LList()names.insert('jacob','head');names.insert('bruce','jacob');names.insert('jetty','bruce');names.insert('raistlin','jacob');names.remove('jacob');names.display(); 1-2-3、queue123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function Queue() &#123; this.dataStore = []; this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.back = back; this.toString = toString; this.empty = empty;&#125;function enqueue(element) &#123; this.dataStore.push(element);&#125;function dequeue () &#123; return this.dataStore.shift();&#125;function front () &#123; return this.dataStore[0];&#125;function back () &#123; return this.dataStore[this.dataStore.length - 1];&#125;function toString() &#123; var restr = ''; for (var i = 0; i &lt; this.dataStore.length; i++) &#123; restr += this.dataStore[i] + '\n'; &#125; return restr;&#125;function empty () &#123; if (this.dataStore.length == 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;var queue = new Queue();queue.enqueue('jacob');queue.enqueue('bruce');queue.enqueue('jetty');console.log(queue.front());console.log(queue.back());console.log(queue.toString());queue.dequeue();console.log(queue.toString()); 1-2-4、stack12345678910111213141516171819202122232425262728293031323334353637383940function Stack()&#123; this.dataStore = []; this.top = 0; this.push = push; this.pop = pop; this.peek = peek; this.length = length; this.clear = clear;&#125;function push(element) &#123; this.dataStore[this.top++] = element;&#125;function pop() &#123; return this.dataStore[--this.top];&#125;function peek() &#123; return this.dataStore[this.top - 1];&#125;function length() &#123; return this.top;&#125;function clear() &#123; this.top = 0;&#125;var instanceStack = new Stack();instanceStack.push('jacob');instanceStack.push('jetty');instanceStack.push('bruce');instanceStack.push('raistlin');console.log(instanceStack.peek());instanceStack.pop();console.log(instanceStack.peek());instanceStack.pop();console.log(instanceStack.peek()); 1-3、二叉树1-3-1、背景知识树是一种比较重要的数据结构，尤其是二叉树。二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。二叉树是递归定义的，因此，与二叉树有关的题目基本都可以用递归思想解决。 1-3-2、基本概念二叉树概念：每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。二叉树中每一个节点都是一个对象，每一个数据节点都有三个指针，分别是指向父母、左孩子和右孩子的指针。每一个节点都是通过指针相互连接的。相连指针的关系都是父子关系。 满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树：完全二叉树是指最后一层左边是满的，右边可能满也可能不满，然后其余层都是满的。一个深度为k，节点个数为 2^k - 1 的二叉树为满二叉树（完全二叉树）。满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。 二叉树的遍历：前序遍历，中序遍历，后序遍历123（1）前序遍历（DLR），首先访问根结点，然后遍历左子树，最后遍历右子树。简记根-左-右。（2）中序遍历（LDR），首先遍历左子树，然后访问根结点，最后遍历右子树。简记左-根-右。（3）后序遍历（LRD），首先遍历左子树，然后遍历右子树，最后访问根结点。简记左-右-根。 【规律：左右不变，根移位】 实现的代码主要使用递归：1234567891011121314151617181920212223242526 void PreOrderTraverse(BinaryTreeNode * pRoot) &#123; if(pRoot == NULL) return; Visit(pRoot); // 访问根节点 PreOrderTraverse(pRoot-&gt;m_pLeft); // 前序遍历左子树 PreOrderTraverse(pRoot-&gt;m_pRight); // 前序遍历右子树 &#125; void InOrderTraverse(BinaryTreeNode * pRoot) &#123; if(pRoot == NULL) return; InOrderTraverse(pRoot-&gt;m_pLeft); // 中序遍历左子树 Visit(pRoot); // 访问根节点 InOrderTraverse(pRoot-&gt;m_pRight); // 中序遍历右子树 &#125; void PostOrderTraverse(BinaryTreeNode * pRoot) &#123; if(pRoot == NULL) return; PostOrderTraverse(pRoot-&gt;m_pLeft); // 后序遍历左子树 PostOrderTraverse(pRoot-&gt;m_pRight); // 后序遍历右子树 Visit(pRoot); // 访问根节点 &#125; 1-3-3、参考资料轻松搞定二叉树面试题 js算法与数据结构 学习JavaScript数据结构与算法:栈与队列 1-4、查找二叉树（BST）,二叉堆，图1-4-1、查找二叉树二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为O(log n)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、multiset、关联数组等。 二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望O(log n)最坏O(n)（数列有序，树退化成线性表）。 虽然二叉查找树的最坏效率是O(n),但它支持动态查询，且有很多改进版的二叉查找树可以使树高为O(log n),如SBT,AVL树，红黑树等。故不失为一种好的动态查找方法。 1-4-2、查找二叉树的js实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function Node(data,left,right) &#123; this.data = data; this.left = left; this.right = right; this.show = show;&#125;function show() &#123; return this.data;&#125;function BST() &#123; this.root = null; this.insert = insert; this.inOrder = inOrder;&#125;function insert(data) &#123; var n = new Node(data,null,null); if (this.root == null) &#123; this.root = n; &#125; else &#123; var current = this.root; while(1) &#123; if (data &lt; current.data) &#123; if (current.left == null) &#123; current.left = n; break; &#125; current = current.left; &#125; else &#123; if (current.right == null) &#123; current.right = n; break; &#125; current = current.right &#125; &#125; &#125;&#125;function inOrder(node) &#123; if (node != null) &#123; inOrder(node.left); console.log(node.show()); inOrder(node.right); &#125;&#125;var nums = new BST();nums.insert(23);nums.insert(45);nums.insert(16);nums.insert(110);nums.insert(37);nums.insert(3);nums.insert(99);nums.insert(22);inOrder(nums.root); 二、排序算法2-1、冒泡排序(bubble sort)2-1-1、bubble概述【o(n2)】冒泡排序的算法时间复杂度为n^2，是最基础的排序算法，基本思想：对于一个长度为N的数组，从左往右，依次找到数组中最大项，第二大项….，最小项，依次排序到数组最右侧，第一次比较的次数为N-1,找到最大项后，将其移至最右侧，第二次找第二大项，比较次数为N-2，找到第二大项后，将其移至倒数第二位，依次重复上述操作。 2-1-2、bubble排序实现（js）12345678910111213141516171819// bubble排序// 可视化演示过程可参考：https://visualgo.net/sorting// 理解：时间复杂度为O(n2);进行2个for循环，原则是每一个子循环进行后，最大数值被放置最右侧var array = [12,23,45,2,45,3,464,29];function bubbleSort() &#123; var numElements = this.array; for (var outer = numElements.length; outer &gt;=2; --outer) &#123; for (var inner = 0; inner &lt;= outer - 1; ++inner) &#123; if (this.array[inner] &gt; this.array[inner + 1]) &#123; var b = this.array[inner]; this.array[inner] = this.array[inner + 1]; this.array[inner + 1] = b; &#125; &#125; &#125; console.log(this.array);&#125;bubbleSort(); 2-2、选择排序(selected sort)2-2-1、selected sort概述【O(n2)】选择排序和冒泡排序基本思想是一致的，都是找出数组中，最大元素，第二大元素，第三大元素….最小元素，依次放置在数组的最右侧，选择排序比冒泡排序算法好在，其元素交换的次数没有那么多。核心体现在[哨兵]的使用上。 2-2-2、selected sort算法实现(js)1234567891011121314151617181920212223242526//理解：选择排序的时间复杂度还是O(n2)，和冒泡排序不同在于，减少数据交换次数，以下实现为找到最小元素，然后找到第二小元素，直接放置合适位置var swap = function(array, firstIndex, secondIndex)&#123; var temp = array[firstIndex]; array[firstIndex] = array[secondIndex]; array[secondIndex] = temp;&#125;;var array = [2,1];swap(array, 0, 1)console.log('swap should return [1,2] --&gt;', array);var selectionSort = function(array)&#123; for(var i = 0; i &lt; array.length; i++)&#123; //set min to the current iteration of i var min = i; for(var j = i+1; j &lt; array.length; j++)&#123; if(array[j] &lt; array[min])&#123; min = j; &#125; &#125; swap(array, i, min); &#125; return array;&#125;;var array = [12,23,45,2,45,3,464,29]console.log('selectionSort should return [2, 3, 12, 23, 29, 45, 45, 464]--&gt;',selectionSort(array)); 2-3、插入排序(insert sort)2-3-1、insert sort概述【O(n2)】插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 2-3-2、insert sort算法实现(js)1234567891011121314151617181920212223242526//理解：插入算法简而言之，将一个新元素插入不断增长的有序数列中，插入完成之后，有序数列增加一个元素。function insertionSort(inputArray)&#123; var holePosition var valueToInsert for(var i = 1; i&lt; inputArray.length; i++)&#123; /* select value to be inserted */ valueToInsert = inputArray[i] holePosition = i /* Notice I used the while as opposed to the for*/ while ( holePosition &gt; 0 &amp;&amp; inputArray[holePosition-1] &gt; valueToInsert)&#123; inputArray[holePosition] = inputArray[holePosition-1] holePosition = holePosition -1 &#125; /* insert the number at hole position */ inputArray[holePosition] = valueToInsert &#125; return inputArray; &#125;var result =insertionSort([12,23,45,2,45,3,464,29]);console.log(result); 2-4、希尔排序(shell sort)2-4-1、shell sort概览【O(n log2 n)】希尔排序需要着重注意一下，这是排序算法的一个里程碑，在希尔算法之前，人们都认为排序的算法复杂度没有办法突破，O(n2),希尔算法之后，人们相续发明诸多可以突破时间复杂度O(n2)的算法，其实希尔算法是插入算法的一种变形。具体的解释摘抄自维基百科： 1希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 上述的解释不够直观，下面用一个例子描述： 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 123413 14 94 33 8225 59 94 65 2345 27 73 25 3910 然后我们对每列进行排序： 123410 14 73 25 2313 27 94 33 3925 59 94 65 8245 将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序： 12345610 14 7325 23 1327 94 3339 25 5994 65 8245 排序之后变为： 12345610 14 1325 23 3327 25 5939 65 7345 94 8294 最后以1步长进行排序（此时就是简单的插入排序了） 2-4-2、shell sort算法实现(js)1234567891011121314151617181920212223242526//理解：shell sort 算法是对插入算法的一个改进，从下面的代码中也可以看出来，for循环的部分和插入算法实现是一样的，shell sort算法实现较为容易，但是理解并计算其时间复杂度还是比较困难的。function shellSort(arr) &#123; var increment = arr.length / 2; while (increment &gt; 0) &#123; for (i = increment; i &lt; arr.length; i++) &#123; var j = i; var temp = arr[i]; while (j &gt;= increment &amp;&amp; arr[j-increment] &gt; temp) &#123; arr[j] = arr[j-increment]; j = j - increment; &#125; arr[j] = temp; &#125; if (increment == 2) &#123; increment = 1; &#125; else &#123; increment = parseInt(increment*5 / 11); &#125; &#125; return arr;&#125;console.log(shellSort([12,23,45,2,45,3,464,29])); 2-5、归并排序(merge sort)2-5-1、merge sort概览【O(n log n)】归并排序，看着英文名字是不是很熟悉，是的，merge，就是git操作中合并分支的语法，所以你应该能明白这个算法的大概了，而且这个算法是大神，冯洛伊曼给出的，官方给的说明太过简洁，反而不好理解，下面是啰嗦版本。 首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。 可以看出合并有序数列的效率是比较高的，可以达到O(n)。 解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？ 可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。 归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(NlogN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(NlogN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。 归并排序参考的网页 我的理解：2个有序的数列【1，3，6，12】、【2，4，5，10】现在将2个数列合并为一个数列，第一步，比较a[0]和b[0]，所以c[0]=a[0]=1 ,c[1]=b[0]=2第二步，比较a[1]和b[1]，所以c[2]=a[1]=3 ,c[3]=b[1]=4第三步，比较a[2]和b[2]，所以c[4]=b[2]=5，c[5]=a[2]=6第四步，比较a[3]和b[3]，所以c[6]=b[3]=10，c[7]=a[3]=12最后合并的数组为var c = [1,2,3,4,5,6,10,12] 所以合并2个有序数组是很容易，但是怎样才能保证合并的是有序数组呢，最小的有序数组是【单个元素】，所以可以不断递归直至最后一个元素，下面看算法实现吧。 2-5-2、merge sort算法实现(js)123456789101112131415161718192021222324252627282930313233343536//理解：归并算法其实是递归算法的一个应用.var a = [34, 203, 3, 746, 200, 984, 198, 764, 9];function mergeSort(arr)&#123; if (arr.length &lt; 2) return arr; var middle = parseInt(arr.length / 2); var left = arr.slice(0, middle); var right = arr.slice(middle, arr.length); return merge(mergeSort(left), mergeSort(right));&#125; function merge(left, right)&#123; var result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; console.log(mergeSort(a)); It’s interesting to see what happens in the Firebug’s console: 1234567891011121314151617[34, 203, 3, 746] [200, 984, 198, 764, 9] [34, 203] [3, 746] [34] [203] [3] [746] [200, 984] [198, 764, 9] [200] [984] [198] [764, 9] [764] [9] [3, 9, 34, 198, 200, 203, 746, 764, 984] 2-6、堆排序(heap sort)2-6-1、heap sort概览【O(nlogn)】堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 2-6-2、heap sort算法实现[js]12345678910111213141516171819202122232425262728293031323334353637//思想：Array.prototype.heap_sort = function() &#123; var arr = this.slice(0); function swap(i, j) &#123; var tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; &#125; function max_heapify(start, end) &#123; //建立父節點指標和子節點指標 var dad = start; var son = dad * 2 + 1; if (son &gt;= end)//若子節點指標超過範圍直接跳出函數 return; if (son + 1 &lt; end &amp;&amp; arr[son] &lt; arr[son + 1])//先比較兩個子節點大小，選擇最大的 son++; if (arr[dad] &lt;= arr[son]) &#123;//如果父節點小於子節點時，交換父子內容再繼續子節點和孫節點比較 swap(dad, son); max_heapify(son, end); &#125; &#125; var len = arr.length; //初始化，i從最後一個父節點開始調整 for (var i = Math.floor(len / 2) - 1; i &gt;= 0; i--) max_heapify(i, len); //先將第一個元素和已排好元素前一位做交換，再從新調整，直到排序完畢 for (var i = len - 1; i &gt; 0; i--) &#123; swap(0, i); max_heapify(0, i); &#125; return arr;&#125;;var a = [3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6];console.log(a.heap_sort()); 2-7、快速排序(quick sort)2-7-1、quick sort算法概览[O(nlogn)]快速排序算法是以上7中算法中最快的，主要的想法是，随机在数列中选择一个作为参考，然后大于这个元素的发在右侧，小于这个元素的放在左侧，然后在左侧数列中在选择一个元素，重复上述操作，右侧也这样操作，直至最后数列元素只有一个。这样讲述可能不容易理解，可以参考维基百科中的动态图 2-7-2、quick sort算法实现[js]1234567891011121314151617181920212223242526272829303132333435363738//思想：随机选取数列中一个元素，然后基于该元素，分左右2组数列function swap(arr, i, j)&#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function partition(arr, pivot, left, right)&#123; var pivotValue = arr[pivot], partitionIndex = left; for(var i = left; i &lt; right; i++)&#123; if(arr[i] &lt; pivotValue)&#123; swap(arr, i, partitionIndex); partitionIndex++; &#125; &#125; swap(arr, right, partitionIndex); return partitionIndex;&#125; function quickSort(arr, left, right)&#123; var len = arr.length, pivot, partitionIndex; if(left &lt; right)&#123; pivot = right; partitionIndex = partition(arr, pivot, left, right); //sort left and right quickSort(arr, left, partitionIndex - 1); quickSort(arr, partitionIndex + 1, right); &#125; return arr;&#125; 2-8、总结国外友人写的不过的排序总结 三、查找算法3-1、二分查找四、参考《数据结构与算法Javascript描述》 《数据结构与算法C语言描述》 《大话数据结构》 算法与数据结构资源推荐 可视化的算法和数据结构网站 javascript数据结构实现——我的github 浙大数据结构与算法-视频]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux下遇到的问题]]></title>
      <url>%2Flinux%E4%B8%8B%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[缘由：这里集中记录下linux使用中碰到的问题 问题一、问题描述：给centos6.8配置virtualenv的时候，使用【pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple virtualenv】指令，出现错误：1python3.5: error while loading shared libraries: libpython3.5m.so.1.0: cannot open shared object file: No such file or directory 解决办法：一般这个路径找不到的问题，都是库的配置有问题 使用find指令找到库 1find / -name &quot;libpython3.5m.so.1.0&quot; 配置$LD_LIBRARY_PATH 1export LD_LIBRARY_PATH=/usr/local/lib/ /usr/local/lib/ 路径就是我的库所在位置 参考问题二、问题描述：查找指定文件夹下，某些文件是否包含指定字符串解决办法：例如我要查找【/Users/het/Desktop/hangblog/blog】文件夹下，后缀为【yml,html】的文件，那些含有【https://github.com/limhang】，指令如下：1grep -rnw &apos;/Users/het/Desktop/hangblog/blog&apos; -e &apos;https://github.com/limhang&apos; --include=\*.&#123;yml,html&#125; 参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[招聘狗拉钩项目]]></title>
      <url>%2Fproject%2F%E6%8B%9B%E8%81%98%E7%8B%97%E6%8B%89%E9%92%A9%E9%A1%B9%E7%9B%AE.html</url>
      <content type="text"><![CDATA[缘由：记录下之前做过的拉钩招聘狗自动显示项目吧 一、python爬虫获取招聘狗和拉钩网的数据1-1、开发准备工作python3开发环境，virtualenv虚拟环境安装pymysql库，这里可能会不好安装，可以用其他的类似的库替换安装requests库 二、将爬取的数据存入mysql数据库设置自己库的密码和数据库名字，这里看代码 三、编写php接口获取当天数据看代码 四、编写前端图表展示页面看代码 五、启动vps定时任务，实现自动获取数据，实时展示博客中有方法 github地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[dva框架学习]]></title>
      <url>%2Fdva%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0.html</url>
      <content type="text"><![CDATA[缘由：dva&amp;&amp;redux学习总结 一、遇到的问题1-1、es6语法所引起的问题1-1-1、对象处理相关问题 对象的再赋值eg1:input:1234let result0 = &#123;x:1,y:2&#125;;let result1 = &#123;x:2&#125;;let result = &#123;...result0,x:3&#125;;console.log(result); output:1Object &#123;x: 3, y: 2&#125; eg2:input:1234let result0 = &#123;x:1,y:2,z:3&#125;;let result1 = &#123;x:2,y:3&#125;;let result = &#123;...result0,...result1&#125;;console.log(result); output:1Object &#123;x: 2, y: 3, z: 3&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx配置常见问题]]></title>
      <url>%2Fbackend%2Fnginx%E9%85%8D%E7%BD%AE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[缘由：Nginx配置问题，location，error_log 问题一、location配置问题问题描述：想用nginx做反向代理，例如【/api/xxx/yyy】检测到/api后，通过location修改proxy_pass，但是location正则一直没法匹配上，一直匹配到【location /】 解决办法：应该是location正则匹配的优先级的问题，采用【location ~ /api/[^\/]+/[^\/]+】匹配 参考资料 问题二、ip:port无法生效问题描述：需要改变ip的默认port，例如：www.hang.com:81，在nginx中，将listen：81，但是还是无法正常访问 解决办法：之后想到可能是防火墙的原因，修改/etc/sysconfig/iptables，在iptables中添加81端口，然后重启iptables，命令：service iptables restart，这样修改之后还是不可以，这个时候想到可能是阿里云那边的安全限制，果然是这样，修改阿里云的esc下的安全组设置就可以了 参考资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[urlStore接口]]></title>
      <url>%2Finterface%2FurlStore%E6%8E%A5%E5%8F%A3.html</url>
      <content type="text"><![CDATA[缘由：UrlStore应用的接口 一、urlStore用户模块接口1-1、添加注册接口12url:http://urlapi.coderhelper.cn/v1_0/person/user/register请求方式：post 参数 说明 类型 username 账户 string password 密码 string 1-2、添加登录接口12url:http://urlapi.coderhelper.cn/v1_0/person/user/login请求参数：post 参数 说明 类型 username 账户 string password 密码 string 二、url内容发布接口2-1、发布url接口12url:http://urlapi.coderhelper.cn/v1_0/url/user/urlcreate请求参数：post 参数 说明 类型 token 令牌 string url 需要保持的网址 string category 分类 string tag 标签 string detail 详细描述 string 1&#123;"code":200,"info":"","datas":&#123;"category":"test","tag":"web","detail":"justFortest","userId":"7393ee8db55db7ea99070676e0029972","id":1&#125;&#125; 2-2、查询url[按页查询]接口12url:http://urlapi.coderhelper.cn/v1_0/url/user/urlquery请求参数：post 参数 说明 类型 token 令牌 string page 查询的页码 string pagenum 每页显示的数据 string item 查询的类型 1：category, 2:tag, 3:detail 不填：all category 分类查询字段 string tag 标签查询字段 string detail 详细查询字段 string 2-3、查询有哪些标签12url:http://url.coderhelper.cn/api/v1_0/url/user/urlquerytag请求参数：post |参数|说明|类型||token|令牌|string| 2-4、查询有哪些分类12url:http://url.coderhelper.cn/api/v1_0/url/user/urlquerycategory请求方式：post |参数|说明|类型||token|令牌|string|]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python3开发环境配置]]></title>
      <url>%2Fpython%2Fpython3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      <content type="text"><![CDATA[缘由：python3开发环境配置，该配置环境主要包括python3安装和python3虚拟隔离设置 一、python3安装关于python3的安装，可以参考virtualbox中的centos69box制作，在centos69box制作中，我已经将python3安装做成了脚本，可以直接运行。 二、virtualenv环境隔离设置关于python3的安装，也请参考centos69box制作文章]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scratch基础]]></title>
      <url>%2Fpython%2F%E7%88%AC%E8%99%AB%2Fscratch%E5%9F%BA%E7%A1%80.html</url>
      <content type="text"><![CDATA[缘由：顺着这次项目的机会，整理下爬虫相关的所有基础知识 一个爬虫程序，需要有以下几个模块。 一、网络接口模块【获取网络资源get post请求】1-1、基础请求处理精准定位元素模块【一个网页内容那么多，我们需要指定获取那些内容】反爬虫模块【主流网站都有反爬虫机制，比如：refer相关，ip限制，请求时间判断，验证码机制】异步请求处理模块【现在很多网页采用api接口设计方案，所有有很多ajax请求，xhr】以上，就是对爬虫程序，模块化的简单划分，其中，最复杂最难的部分，应该是反爬虫模块。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reactiveCocoa使用指南]]></title>
      <url>%2FiOS%2FreactiveCocoa%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html</url>
      <content type="text"><![CDATA[中文参考资料 replay使用 中文基础讲解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Objc的block中weakSelf和strongSelf用法]]></title>
      <url>%2FiOS%2FObjc%E7%9A%84block%E4%B8%ADweakSelf%E5%92%8CstrongSelf%E7%94%A8%E6%B3%95.html</url>
      <content type="text"><![CDATA[缘由：weakself和strongself用法解析 一、weakSelf和strongSelfObjective C 的 Block 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(retain cycle)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 ‘self-&gt;theVar’，’self’ 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。 Apple 官方的建议是，传进 Block 之前，把 ‘self’ 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。 eg:1234__weak __typeof__(self) weakSelf = self; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [weakSelf doSomething];&#125;); clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：12345__weak __typeof__(self) weakSelf = self; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [weakSelf doSomething]; [weakSelf doOtherThing];&#125;); 在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：123456__weak __typeof__(self) weakSelf = self; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; __strong __typeof(self) strongSelf = weakSelf; [strongSelf doSomething]; [strongSelf doOtherThing];&#125;); __strong 确保在 Block 内，strongSelf 不会被释放。 故： 在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。 如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。 二、weakify and strongify这就是我们在大多数 Objective-C 代码中看到的 weak/strong dance , 这样的写法运行起来没有问题，但是还是有不足之处。当有了新的需求，添加新的特性，block的定义会变得越来越长，越来越复杂，仍然会有可能在 block 中使用 self . 我们对此无法发觉 - 编译器的提示帮助只在一些简单的例子下。这就是 weakify 和 strongify 宏发挥作用的时候了。 @weakify 和 @strongify 的 Original implementation 比较复杂，因为他们接受多个参数。为了使分析简单一点，我们引用自己的版本，只接受一个参数: 123456#define weakify(var) __weak typeof(var) AHKWeak_##var = var;#define strongify(var) \_Pragma("clang diagnostic push") \_Pragma("clang diagnostic ignored \"-Wshadow\"") \__strong typeof(var) var = AHKWeak_##var; \_Pragma("clang diagnostic pop") 看下我们对这个宏的使用:1234567Model *model = [Model new];weakify(self);model.dataChanged = ^(NSString *title) &#123; strongify(self); self.label.text = tile;&#125;;self.model = model; 以上代码可以翻译为:1234567Model *model = [Model new];__weak typeof(self) AHKWeak_self = self;model.dataChanged = ^(NSString *title) &#123; __strong typeof(self) self = AHKWeak_self; self.label.text = tile;&#125;;self.model = model; 参考weakSelf和strongSelf参考 weakify and strongify]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[php调试小结]]></title>
      <url>%2Fbackend%2Fphp%E8%B0%83%E8%AF%95%E5%B0%8F%E7%BB%93.html</url>
      <content type="text"><![CDATA[缘由：排除一切不可能的，剩下的即使再不可能，那也是真相——Sherlock Holmes 一、php初级调试技巧使用nginx+php开发服务器，遇到500错误，是非常头痛的，良好的调试技巧，可以快速定位。 1-1、php.ini中设置display_errors 设置display_errors = On 重启php-fpm，使设置生效，service php-fpm restart上述的设置在开发环境中，是很有效的，可以直接将错误信息显示在浏览器上，但是生成环境千万不能这样做，这样会让黑客探测到很多服务器的信息，很容易被黑 1-2、php.ini中设置log_errors 设置log_errors = On error_log 设置错误信息存放文件，例如：”/usr/local/php56/var/log/php-error.log” 设置刚刚log文件的读写属性，我在这里被坑过一次，chmod 777 log 重启php-fpm，使设置生效，service php-fpm restart上述的设置可以在生成环境中使用，出现问题可以直接到指定文件夹中去找错误报告 1-3、php-fpm.conf中设置主要设置2个地方，一个是catch_workers_output = yes 一个是error_log = log/php-fpm.log也就是错误的位置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[time接口]]></title>
      <url>%2Finterface%2Ftime%E6%8E%A5%E5%8F%A3.html</url>
      <content type="text"><![CDATA[缘由：时间管理应用的接口 一、登录注册模块接口注册接口123url:http://time.coderhelper.cn/v1_0/person/user/register请求方式：post参数：username password 登录接口123url:http://time.coderhelper.cn/v1_0/person/user/login请求方式：post参数：username password 二、时间管理模块接口添加时间项目接口12url:http://time.coderhelper.cn/v1_0/time/user/timecreate请求方式：post 参数 说明 类型 duration 时长 string timedesc 详细说明 string timeType 时间分类 string token 令牌指定用户 string loadTime 上传当天时间 string 查询用户某天时间详细接口12url:http://time.coderhelper.cn/v1_0/time/user/timequery请求参数：get 参数 说明 类型 token 用户标识令牌 string time 查询那一天 string]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql数据库基础]]></title>
      <url>%2Fbackend%2Fmysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80.html</url>
      <content type="text"><![CDATA[缘由：做个记录，方便查看，都是很简单的东西，久了不写就忘 一、创建数据库，给用户赋予权限创建数据库1create database time; 给用户权限1grant all privileges on *.* to jacob@localhost identified by &apos;password&apos; with grant option; 二、创建表12345678910CREATE TABLE users( id INT NOT NULL AUTO_INCREMENT, status INT NOT NULL, vip_level INT NOT NULL, username VARCHAR(50) NOT NULL, password VARCHAR(50) NOT NULL, publish_time VARCHAR(80) NOT NULL, token VARCHAR(200) NOT NULL, PRIMARY KEY ( id ))ENGINE=InnoDB DEFAULT CHARSET=utf8;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[centos6.9安装python3环境]]></title>
      <url>%2Fbackend%2Fcentos6-9%E5%AE%89%E8%A3%85python3%E7%8E%AF%E5%A2%83.html</url>
      <content type="text"><![CDATA[缘由：阿里云多语言版本无python3开发环境，安装python3开发环境 1、安装编译python的组件gcc等12yum install gccyum groupinstall &quot;Development tools&quot; 2、再安装依赖包1yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 3、下载Python3.5的源码包并编译123456wget https://www.python.org/ftp/python/3.5.2/Python-3.5.2.tgz #其中3.5.2可修改成自己想要的版本tar xf Python-3.5.2.tgzcd Python-3.5.2./configure --prefix=/usr/local --enable-shared #把python3安装在此目录，这里注意下，后面有详解makemake install 4、创建Python3.5软连接1ln –s /usr/local/bin/python3 /usr/bin/python3 #记住这些目录很重要 5、出现错误error while loading shared libraries: xxxxxxxx: cannot open shared object file: No such file or directory（xxxx为文件名） 解决办法：我是采用修改bash_profile 1export LD_LIBRARY_PATH=/usr/local/lib/ 6、参考python3安装–简书qq]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[photo接口]]></title>
      <url>%2Finterface%2Fphoto%E6%8E%A5%E5%8F%A3.html</url>
      <content type="text"><![CDATA[photo接口缘由：photo接口说明文档 一、基础模块接口：1-1、基础教程列表1http://39.108.82.4/v1_0/common/baseInfo/lists 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&#123; "code": 200, "info": "", "datas": &#123; "lists": [ &#123; "id": 10, "status": 1, "title": "日常保养", "des": "用专业的清洁器材，配合特定手法，才能进行有效清洁", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/maintain_2/maintain_2_img_02.jpg", "webUrl": "http://39.108.82.4/photo/dailyMaintenance.html" &#125;, &#123; "id": 9, "status": 1, "title": "选择合适的对焦模式", "des": "选择合适的对焦模式", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/focus_2/focus_2_img_01.jpg", "webUrl": "http://39.108.82.4/photo/focusMode.html" &#125;, &#123; "id": 8, "status": 1, "title": "曝光补偿", "des": "曝光补偿的基础知识", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/exposure_2/exposure_2_img_01.jpg", "webUrl": "http://39.108.82.4/photo/exposureCompensation.html" &#125;, &#123; "id": 7, "status": 1, "title": "镜头的乐趣", "des": "世界随镜头而变——来享受单反/无反相机更换镜头的乐趣吧", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/enjoy_nikkel/en_img_01.jpg", "webUrl": "http://39.108.82.4/photo/sceneFun.html" &#125;, &#123; "id": 6, "status": 1, "title": "PASM模式", "des": "手动曝光模式——实现照片创意的基石", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/pasm/pasm_img_01.jpg", "webUrl": "http://39.108.82.4/photo/pasmPattern.html" &#125;, &#123; "id": 5, "status": 1, "title": "光圈快门感光度", "des": "控制照片的亮度——光圈、快门速度、感光度", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/asiso/asiso_img_01.jpg", "webUrl": "http://39.108.82.4/photo/apertureShutterSensitivity.html" &#125;, &#123; "id": 4, "status": 1, "title": "焦点", "des": "准确合焦，让照片清晰起来", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/focus/focus_img_01.jpg", "webUrl": "http://39.108.82.4/photo/focus.html" &#125;, &#123; "id": 3, "status": 1, "title": "白平衡", "des": "白平衡——照片色调的奥秘", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/white_balance/wb_img_01.jpg", "webUrl": "http://39.108.82.4/photo/colorBalance.html" &#125;, &#123; "id": 2, "status": 1, "title": "相机的基本持握方式", "des": "先来掌握相机的握持方法和拍摄姿势吧", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/hold_way/hold_way_img_01.jpg", "webUrl": "http://39.108.82.4/photo/holdingCameraRightWay.html" &#125;, &#123; "id": 1, "status": 1, "title": "构图", "des": "视角和构图，好照片的基础", "img": "http://www.nikon.com.cn/microsite/beginnertutor/common/images/base_knowledge/composition_pic/composition_pic_img_01.jpg", "webUrl": "http://39.108.82.4/photo/composition.html" &#125; ] &#125;&#125; 二、答疑模块接口2-1、获取指定模块的数据12345678910111213141516171819202122232425262728293031323334353637http://39.108.82.4/v1_0/common/quoraInfo/lists/5``` * 参数 后缀为5：夜景 注意：如果参数传10，则获取所有数据* 参数取值 1-9，代表9中不同模块，分别是，器材基础知识.摄影基础知识.基础技巧.人像.夜景.风光.运动.微距.配件&amp;闪光灯```js&#123; &quot;code&quot;: 200, &quot;info&quot;: &quot;&quot;, &quot;datas&quot;: &#123; &quot;lists&quot;: [ &#123; &quot;id&quot;: 34, &quot;status&quot;: 5, &quot;classify&quot;: &quot;夜景&quot;, &quot;question&quot;: &quot;怎样才能把水族馆里的鱼拍得很漂亮？&quot;, &quot;answer&quot;: &quot;在水族馆里拍摄鱼类时要隔着玻璃，由于玻璃会反光，周围的景色也会投影在玻璃上。特别是水箱中光线较暗、周围比较明亮的时候，玻璃会像镜子一样反光。在这种条件下，如果镜头不紧贴住玻璃，由于玻璃上的投影，水槽中的画面就会显得不够鲜明。为了防止出现这种现象，拍摄时镜头的前端要与玻璃表面垂直紧贴。如果镜头与玻璃表面不成直角，就容易拍摄到投影。因为水箱中光线较暗，鱼的游动速度也很快，所以要将ISO感光度提高。另外，在很难自动对焦时，要使用手动对焦（MF）模式手动进行对焦。有些水族馆禁止在拍摄时使用闪光灯。即使并未禁止，由于玻璃会反射光线，还是不使用闪光灯为好。&quot; &#125;, &#123; &quot;id&quot;: 33, &quot;status&quot;: 5, &quot;classify&quot;: &quot;夜景&quot;, &quot;question&quot;: &quot;在拍摄夜景时，为何迟迟无法再次按下快门？&quot;, &quot;answer&quot;: &quot;因为夜景比白天光线弱，故快门速度也比白天慢很多。虽然快门速度与ISO感光度、夜景的亮度等都有关系，但一般情况下拍摄夜景的曝光时间会超过1秒。但是，如果数码相机长时间曝光，或者用超高感光度拍摄，照片就会有粗糙的感觉，容易出现噪点。因此，在将拍摄的照片存储到存储卡中时，相机就会启动“降噪功能”来减少噪点。降噪处理需要的时间和曝光的时间基本相同，因此造成迟迟无法再次按下快门。相机的初始设置里降噪功能是开启的，如果将其关闭，拍摄夜景时也可以实现连拍。&quot; &#125;, &#123; &quot;id&quot;: 32, &quot;status&quot;: 5, &quot;classify&quot;: &quot;夜景&quot;, &quot;question&quot;: &quot;夜景拍摄得过于明亮时应该怎么办？&quot;, &quot;answer&quot;: &quot;在拍摄夜景时，照片的亮度会根据亮部与暗部的比例不同而不同。如果照片中暗部（较黑的部分）较多，那么相机就会把夜景拍得更明亮；如果亮部（较白的部分）较多，那么相机就会把夜景拍得更暗一些。夜景被拍得过于明亮，就是由于相机判断画面中暗部的比例过大造成的。##如果感觉夜景照片过于明亮，拍摄时可以对曝光进行负补偿。进行负补偿后，照片整体会变暗。反之，如果画面上霓虹灯或灯光装饰等明亮的光线过多，拍摄时照片整体就会变暗。这种情况需要对曝光进行正补偿。##此外，这并不局限于夜景，在拍摄风景或生活照时这一规则也同样适用。比如，如果雪景被拍得过暗，则可以对曝光进行正补偿；如果阴暗处的照片过于明亮，则可以进行负补偿，最终拍出满意的照片。&quot; &#125; ] &#125;&#125; 2-2、查询答疑模块数据1http://39.108.82.4/v1_0/common/quoraInfo/searchQuora/焦点 参数 焦点 查询答疑模块数据 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; "code": 200, "info": "", "datas": &#123; "lists": [ &#123; "id": 40, "status": 7, "classify": "运动", "question": "拍摄运动物体时，怎样才能不错过精彩瞬间？", "answer": "在拍摄孩子、动物等运动毫无规律的对象时，连续AF模式的效果最好，它在半按快门时焦点能够一直追踪被摄体。但是，如果被摄体在自动对焦区域之外，就必须目不转睛地盯着取景框之中的被摄体，以防错失拍摄良机。##如果要拍摄交通工具等沿着固定轨道运行的物体或者是能够预测运动轨迹的物体，则可以将相机设定为手动对焦（MF）模式，在要拍摄的位置使用可以提前完成对焦的“预对焦”，这将会给拍摄带来很大的便利。“预对焦”完成后，拍摄者就可以在被摄体到达焦点位置的瞬间直接按下快门，捕捉到拍摄时机。" &#125;, &#123; "id": 39, "status": 7, "classify": "运动", "question": "拍摄运动中的物体时应该怎么对焦？", "answer": "在相机的初始设定中，相机自动对焦模式（AF模式）为单次AF。在这种模式下，对焦后焦点的位置固定，在拍摄静物时可以对焦。##但是，在拍摄运动中的物体时，因为从对焦之后到按下快门的瞬间被摄体发生了移动，如果使用单次AF，焦点就会不对，因此，在拍摄运动的物体时要把自动对焦模式设定为连续AF。这样，只要被摄体在对焦框之内，在半按快门时焦点就会一直追踪被摄体，所以即使被摄体在运动中，也能够拍摄出对焦的照片。" &#125;, &#123; "id": 38, "status": 7, "classify": "运动", "question": "在拍摄运动的对象时，使用“运动”模式好吗？", "answer": "运动模式在模式盘上用一个跑步者的图标来表示。选择这个模式时，相机会自动设置各种参数，以适合拍摄速度很快的运动场景，非常方便。在运动模式下，相机可以根据焦距、最大光圈、现场的亮度等因素自动设定ISO感光度，用尽可能高的快门速度进行曝光。而且，相机会将自动对焦切换为在半按快门期间可以一直追踪焦点的连续AF模式。使用运动模式拍摄好动的孩子或宠物也很方便。但上述设定全部由相机自动设置，拍摄者连曝光补偿等也无法调节。我们建议精通各种拍摄参数的摄影高手选择“S”模式，这样比较容易根据被摄体和现场情况来进行调整。" &#125;, &#123; "id": 37, "status": 6, "classify": "风光", "question": "在拍摄风景时，焦点在哪儿最好？", "answer": "对焦的基本要领就是将焦点对准被摄体。即使是拍摄大范围的风景，风景之中也一定会有自己最为关注的部分。如果不把焦点对准那个部分，就无法传递出自己的意图，观众就会不明白照片到底想要表达些什么。##在拍摄时，建议拍摄者将对焦点设置为“中央”，并使想要拍摄的物体位于取景器的中心，然后进行对焦，在半按快门的状态下对构图进行再次调整。而且，拍摄者还可以先确定构图，再选择位于想要对焦的位置的对焦点。" &#125;, &#123; "id": 16, "status": 2, "classify": "摄影基础知识", "question": "什么是“景深”？", "answer": "对焦后在焦点前后能够清晰成像的范围叫做“景深”。如果收缩镜头光圈（增大F值），对焦后清晰成像的范围就大，照片就不容易虚化，这种状态叫做“大景深”。反之，如果开放镜头光圈（减少F值），对焦范围就狭窄，背景就容易出现虚化，这种状态叫做“浅景深”。因为景深对于拍摄的影响很大，所以在拍摄时一定要认识到它的重要性。##景深根据镜头焦距及相机与被摄体之间距离的变化而变化。广角镜头的景深大，长焦镜头的景深浅。而且，相机与被摄体之间的距离越远，景深就越大；距离越近，景深就越浅。" &#125; ] &#125;&#125; 三、鉴赏模块接口3-1、图片查询接口1http://39.108.82.4/v1_0/common/photoViewInfo/lists 注意：返回的url中后面有’\n’需要去掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&#123; "code": 200, "info": "", "datas": &#123; "lists": [ &#123; "id": 18, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Sydney,%20Australia.jpg" &#125;, &#123; "id": 17, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Bu%CC%81%C3%B0ir-%20at%20the%20end%20of%20the%20road.jpg" &#125;, &#123; "id": 16, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Bamboo%20forest%20Kyoto%202.jpg" &#125;, &#123; "id": 15, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Amsterdam%20II.jpg" &#125;, &#123; "id": 14, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Algarve,%20Portugal.jpg" &#125;, &#123; "id": 13, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Afternoon%20sunlight.jpg" &#125;, &#123; "id": 12, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/EMPIRE%20STATE.jpg" &#125;, &#123; "id": 11, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Go%C5%82ucho%CC%81w%20Castle.jpg" &#125;, &#123; "id": 10, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Half%20Tower.jpg" &#125;, &#123; "id": 9, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Dresden,%20German.jpg" &#125;, &#123; "id": 8, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Great%20Smoky%20Mountains,%20U.S..jpg" &#125;, &#123; "id": 7, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/fishing.jpg" &#125;, &#123; "id": 6, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Hallstatt,%20Austria.jpg" &#125;, &#123; "id": 5, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/France,%20Europe,.jpg" &#125;, &#123; "id": 4, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/breidavik%20church...jpg" &#125;, &#123; "id": 3, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Guardian%20of%20heaven.jpg" &#125;, &#123; "id": 2, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Glass%20lake....jpg" &#125;, &#123; "id": 1, "imgUrl": "http://oqv1anv8e.bkt.clouddn.com/Foggy%20Morning.jpg" &#125; ] &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[phantomJS使用指南]]></title>
      <url>%2F%E7%88%AC%E8%99%AB%2FphantomJS%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html</url>
      <content type="text"><![CDATA[缘由：phantomjs初体验 一、安装指南1-1、依赖库的安装1yum install fontconfig freetype freetype-devel fontconfig-devel libstdc++ 1-2、下载安装包需要自行结合自己系统版本，32位还是64位例子：1wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-1.9.8-linux-x86_64.tar.bz2 查看自己系统的版本：1cat /proc/version 1-3、初始化 创建文件夹 1mkdir -p /opt/phantomjs 解压下载包 1tar -xjvf ~/downloads/phantomjs-1.9.8-linux-x86_64.tar.bz2 -C /opt/phantomjs/ 全局使用 1ln -s /opt/phantomjs/bin/phantomjs /usr/bin/phantomjs 1-4、测试是否安装成功1phantomjs /opt/phantomjs/examples/hello.js 二、基本使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阿里云lumen开发环境配置]]></title>
      <url>%2Fbackend%2F%E9%98%BF%E9%87%8C%E4%BA%91lumen%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      <content type="text"><![CDATA[缘由：阿里云做活动，9元半年vps，就体验了下，在国内用阿里云还是有保障的，今天记录下lumen开发环境的配置 一、安装composer 安装composer的4行代码如下： 1234567php -r &quot;copy(&apos;https://getcomposer.org/installer&apos;, &apos;composer-setup.php&apos;);&quot;php -r &quot;if (hash_file(&apos;SHA384&apos;, &apos;composer-setup.php&apos;) === &apos;669656bab3166a7aff8a7506b8cb2d1c292f042046c5a994c43155c0be6190fa0355160742ab2e1c88d40d5be660b410&apos;) &#123; echo &apos;Installer verified&apos;; &#125; else &#123; echo &apos;Installer corrupt&apos;; unlink(&apos;composer-setup.php&apos;); &#125; echo PHP_EOL;&quot;php composer-setup.phpphp -r &quot;unlink(&apos;composer-setup.php&apos;);&quot; 将composer做成全局的 1sudo mv composer.phar /usr/local/bin/composer 二、安装lumen 配置Composer中国镜像，国内用户都懂得。 1composer config -g repo.packagist composer https://packagist.phpcomposer.com 建立一个目录为lumen的项目 1composer create-project --prefer-dist laravel/lumen lumen 三、安装中出现的问题12[Symfony\Component\Process\Exception\RuntimeException] The Process class relies on proc_open, which is not available on your PHP installation. 解决办法：1231.找到php.ini文件，搜索disable_functions2.删除搜索到的这一行3.[参考的资料](https://stackoverflow.com/questions/19911737/laravel4-composer-install-got-proc-open-not-available-error) 四、使用lumen中遇到的问题4-1、nginx配置问题查找lumen的root路径配置，发现只用定位到public文件夹就可以了nginx配置中的index.xxx后缀文件配置也是挺烦的我的阿里云nginx配置文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108user www www;worker_processes auto;error_log /data/wwwlogs/error_nginx.log crit;pid /var/run/nginx.pid;worker_rlimit_nofile 51200;events &#123; use epoll; worker_connections 51200; multi_accept on;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log logs/access.log main; server_names_hash_bucket_size 128; client_header_buffer_size 32k; large_client_header_buffers 4 32k; client_max_body_size 1024m; client_body_buffer_size 10m; sendfile on; tcp_nopush on; keepalive_timeout 120; server_tokens off; tcp_nodelay on; fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; fastcgi_intercept_errors on; #Gzip Compression gzip on; gzip_buffers 16 8k; gzip_comp_level 6; gzip_http_version 1.1; gzip_min_length 256; gzip_proxied any; gzip_vary on; gzip_types text/xml application/xml application/atom+xml application/rss+xml application/xhtml+xml image/svg+xml text/javascript application/javascript application/x-javascript text/x-json application/json application/x-web-app-manifest+json text/css text/plain text/x-component font/opentype application/x-font-ttf application/vnd.ms-fontobject image/x-icon; gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;; #If you have a lot of static files to serve through Nginx then caching of the files&apos; metadata (not the actual files&apos; contents) can save some latency. open_file_cache max=1000 inactive=20s; open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on;######################## default ############################ server &#123; listen 80; server_name _; root /data/lumen/public; index index.php index.html index.htm; access_log /data/wwwlogs/access_nginx.log main; location /nginx_status &#123; stub_status on; access_log off; allow 127.0.0.1; deny all; &#125; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ [^/]\.php(/|$) &#123; #fastcgi_pass remote_php_ip:9000; fastcgi_pass unix:/dev/shm/php-cgi.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi.conf; &#125; location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ &#123; expires 30d; access_log off; &#125; location ~ .*\.(js|css)?$ &#123; expires 7d; access_log off; &#125; location ~ /\.ht &#123; deny all; &#125; &#125;########################## vhost ############################# include vhost/*.conf;&#125; 4-2、.env环境配置在lumen中，配置开发环境是通过.env文件进行的，出现的错误是无法连接到数据库，这个定位也花了好久时间，最终的错误是，我使用的阿里云多语言环境设置里，连接数据库只能通过localhost，而.env环境中写的是ip地址，127.0.0.1修改127.0.0.1为localhost就可以了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[shadowsocks配置须知]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2Fshadowsocks%E9%85%8D%E7%BD%AE%E9%A1%BB%E7%9F%A5.html</url>
      <content type="text"><![CDATA[缘由：记录下shadowsocks的基本配置，方便今后查找 一、VPS上安装shadowsocks1pip install shadowsocks 二、配置文件配置123456789101112131415161718192021&#123; "server":"138.128.198.147", "timeout":600, "method":"aes-256-cfb", "port_password": &#123; "9000":"hehe", "9001":"haha", "9002":"xiaozuo", "9003":"zhanyuan", "9004":"minghang" &#125;, "_comment": &#123; "9000":"hehe", "9001":"haha", "9002":"xiaozuo", "9003":"zhanyuan", "9004":"minghang" &#125;&#125; 三、启动服务将配置文件保存为/etc/shadowsocks/config.json，然后按配置文件启动shadowsocks：1ssserver -c /etc/shadowsocks/config.json -d start 停止shadowsocks服务：1ssserver -d stop]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[对于未知的恐惧]]></title>
      <url>%2Flife%2F%E5%AF%B9%E4%BA%8E%E6%9C%AA%E7%9F%A5%E7%9A%84%E6%81%90%E6%83%A7.html</url>
      <content type="text"><![CDATA[缘由：总有些东西一直萦绕在心头，散不去，道不明，有时如鲠在喉，忆起不知所措。 对于未知，人总是有恐惧的，这种恐惧是一直伴随着人的一生。从我们懵懂哭啼时，这个恐惧就已存在。婴儿离开熟悉的子宫环境，进入人世间，出于对未知的恐惧，有了第一声啼哭。曾经有一个实验，将一个幼童，放在高置的透明玻璃上，母亲在另一端，引导幼童爬向自己。在孤立无援的环境下，母亲，是幼童唯一的依靠，在母亲爱意的指引下，幼童成功走出困境。当然，实验都是有对照组，没有母亲引导的幼童，只能停留在原地，不停哭泣，无助。陌生的环境，人类天生的恐高，透明的玻璃，这些构成了一个未知恐惧的环境。 当我们上学时，老师，家长，告诉我们，上学考试。这个时候，大家都是上学考试，最后参加高考，这个时候的老师，家长，就是站在透明玻璃旁的母亲。我们就是高耸透明玻璃上的孩童，一切都没有变。但是当我们完成基础教育，参加完高考后，一切都变了，在也没有一个大众认为的标准指引，我们又变成了玻璃板上的孩童，不知何去何从，又像迷失在沙漠中。 对于未知的恐惧，一直支配着你，不论何时不论何地无论谁，大神如，jobs，在大学辍学时，也坦诚当时非常害怕。许多的年轻人，都希望，有一个人生的导师，可以指引方向，告诉你，未来在哪里，那些事是确定的，是有把握的。但是，未来确定的，就是一切都是不确定的，诸行无常。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小程序初体验]]></title>
      <url>%2Fweb%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%9D%E4%BD%93%E9%AA%8C.html</url>
      <content type="text"><![CDATA[缘由：体验体验，渐渐的明白了一个道理，很多的套路和操作，并非“无源之水，无本之木”，从web1.0到web2.0，从移动互联网到知识经济，从粉丝效应到内容营销，从社交软件群控到大平台联盟，它们之间有着各种套路和操作，但是这些之间当真没有联系嘛-_-… 一、基本概念1-1、入门必知在小程序中最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。 app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据。 123456789101112131415161718192021222324252627282930//app.jsApp(&#123; onLaunch: function () &#123; //调用API从本地缓存中获取数据 var logs = wx.getStorageSync('logs') || [] logs.unshift(Date.now()) wx.setStorageSync('logs', logs) &#125;, getUserInfo:function(cb)&#123; var that = this; if(this.globalData.userInfo)&#123; typeof cb == "function" &amp;&amp; cb(this.globalData.userInfo) &#125;else&#123; //调用登录接口 wx.login(&#123; success: function () &#123; wx.getUserInfo(&#123; success: function (res) &#123; that.globalData.userInfo = res.userInfo; typeof cb == "function" &amp;&amp; cb(that.globalData.userInfo) &#125; &#125;) &#125; &#125;); &#125; &#125;, globalData:&#123; userInfo:null &#125;&#125;) app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。 123456789101112&#123; "pages":[ "pages/index/index", "pages/logs/logs" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle":"black" &#125;&#125; app.wxss 是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。 12345678910/**app.wxss**/.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box;&#125; 二、创建页面相关2-1、创建页面前准备工作微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。 每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。 index.wxml 是页面的结构文件： 12345678910&lt;!--index.wxml--&gt;&lt;view class=&quot;container&quot;&gt; &lt;view bindtap=&quot;bindViewTap&quot; class=&quot;userinfo&quot;&gt; &lt;image class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;usermotto&quot;&gt; &lt;text class=&quot;user-motto&quot;&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 本例中使用了、、来搭建页面结构，绑定数据和交互处理函数。 index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。 1234567891011121314151617181920212223242526//index.js//获取应用实例var app = getApp()Page(&#123; data: &#123; motto: 'Hello World', userInfo: &#123;&#125; &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;) &#125;, onLoad: function () &#123; console.log('onLoad') var that = this //调用应用实例的方法获取全局数据 app.getUserInfo(function(userInfo)&#123; //更新数据 that.setData(&#123; userInfo:userInfo &#125;) &#125;) &#125;&#125;) index.wxss 是页面的样式表： 12345678910111213141516171819202122/**index.wxss**/.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125;.userinfo-avatar &#123; width: 128rpx; height: 128rpx; margin: 20rpx; border-radius: 50%;&#125;.userinfo-nickname &#123; color: #aaa;&#125;.usermotto &#123; margin-top: 200px;&#125; 页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。 index.json 是页面的配置文件： 页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS基础汇总]]></title>
      <url>%2FiOS%2FiOS%E5%9F%BA%E7%A1%80%E6%B1%87%E6%80%BB.html</url>
      <content type="text"><![CDATA[缘由：好久都没有写原生iOS应用了，很多的东西都忘的差不多了，之前也有做过零零散散的笔记，这里对这次开发做个记录，汇总下iOS开发的基础知识，这样就不怕以后又忘记了。 零、list about what i need0-0、 一、常用技巧知识1-1、xcode使用相关1-1-1、建立新的文件夹 1.$cd 到你要创建文件夹的目录。 2.终端输入$ mkdir View。 3.将创建好的文件夹拖入工程点Copy就OK了。注意：蓝色文件夹（folder）一般作为资源文件夹使用，与黄色文件夹（groups）的主要区别是不参与编译，所以在上述步骤中，如果是代码文件就选择groups的。 二、网络请求1-1、YTKNetwork1-1-1、基本使用 1-1-2、上传图片数组需求：上传一个图片数组，与服务端的kw是：img，数组元素是NSData代码：12345678910111213- (AFConstructingBlock)constructingBodyBlock &#123; return ^(id&lt;AFMultipartFormData&gt; formData) &#123; for (int i = 0;i &lt; _img.count; i++)&#123; NSData *data = UIImageJPEGRepresentation(_img[i], 0.5); if ((float)data.length/1024 &gt; 1000) &#123; data = UIImageJPEGRepresentation(_img[i], 1024*1000.0/(float)data.length); &#125; NSString *name = [NSString stringWithFormat:@"image%d.png",i]; NSString *type = @"image/jpeg"; [formData appendPartWithFileData:data name:@"img" fileName:name mimeType:type]; &#125; &#125;;&#125; 三、时间处理1-1、零时区，东八区时间转换需求：服务器传给客户端的是零时区，我们处在东8区，所以客服端需要显示的时间要在零时区上加8小时。服务器返回的格式为：xxxx-xx-xx xx-xx-xx，那么：代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//将服务器返回的字符串转为nsdate+ (NSDate *)stringToDate: (NSString *)string &#123; NSAssert(string, @"Parameter 'string' should not be nil"); static NSDateFormatter *_dateFormatter = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _dateFormatter = [[NSDateFormatter alloc] init]; &#125;); [_dateFormatter setDateFormat: @"yyyy-MM-dd HH:mm:ss +0000"]; NSDate *destDate= [_dateFormatter dateFromString: string]; return destDate;&#125;//将任意类型的nsdate转换为东8区的nsdate+(NSDate *)getNowDateFromatAnDate:(NSDate *)anyDate&#123; //设置源日期时区 NSTimeZone* sourceTimeZone = [NSTimeZone timeZoneWithAbbreviation:@"UTC"];//或GMT //设置转换后的目标日期时区 NSTimeZone* destinationTimeZone = [NSTimeZone localTimeZone]; //得到源日期与世界标准时间的偏移量 NSInteger sourceGMTOffset = [sourceTimeZone secondsFromGMTForDate:anyDate]; //目标日期与本地时区的偏移量 NSInteger destinationGMTOffset = [destinationTimeZone secondsFromGMTForDate:anyDate]; //得到时间偏移量的差值 NSTimeInterval interval = destinationGMTOffset - sourceGMTOffset; //转为现在时间 NSDate* destinationDateNow = [[NSDate alloc] initWithTimeInterval:interval sinceDate:anyDate]; return destinationDateNow;&#125;//将nsdate转换为字符串xxxx-xx-xx xx-xx-xx+ (NSString *)dateToString: (NSDate *)date &#123; NSAssert(date, @"Parameter 'date' should not be nil"); NSCalendar *calendar = [NSCalendar currentCalendar]; NSUInteger unitFlags = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond; NSDateComponents *dateComponent = [calendar components:unitFlags fromDate: date]; NSInteger year = [dateComponent year]; NSInteger month = [dateComponent month]; NSInteger day = [dateComponent day]; NSInteger hour = [dateComponent hour]; NSInteger minute = [dateComponent minute]; NSString *dateStr = [NSString stringWithFormat:@"%d-%d-%d %d:%d",(int)year,(int)month,(int)day,(int)hour,(int)minute]; return dateStr;&#125; 三、UI相关3-1、label控件 计算label的宽度1、获取多行文字size的方法1234- (CGRect)boundingRectWithSize:(CGSize)size options:(NSStringDrawingOptions)options attributes:(NSDictionary *)attributes context:(NSStringDrawingContext *)context NS_AVAILABLE_IOS(7_0);//使用方法CGSize titleSize = [testString boundingRectWithSize:CGSizeMake(200, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:14]&#125; context:nil].size; 2、获取单行文字size的方法123NSString *testString = @"我要测试一下文字内容的长度哦,不要一定非常准确,但是也可能非常正确,我就是用来测试文字行数才弄这么多字数在这里,呵呵,赶紧运行看看结果吧,不过你要记录一下单行计算下的size数值,后面会用来做比对的.";// 计算一下14号字体的情况下,size的结果CGSize size =[testString sizeWithAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:14]&#125;]; label省略号显示问题123456NSLineBreakByWordWrapping = 0 //以空格为边界，保留单词。NSLineBreakByCharWrapping //保留整个字符NSLineBreakByClipping //简单剪裁，到边界为止NSLineBreakByTruncatingHead //前面部分文字以……方式省略，显示尾部文字内容NSLineBreakByTruncatingTail //结尾部分的内容以……方式省略，显示头的文字内容。NSLineBreakByTruncatingMiddle //中间的内容以……方式省略，显示头尾的文字内容。 3-2、searchBar控件 点击取消按钮，退出当前界面，主要的问题在于当searchbar退出焦点后，canclebtn是处于disable状态 四、内存管理相关4-1、内存管理基础属性介绍：copy和strong；可变和不可变数据结构：NSString和NSMutableString，NSArray和NSMutableArray，NSDictionary和NSMutableDictionary深拷贝和浅拷贝 理解这张图就够了： 上图中需要注意的是如果源对象和副本对象都是不可变类型，那么这个复制是属于浅拷贝，也就是说只是指针的复制，想想为什么，这里可以在项目中实际打印出地址看看12345678910111213141516171819202122232425262728#import "Jacob.h"@interface Jacob ()@property (nonatomic, copy)NSString *jacobstring;@property (nonatomic, copy)NSString *jacobCopyString;@property (nonatomic, strong)NSMutableArray *Mutablearray;@property (nonatomic, copy)NSArray *array;@end@implementation Jacob- (void)getMessage &#123; NSLog(@"message : %@",_name); self.jacobstring = @"xxx"; self.jacobCopyString = self.jacobstring; NSLog(@"string = %p copyString = %p ", self.jacobstring, self.jacobCopyString); NSLog(@"before:string=%@ copyString=%@",self.jacobstring, self.jacobCopyString); self.jacobstring = @"yyy"; NSLog(@"string = %p copyString = %p ", self.jacobstring, self.jacobCopyString); NSLog(@"before:string=%@ copyString=%@",self.jacobstring, self.jacobCopyString); self.array = @[@"1",@"2"]; self.Mutablearray = [self.array mutableCopy]; [self.Mutablearray addObject:@"3"]; NSLog(@"%@",self.Mutablearray);&#125;@end]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx配置信息]]></title>
      <url>%2Fbackend%2Fnginx%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF.html</url>
      <content type="text"><![CDATA[缘由：nginx配置信息示例，如下，方便以后查看 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /var/run/nginx.pid;# Load dynamic modules. See /usr/share/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125; http &#123; server &#123; listen 80; server_name localhost; root /usr/share/nginx/html; autoindex on; autoindex_exact_size off; autoindex_localtime on; include /etc/nginx/mime.types; #告诉客户端 不缓存 静态资源文件 add_header Cache-Control no-cache; location ~.*\.(js|css|html|png|jpg)$ &#123; #expires 3d; &#125; location / &#123; index index.html index.htm index.php; try_files $uri $uri/ /index.php$is_args$args; &#125; location ~ \.php &#123; fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock; #fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; #fastcgi_param PATH_INFO $fastcgi_script_name; include fastcgi_params; &#125; &#125; server &#123; listen 80; server_name api.lmhang.com; root /usr/share/nginx/html/lumen/public/index.php; autoindex on; autoindex_exact_size off; autoindex_localtime on; include /etc/nginx/mime.types; #告诉客户端 不缓存 静态资源文件 add_header Cache-Control no-cache; location ~.*\.(js|css|html|png|jpg)$ &#123; #expires 3d; &#125; location / &#123; index index.html index.htm index.php; try_files $uri $uri/ /index.php$is_args$args; &#125; location ~ \.php &#123; fastcgi_pass unix:/var/run/php-fpm/php-fpm.sock; #fastcgi_pass 127.0.0.1:8500; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; #fastcgi_param PATH_INFO $fastcgi_script_name; include fastcgi_params; &#125; &#125; &#125; nginx相关操作nginx -s reload ：修改配置后重新加载生效nginx -s reopen ：重新打开日志文件nginx -t -c /path/to/nginx.conf 测试nginx配置文件是否正确 关闭nginx：nginx -s stop :快速停止nginx quit ：完整有序的停止nginx 其他的停止nginx 方式： ps -ef | grep nginx kill -QUIT 主进程号 ：从容停止Nginxkill -TERM 主进程号 ：快速停止Nginxpkill -9 nginx ：强制停止Nginx 启动nginx:nginx -c /path/to/nginx.conf 平滑重启nginx：kill -HUP 主进程号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[seo资料]]></title>
      <url>%2F%E7%88%AC%E8%99%AB%2Fseo%E8%B5%84%E6%96%99.html</url>
      <content type="text"><![CDATA[缘由：开始准备系统的学习下seo了，这里总结记录下收集到的资源 英文：authorityHacker backlinko 中文： 在SEO网站优化的过程中，多数人讲网站优化，就是讲网站的架构，关键字，标题，描述，dofollow，nofollow，sitemap，伪静态，H标签，关键字密度，Css，CDN…. 这些要素我也经常讲,对Google来讲也是相当重要。但是各位，一个网站真正能不能成功，有没有流量，这些要素只是部分的影响因素，真正起作用的不在这，是在我接下来介绍的四种关键方法。 我之前和大家分享过www.10beasts.com 你们去分析这个网站，觉得非常的不起眼，一个网站才3个产品，5个页面，一个月纯利就可以做到60k美金，你去分析他的外链，搜索数量也很少，如果你按照传统的分析方法，你压根就看不出来，会让你大跌眼镜。 而且这个网站（博客）自己是做affiliate，什么意思？ 就是自己不压货，没有资金压力，不用设置客服，一个月就可以做到60k美刀，而且多数流量就是靠SEO，更为关键的是，这些流量是免费的，简直是养了一台日夜赚钱的机器。 我很早之前就在公众号和各位做分析，我不知道各位有没有注意到，还只是看过了就没了。因为我们也是这样做的，懂流量，就去玩affiliate，这些压货啊，客服啊，资金压力和我们统统没关系….一个月也只比10beasts.com少了一点，非常轻松！ 那么我做一个网站／博客除了基本的网站优化，我最主要关心的事哪几个要素呢？最主要把时间花在哪里呢？ 第一：用户的需求 这个在我做网站的时候，我会花一些时间分析用户的需求，这一步非常重要。很多人问：“小北，你是怎么选品的？” 我在选品的时候，就会对用户的分析进行详细的调研，我独立站的选品，特别是如果你也想做一个类似10beasts.com这样的网站，这都是有一定的方法。 总体来说，我们独立站的选品思路是，用已经被卖家证明过的产品，多方位比较后，来成为我们独立站的产品。我之前有看过一个老外大卖家的视频，他的思路和我们事一样，我们可以把这类已经被卖家证明过的产品，称为“wow，products” 我们这个思路和很多人不一样，很多人说自己选一个产品，然后花了很多时间和精力，包括打了很多广告，才被证明这个产品是好还是坏，但是我们在独立站的选品方面，我们反其道而行之，这个就为我们节省了大量的时间和金钱。 所以我们在开始做产品，就已经把用户的需求，反馈植入到产品中。 另外关于用户的需求，为记得我在公众号上面也说过，很多人忽视了论坛（Forum，Board），群组（facebook group，reddit），问答类（Yahoo answer，Quaro，Wiki），这些渠道上存在着大量的用户对于问题的反馈，他是一个好的调研渠道。 再次强调，对于这些渠道的研究，对于用户关心的需求点把握，这点非常非常重要！！！ 我经常是对用户的需求，来写文章，做博客，以这样的形式来做博客，这个太好做排名了，而且非常有针对性！ 第二：关键字／长尾词的调研 找到用户的需求，选品完成之后，就是要对关键字和长尾词的调研。关键字和长尾词如果你选取错误，要么你今后网站很难得到一个好的排名，要么你压根就没有曝光的机会。关键字的选取这个我之前也写过几篇文章，大家有兴趣的可以再看看： SEO基础篇—关键词挖掘和分类（一）SEO基础篇—关键词挖掘和分类（二）几种提高关键词排名的方法手把手教你如何选择SEO关键字 (1)有效的关键字工具，博客排名方法，寻找客户技巧法集合（详细） 关于关键字研究的内容，在今后，我会再写一些此方面的文章，大家可以期待。 第三：做内容 在SEO上，有句话叫：“内容为王，外链为皇”，内容非常非常重要。 是啊，大家都知道内容重要，可是问题是为什么很多人写不出高质量的内容？我在国外我也是叫老外来写，但是我会把我的思路，写的样式，参考的渠道，文章的排版都讲解给老外，他用我的思路来写问题。 各位，一定要做内容，这个市面上，太多人抄袭，伪原创，很少人能专心去做内容的输出，而且还能能把内容写好的那更少。我觉得我国外博客能做的不错，很重要的点就是认真做内容！ 高质量的内容，不仅对于用户来说非常重要，对于搜索引擎来说都非常友好，搜索引擎会给予那些长期输出高质量的内容很高的权重，我一直觉得这个是我们的核心秘密。 还有一点很重要，我看过了太多的国外博客，很多写的非常的好，但他们真不是靠文章的数量来赢取排名，他们靠的是文章的质量来取胜。国内的也有类似的案例，各位看到李叫兽的微信公众号，55篇被百度1.2个亿全资收购，25岁就实现了财务的自由。 第四：坚持，坚持，再坚持 是的，持续并坚持高质量的内容。 这个过程其实真的没有任何的捷径，只有不断的，长时间的做内容输出，这个道理都明白，可是真没有几个人能坚持的了。 以我公众号为例，也是长时期的坚持，之前都是每天晚上11:30分开始写，一篇文章至少要写2个小时，很多的周末周六，也都是在写文章中度过的，其中花费的时间是巨大的。 还有一点，你们看到10beasts.com一个月42几万的纯收入，你会非常的羡慕，好像躺着就可以赚钱，但是我想说的是，我们做一个博客前期是6个月没有赚钱，都是在坚持输出高质量的内容，对于内容的产生非常大严格。 我们的一个理念就是用户在看到你这篇文章之后，会情不自禁的发出：“WOW” 国内的术语就是：“卧槽，我怎么现在才看到这篇文章” 我们严格并坚守这个理念。 SEO真没有你想象的那么难，你外面看到的那些条条框框，其实对于Google来说，都是很小的影响要素，或者你可以把他称为小技巧，我上面列出的这几点，才是真正值得你注意的核心和要素。 我一直觉得SEO无论对于一家公司来说，还是对于个人来说，必须是要掌握的，他真会给你带来巨大的利益，而且关键字是这部分流量是免费的。SEO没有你们想象的那么难，难的是你们能不能持续性的做高质量的内容输出，能不能坚持住，就是这么简单，其他的要素，我相信你们或多或少的都懂，这个不是你拉开别人的重要因素。我看了太多的公司，一个网站真多做多太滥了，很多人真多就是在浪费钱，自己还不知道问题出在哪里。有些人做广告，都没有安装追踪要素（Facebook pixel，Google analysis），我说你打广告，作用在哪里，烧了钱，居然没有做数据的追踪，更没有对于数据的分析，这太诧异吧。还有一些人，打广告，就随便做一个链接，要么首页，要么是分类页，我说你们是不是钱太多了？用户导入进来，你让他漫无目的的自由选择，自由浏览，都没有让他有进一步的行动…..还有一些公司，新品已上来，页面都没有做基本都优化，就去烧广告，或者有些用户想去购买你的产品，但是以搜索，发现啥都没有，网站没有基本的排名，没有做社交的展示，公司的about还是抄别人的，你看很多人都不注意这些，钱毫无疑问的就白白浪费。有时候看他们花的钱，我自己看了都觉得心疼～～从后天开始就要在武汉连续待一个月左右，我真觉得自己有一个功能，就是当你很想很想做一件事的时候，它就会实现！ 长按二维码，添加关注！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vagrant&virtualBox]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2Fvarant%26virtualBox.html</url>
      <content type="text"><![CDATA[缘由：一款可移动的工作环境，一款可备份的工作环境，今后换电脑，不用再折腾各种环境软件配置了 一、vagrant初级使用指南1-1、vagrant与virtualbox简介这里有一些概念，我们需要提前弄明白，不然困惑会一直存在。什么是virtualbox，它是一款开源的虚拟机，可在其上运行各种操作系统；什么是vagrant，它是一款应用软件，通过它用户可以操作各种操作系统。虚拟机的解释wikivirtualbox和vagrant介绍 1-2、安装准备 下载 VirtualBox 下载 Vagrant 下载需要安装的virtualbox，接下来以laravel/homestead为例在这一步中，由于防火长城的原因，导致使用vagrant box add xxx会非常的慢，所以我一般使用手动安装导入。具体的思路就是在自己的vps上下载下来box,wget url，然后使用bypy上传到百度云，然后下从百度云上拉下来。到此基本的需要软件就弄好了 1-3、使用示例 下载my.box 将my.box文件添加到vagrant中，【vagrant box add xx_name file:///User/het/xxxx/my.box】 创建一个文件夹vagrant_laravel，进入文件夹，执行【vagrant init】，生成了Vagrantfile 配置Vagrantfile文件，将config.vm.box改为xx_name，保存关闭 执行vagrant up，开启改虚拟机，然后执行vagrant ssh进入该虚拟机 上述步骤就是最基本的vagrant使用指南，当然，当我们修改了虚拟机，需要保存备份做快照，怎么办呢， 执行【vagrant package】,打包当前的虚拟环境，在当前目录生成.box文件 对该.box文件执行上述基本操作 how to sava and share box官方参考资料 常用指令 vagrant box add name file – 添加box到vagrant，file为本地路径file:///xxx vagrant box list – 列出所有vagrant添加的box vagrant global-status –prune – 列出所有vagrant运行的虚拟机，可以看到该虚拟机的id和name vagrant destroy [name/id] – 删除vagrant运行的虚拟机和global-status指令结合起来使用 vagrant box remove name – 删除名字叫name的box，和vagrant box add结合使用 二、vagrant进阶使用2-1、vagrant基本使用的弊端xxx的进阶使用，是不是很熟悉，一个东西之所以有进阶高阶使用，要不是因为它不够优雅简洁，要不是就有局限性，换句话就是做的不够做的不好，想明白vagrant基本使用中，哪里做的不够做的不好，就明白怎样进阶使用了。 使用虚拟机略显麻烦，我们需要使用vagrant ssh然后编辑代码，这样我们没法使用sublime或者ws之类的工具了，有没有一种办法可以编辑本地文件，然后自动同步到虚拟机呢？ 使用虚拟机，无法较为方面的模拟网站开发，域名打开麻烦 ok，我们列举了一些不足，那么怎样进阶使用呢，下面以laravel/homestead项目为例，剖析 2-2、homestead是如何做的我们进入laravel官网，它们提供了一个vagrant的配置文件，Vagrantfile文件是用ruby语法编写的 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- mode: ruby -*-# vi: set ft=ruby :require 'json'require 'yaml'VAGRANTFILE_API_VERSION ||= "2"confDir = $confDir ||= File.expand_path(File.dirname(__FILE__))homesteadYamlPath = confDir + "/Homestead.yaml"homesteadJsonPath = confDir + "/Homestead.json"afterScriptPath = confDir + "/after.sh"aliasesPath = confDir + "/aliases"require File.expand_path(File.dirname(__FILE__) + '/scripts/homestead.rb')Vagrant.require_version '&gt;= 1.9.0'Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| if File.exist? aliasesPath then config.vm.provision "file", source: aliasesPath, destination: "/tmp/bash_aliases" config.vm.provision "shell" do |s| s.inline = "awk '&#123; sub(\"\r$\", \"\"); print &#125;' /tmp/bash_aliases &gt; /home/vagrant/.bash_aliases" end end if File.exist? homesteadYamlPath then settings = YAML::load(File.read(homesteadYamlPath)) elsif File.exist? homesteadJsonPath then settings = JSON.parse(File.read(homesteadJsonPath)) else abort "Homestead settings file not found in #&#123;confDir&#125;" end Homestead.configure(config, settings) if File.exist? afterScriptPath then config.vm.provision "shell", path: afterScriptPath, privileged: false end if defined? VagrantPlugins::HostsUpdater config.hostsupdater.aliases = settings['sites'].map &#123; |site| site['map'] &#125; endend 在阅读上述代码之前，我们需要弄明白几个知识点yaml是一个文件格式，可被多种语法识别类似于json，require语法注意下。其实核心的内容很短，想要完全弄明白还是需要参考vagrant官方，这里大概说下1if File.exist? aliasesPath 这里是将本地的alias文件复制到虚拟机上 1if File.exist? homesteadYamlPath 这里是将配置vagrant配置项作用到虚拟机上，开始的时候我这里不明白，原来是看漏了一句代码1require File.expand_path(File.dirname(__FILE__) + &apos;/scripts/homestead.rb&apos;) 上述代码是导入一个ruby函数，然后将yaml文件的配置项导入到虚拟机 1if File.exist? afterScriptPath then 这里是开启虚拟机之前的一个运行脚本 12345678910111213141516171819202122232425262728293031323334---ip: "192.168.10.10"memory: 2048cpus: 1provider: virtualboxauthorize: ~/.ssh/id_rsa.pubkeys: - ~/.ssh/id_rsafolders: - map: ~/Code to: /home/vagrant/Codesites: - map: homestead.app to: /home/vagrant/Code/publicdatabases: - homestead# blackfire:# - id: foo# token: bar# client-id: foo# client-token: bar# ports:# - send: 50000# to: 5000# - send: 7777# to: 777# protocol: udp 这个算是homestead对于虚拟机的配置了 结论：laravel/homestead算是良心之作，核心功能我们都需要，也没加太多私货，以其当模板，我们能省不少功夫。 2-3、homestead部分详细说明2-3-1、ip设置在Homestead.yaml中将ip进行设置，如果是在本地进行调试，可以将ip设置为127.0.0.1 2-3-2、ssh密钥设置在Homestead文件中运行1ssh-keygen -t rsa -C &quot;you@homestead&quot; 然后直接几个回车就好 2-3-3、相关配置配置共享文件夹123folders: - map: ~/Code //这个路径是本地的目录路径，这里更新可以直接同步虚拟环境中 to: /home/vagrant/Code //这个路径是虚拟环境中的路径（vagrant ssh可进入环境） 配置nginx站点123sites: - map: homestead.app to: /home/vagrant/Code/Laravel/public]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用api汇总]]></title>
      <url>%2Finterface%2F%E5%B8%B8%E7%94%A8api%E6%B1%87%E6%80%BB.html</url>
      <content type="text"><![CDATA[缘由：汇总自己申请和分析的api接口，方便自己查询 一、翻译接口有道翻译1http://fanyi.youdao.com/openapi.do?keyfrom=&lt;keyfrom&gt;&amp;key=&lt;key&gt;&amp;type=data&amp;doctype=&lt;doctype&gt;&amp;version=1.1&amp;q=要翻译的文本 接口详细讲解 第三方翻译第三方翻译 参考github上汇总的常用API]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript粒子特效-烟花效果]]></title>
      <url>%2Fweb%2Fjavascript%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88-%E7%83%9F%E8%8A%B1%E6%95%88%E6%9E%9C.html</url>
      <content type="text"><![CDATA[缘由：第一次学习JavaScript的粒子特效，做个记录总结，本次更新烟花特效 一、烟花特效分析需求主要实现点击画布，然后粒子升空爆炸的效果，分2步，第一步绘制粒子，实现升空动画爆炸动画，第二步结合物理的速度和运动规律来写 粒子类12345678910111213141516171819202122232425262728293031323334var Particle = function(pos, target, vel, marker, usePhysics) &#123; // properties for animation // and colouring this.GRAVITY = 0.06; this.alpha = 1; this.easing = Math.random() * 0.02; this.fade = Math.random() * 0.1; this.gridX = marker % 120; this.gridY = Math.floor(marker / 120) * 12; this.color = marker; this.pos = &#123; x: pos.x || 0, y: pos.y || 0 &#125;; this.vel = &#123; x: vel.x || 0, y: vel.y || 0 &#125;; this.lastPos = &#123; x: this.pos.x, y: this.pos.y &#125;; this.target = &#123; y: target.y || 0 &#125;; this.usePhysics = usePhysics || false;&#125;; 值得注意的是pos和vel属性。 这些描述了我们的粒子的位置和速度。 其余几乎都是渲染的窗饰，所以我们稍后再来看看。 首先，我们必须设置一切，您将在初始化方法中看到： 12345678910111213141516171819202122232425262728function initialize() &#123; // start by measuring the viewport onWindowResize(); // create a canvas for the fireworks mainCanvas = document.createElement('canvas'); mainContext = mainCanvas.getContext('2d'); // and another one for, like, an off screen buffer // because that's rad n all fireworkCanvas = document.createElement('canvas'); fireworkContext = fireworkCanvas.getContext('2d'); // set up the colours for the fireworks createFireworkPalette(12); // set the dimensions on the canvas setMainCanvasDimensions(); // add the canvas in document.body.appendChild(mainCanvas); document.addEventListener('mouseup', createFirework, true); document.addEventListener('touchend', createFirework, true); // and now we set off update();&#125; 参考参考译文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vps中转设置]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2Fvps%E4%B8%AD%E8%BD%AC%E8%AE%BE%E7%BD%AE.html</url>
      <content type="text"><![CDATA[缘由：做一个阿里云中转ss流量，方案采用iptables 一、开启iptables中转功能打开/etc/sysctl.conf，添加下面代码1net.ipv4.ip_forward=1 下面的这个步骤被我第一次写文章时省略了，结果坑了自己好久1sysctl -p 二、设置iptables终端输入，其中39.108.82.4为本机的ip地址，阿里云需要填写的是内网地址，参考步骤41234567iptables -t nat -A PREROUTING -p tcp --dport 8381 -j DNAT --to-destination 138.128.198.147:8381iptables -t nat -A POSTROUTING -p tcp -d 138.128.198.147 --dport 8381 -j SNAT --to-source 39.108.82.4iptables -t nat -A PREROUTING -p udp --dport 8381 -j DNAT --to-destination 138.128.198.147:8381iptables -t nat -A POSTROUTING -p udp -d 138.128.198.147 --dport 8381 -j SNAT --to-source 39.108.82.4 下面的这个步骤也被我第一次写文章时省略了，结果坑了自己好久12service iptables save ## 将上一步的配置写入iptabels中service iptables restart 三、设置链接配置本机ss设置中，ip设置为阿里云主机，端口密码还是和之前一样配置 四、注意查看阿里云主机的网卡绑定ip地址1ifconfig 查看 inet 后面的地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vps日常使用]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2Fvps%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8.html</url>
      <content type="text"><![CDATA[缘由：在使用vps的过程中，也遇到了不少的坑，有些问题没有总结，导致一遍一遍的搜网页，在此一并记录 一、centos6下python2.6升级到python2.7我在centos6环境下使用的步骤 更新指令 12yum -y updateyum groupinstall -y &apos;development tools&apos; 另外还需要安装 python 工具需要的额外软件包 SSL, bz2, zlib 1yum install -y zlib-devel bzip2-devel openssl-devel xz-libs wget 源码安装Python 2.7.x 123wget http://www.python.org/ftp/python/2.7.8/Python-2.7.8.tar.xzxz -d Python-2.7.8.tar.xztar -xvf Python-2.7.8.tar 安装详情： 12345678910# 进入目录:cd Python-2.7.8# 运行配置 configure:./configure --prefix=/usr/local# 编译安装:makemake altinstall# 检查 Python 版本:[root@dbmasterxxx ~]# python2.7 -VPython 2.7.8 设置 PATH 12345678export PATH=&quot;/usr/local/bin:$PATH&quot;or ln -s /usr/local/bin/python2.7 /usr/bin/python# 检查[root@dbmasterxxx ~]# python -VPython 2.7.8[root@dbmasterxxx ~]# which python /usr/bin/python 接下来这3步我没有用，我直接使用的虚拟环境1virtualenv caogao -p python2.7 安装 setuptools 1234567#获取软件包wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools-1.4.2.tar.gz# 解压:tar -xvf setuptools-1.4.2.tar.gzcd setuptools-1.4.2# 使用 Python 2.7.8 安装 setuptoolspython2.7 setup.py install 安装 PIP 1curl https://bootstrap.pypa.io/get-pip.py | python2.7 - 修复 yum 工具此时yum应该是失效的，因为此时默认python版本已经是2.7了。而yum需要的是2.6 所以： 12345[root@dbmasterxxx ~]# which yum /usr/bin/yum#修改 yum中的python 将第一行 #!/usr/bin/python 改为 #!/usr/bin/python2.6此时yum就ok啦 参考：centos6.5下python2.6升级python2.7 二、centos6环境下开启定时任务，后台执行python自动化脚本运行方案引子：一直想用vps自动运行我的python脚本，但是有几个问题我一直都懒得去查和解决。。但是做coderhelper数据抓取的时候，我总不能每天都定点去抓数据吧，所以其实还是出于我很懒的原因，才有这个小文章的。 Q-0我写的脚本是运行在python3.5上的，所以系统自带的2.7的版本我是运行不了的，而且我习惯使用python的虚拟环境，不想污染自己的开发环境，那么我必须启动一个脚本然后打开运行环境，然后运行我的python脚本，在运行完成后，在退出 解决：我尝试使用python去写脚本，运行之后，发现没什么作用，搜索之后，发现网上关于这个的解决也比较少，大多是说source应该替换为‘.’，后来我又使用了shell脚本，但是效果是一样的，后来我意识到，其实是起作用了的，只是打开了activate环境，然后马上就关闭了而已，不会出现自己终端运行出现的(caogao)，这种现象。 Q-1怎样让脚本自动运行在vps上，关键词是crontab 第一步，使用crontab -e命令，可能出现的错是“Error detected while processing /root/.vimrc:”—-解决： 12345[root@~]# vim ~/.bashrc export EDITOR=/usr/bin/vim [root@~]# source ~/.bashrc 第二步，编辑要定时执行的脚本，eg： 123每天凌晨3:00执行备份程序：0 3 * * * /root/backup.sh每周日8点30分执行日志清理程序：30 8 * * 7 /root/clear.sh 第三步，让root用户生效 1crontab -u root /var/spool/cron/root 第四步，重启crontab服务 1service crond restart Q2能不能给个参考的定时python任务啊，当然：123456#!/bin/shcd /root/python_blogsource ./bin/activatecd /root/python_blog/python_goose/hang/sispython list.pydeactivate Q3我用的是服务器在美国洛杉矶，所以系统时间上是有时间差的比如：我在定时器中使用20 07 换算到中国大陆就是下午7点20，如果是15 22 换算到中国大陆就是上午十点15分 参考第三步和第四步 第一步和第二步 三、centos6.5环境下vsftpd安装与配置 以root身份在终端输入yum install vsftpd 添加jacob上传用户，以root身份在终端输入useradd jacob,并通过passwd jacob设置密码，用于上传; 修改vsftpd配置文件，通过命令cd /etc/vsftpd/ &amp;&amp; vim user_list打开文件，在该文件最下方添加jacob用户， 在该目录下通过命令vim vsftpd.conf, 将userlist_enable的值改为NO 通过命令重启vsftpd,并通过命令service iptables stop和setenforce 0关闭防火墙 参考：centos6.5下vsftpd安装 四、vps使用小技巧4-1、nohup + &amp; 指令做到后台运行程序这个需求来自于我下载vagrant box，我在vps上下载好了box，然后通过bypy上传到百度云，但是box很大，我需要后台运行上传的任务。具体的指令如下：1nohup bypy upload xxx.box &amp; 现在开始讲解一下这里的2个指令，第一个是&amp;，这个指令是让程序在后台运行，但是如果关闭了终端，则任务还是会结束。在指令最前面加上nohup，则当我关闭了vps的终端，程序还是可以在后台运行，具体进程查看可以使用top指令，查看后台任务也可以使用jobs。 这里扩展一下查看进程和任务的命令。jobs,top,ps[process status] info:*如何在后台运行 Linux 命令并且将进程脱离终端 ps查看器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网站添加谷歌翻译]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2F%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91.html</url>
      <content type="text"><![CDATA[缘由：想要自己的博客网站，支持多种语言，添加谷歌的翻译功能 谷歌翻译网站注册在需要翻译的页面添加以下代码1234567&lt;div id="google_translate_element"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;function googleTranslateElementInit() &#123; new google.translate.TranslateElement(&#123;pageLanguage: 'en', includedLanguages: 'zh-CN', layout: google.translate.TranslateElement.FloatPosition.TOP_LEFT&#125;, 'google_translate_element');&#125;&lt;/script&gt;&lt;script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"&gt;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python基础语法总结]]></title>
      <url>%2Fbackend%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[缘由：很多常用的语法，老是忘记，在此做个总结，相当于自己的三级缓存吧 一、文件操作相关1-1、os模块相关 获取当前的文件目录 12import osprint(os.getcwd()) 如果不存在此目录，创建一个该文件夹 12if not os.path.exists(directory): os.makedirs(directory) open()函数写入文件到指定目录 12在mac上，亲测可以如下：open('/Users/het/Desktop/jacob/xxx.html','a') demo:12345678910111213141516171819202122232425262728293031323334from pprint import pprintfrom goose import Goosefrom goose.text import StopWordsChineseimport reimport ossource_file = open('source.md','r')source_data = source_file.read()source_array = re.split('--', source_data)def getUrl(item): url_name = re.split('&amp;&amp;', item) url = url_name[1] name = url_name[0] print url print name html_name = name + '.html' print html_name g = Goose(&#123;'stopwords_class': StopWordsChinese&#125;) article = g.extract(url=url) # print article.raw_html currentDir = os.getcwd() + '/' + 'pages' + '/' + name if not os.path.exists(currentDir): os.makedirs(currentDir) f = open(currentDir + '/' +html_name,'a') f.write(article.raw_html) f.close() f_md = open(currentDir + '/' + name + '.md' ,'a') f_md.write(article.cleaned_text.encode('utf-8')) f_md.close()# pprint (vars(article))for item in source_array: getUrl(item)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谷歌插件推荐]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2F%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90.html</url>
      <content type="text"><![CDATA[缘由：我自己经常使用的谷歌插件，推荐推荐 Vimium介绍：Vimium 这个名字是 Vim 和 Chromium 的合体。Vim 是 Linux 等平台上的一款文本编辑器，它可以让你彻底脱离鼠标，通过一系列快捷键，来操作任何一件事情，也有很多人称之为编辑器之神。 Vimium 继承了 Vim 中的常用键位，让你在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。想像一下，你再也不需要移动鼠标去打开一个链接，手指不用离开键盘，一切都是这么流畅。 功效：熟练使用后，可极大提升浏览器查阅的效率 使用：页面移动 j：向下滚动一点 k：向上滚动一点 g：到页面最底部 G：到页面最底部 d：向下翻一屏 u：向上翻一屏 打开新页面，关闭页面cmd+t打开页面，cmd+w关闭页面 打开页面中的任意链接按f键，出现各个链接的字母标记，输入指定链接的字母标记，完成跳转 在不同便签页中切换shift+j切换到左侧标签， shift+k切换到右侧标签 查找页面中文本cmd+f输入查找内容 dreamAfar介绍：个人最喜欢一款谷歌插件，又名远方，每次打开一个新标签，该插件可从自定义的图库（网络）中随机抽取一张，呈现在你眼前，每张图片都很精美，让你从繁杂的工作中，看到世界的美好，让你对生活，多一份期待 功效：美化浏览器，提升生活–A new way to explore the world. 使用：谷歌应用商店下载，可自定义图片源，也支持下载图片 划词翻译介绍：浏览外文网页的时候，遇到不懂的单词，怎么办？查找谷歌翻译，使用字典软件。。。太慢，太烦，可使用划词翻译插件，支持选择不同服务器解析外文单词，可选谷歌，百度，金山等 功效：在也不怕查看外文页面了。。 使用：设置解析源后，鼠标滑动，选中不懂得单词，或者句子，自动翻译 TextMode介绍：在工作中，查看网页，出现太多图片，被同事看到，不太好，有没有什么办法，可以只有文字，没有图片呢，，试试Text Mode 功效：上班看页面，只有文字，没图片，页面素雅 使用：谷歌应用商店下载，点击Text Mode图标，切换开关模式 Adguard广告拦截器介绍：屏蔽广告 功效：净化页面，屏蔽广告 使用：谷歌应用商店下载，打开使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[compilerandruntimeanalysis]]></title>
      <url>%2FiOS%2Fcompilerandruntimeanalysis.html</url>
      <content type="text"><![CDATA[缘由：iOS的编译和运行时一直都有混淆，在此，做个记录和总结 编译器的主要职责1、静态分析（静态的检查语法错误），更类似于翻译器，代码还未写入内存，所以该阶段也没有内存的概念。只能检查出很低级的错误。 2、将c家族的代码转换为llvm-ir中间码 llvm编译器详解 llvm编译器和运行时分析 运行时系统分析 比较基础的运行时解释文章 存在的不解与疑惑（下文为我的初步理解与分析）运行时————查看维基百科等很多资料，回顾以往开发经历，可以确定，所谓运行时，动态语言，就是在app运行在手机上的这个时间过程。 在这个过程中，可以进行消息的转发，类型的确定(id)，那么疑问来了。。。 梳理xcode编译到运行到手机的过程，xcode编译器clang，编译完成之后，到底生成的是什么，是机器码？是中间码？还是什么，google了很久之后，没什么答案，但是分析之后，我感觉是什么可能不重要，但是绝对不会是机器码。。。查看苹果官方文档和clang关于oc-runtime的文档，发现其实mac和iOS手机上面可以运行苹果应用，是因为操作系统上面有运行时库（可以维基百科这个词），所以编译之后应该是中间码，而且这个中间码可以被操作系统上面的运行时库解析，然后消息转发的时候，完成代码的定位和解释（类似解释器），没有找到就报错了（运行时错误）。 而我们在xcode中可以看到的运行时库，是苹果提供给开发者的，和操作系统中的运行时库是不一样的，操作系统（iOS和mac）提供的运行时库（c和汇编写的），我们应该是看不到的。xcode中可见的运行时库主要目的苹果给的说明是，链接不同语言的brige，在编译器最初阶段，会将所有的import导入翻译，其实我们所做的所谓runtime黑魔法，就是做的这一步。————对某些消息转发进行替换，在操作系统上(iOS和mac)运行的时候，操作系统的运行时库再来定位代码和操作（这步是不透明的）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS闭包和回调函数]]></title>
      <url>%2FiOS%2FiOS%E9%97%AD%E5%8C%85%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html</url>
      <content type="text"><![CDATA[缘由：闭包和回调函数是很多编程语言中的难点和重点，iOS当然也不例外 闭包 block block也叫闭包，也称lamada，在iOS中，闭包主要有以下2点特性 匿名函数和截取自动变量，可以和c语言中的函数指针做类比。 回调函数 CallBackFunction CallBackFunction是回调函数，是函数式编程中很重要的一个特性，就是将函数作为参数传递给另外一个函数，或者将函数作为返回值。 总结在iOS中闭包和回调函数经常组合在一起使用，或者说iOS的回调函数是闭包的一种应用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS代码规范]]></title>
      <url>%2FiOS%2FiOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html</url>
      <content type="text"><![CDATA[缘由：记录iOS代码书写规范，不定期更新 一、viewController代码结构 属性：@property(nonatomic,strong)UIButton *confirmButton VC生命周期：#pragma mark - life cycle 系统控件代理：#pragma mark - UITableViewDelegate 自定义代理：#pragma mark - CustomDelegate 事件响应：#pragma mark - event response 私有方法(一般都是时间控件外观小处理，也可以放在分类中)：#pragma mark - private methods setter和getter方法：#pragma mark - setters and getters 注：控件添加到view上面都是在viewDidLoad中，使用[self.view addSubview:self.firstLabel];调用getter方法 很好的架构资料]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用clang分析oc源码]]></title>
      <url>%2FiOS%2F%E4%BD%BF%E7%94%A8clang%E5%88%86%E6%9E%90oc%E6%BA%90%E7%A0%81.html</url>
      <content type="text"><![CDATA[缘由：如果要深入理解oc，分析其运行时源码是非常有必要的，在此给出分析方式，和必要的基础知识 一、分析方法使用clang编译器，查看oc代码指令：clang -rewrite-objc xxx.m 二、基础知识2-1、理解结构体和结构体指针结构体：123struct 结构体名&#123; 结构体所包含的变量或数组&#125;; 既然结构体是一种数据类型，那么就可以用它来定义变量。例如：struct stu stu1, stu2; 你也可以在定义结构体的同时定义结构体变量：1234567struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125; stu1, stu2; 如果只需要 stu1、stu2 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名，如下所示：1234567struct&#123; //没有写 stu char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在学习小组 float score; //成绩&#125; stu1, stu2; 结构体指针：123456789struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125; stu1 = &#123; "Tom", 12, 18, 'A', 136.5 &#125;;//结构体指针struct stu *pstu = &amp;stu1; 也可以在定义结构体的同时定义结构体指针：1234567struct stu&#123; char *name; //姓名 int num; //学号 int age; //年龄 char group; //所在小组 float score; //成绩&#125; stu1 = &#123; "Tom", 12, 18, 'A', 136.5 &#125;, *pstu = &amp;stu1; 注意，结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加&amp;，所以给 pstu 赋值只能写作：struct stu *pstu = &stu1;参考 2-2、C++构造函数123456789101112131415class Counter&#123; public: // 类Counter的构造函数 // 特点：以类名作为函数名，无返回类型 Counter() &#123; m_value = 0; &#125; private: // 数据成员 int m_value;&#125; 参考 2-3、函数指针1234567891011121314#include &lt;stdio.h&gt;void say_hello(const char *str); void (*fptr)(const char *); int main(void) &#123; void (*fptr)(const char *) = say_hello; fptr("KingPlesk"); return 0; &#125; void say_hello(const char *str) &#123; printf("Hello %s\n", str); &#125; 参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xcode相关]]></title>
      <url>%2FiOS%2Fxcode%E7%9B%B8%E5%85%B3.html</url>
      <content type="text"><![CDATA[缘由：在此总结归纳xcode的使用技巧和xcode编译相关内容 一、xcode基本使用1-1、xcode中创建文件夹如果在xcode工程中new group，只是在视觉效果上分好了几个文件夹，方便分类管理，但在finder中并不会创建新的文件夹，在硬盘目录还是所有文件都并列在一个文件夹内，更恶心的是当你重新打开工程后，会发现刚才new的group已经不见了。那应该怎样建立文件夹呢？ 正确的方法是：在finder找到把工程，新建一个文件夹aa，然后在xcode里面－－右键－－add files to “xxx”－－找到把文件夹aa－－完成，以后若要创建文件，在aa文件夹－－new file即可把文件添加进来，以后在包那里新建文件自然在这个包内。 1-2、xcode快捷键1、打开了2个工程项目，怎么在2个工程项目中切换 Q：’command’ + ‘~’ 2、在.m和.h文件之间快速切换 Q：’command’ + ‘ctrl’ + ‘上/下’ 3、折叠代码操作 Q：‘command’ + ‘option’ + ‘左/右’ 1-3、iOS系统升级后，xcode适配iOS新系统发布后，xcode需要在添加支持文件，步骤如下： 1234567（1）Xcode右击－选项－在Finder显示（2）右击Xcode－显示包内容（3）Contents--&gt;Developer--&gt;Platforms--&gt;iPhoneOS.platform--&gt;DeviceSupport（4）网络下载的文件放入上述位置，完成 1-4、xcode真机调试错误一、账号已绑定最大ID数 解决办法：说明开发账号已绑定超过5台手机，目前解决办法就是重新注册一个账号。 使用注意：所有自己跑的app都可以使用同一个bundleID，前提是使用相同的开发者账号，运行的BuddleID不要随便的更改 1-5、xcode8上架xcode8上架与7有较多不一样的地方，目前整理不是很详细，参考。 二、xcode编译器2-1、背景2-1-1、GCC编译器GCC（GNU Compiler Collection，GNU编译器套装），是一套由 GNU 开发的编程语言编译器。它是一套以 GPL 及 LGPL 许可证所发行的自由软件，也是 GNU计划的关键部分，亦是自由的类Unix及苹果电脑 Mac OS X 操作系统的标准编译器。 GCC 原名为 GNU C 语言编译器，因为它原本只能处理 C语言。GCC 很快地扩展，变得可处理 C++。之后也变得可处理 Fortran、Pascal、Objective-C、Java, 以及 Ada与其他语言。 2-1-2、LLVM编译器Apple（包括中后期的NeXT）一直使用GCC作为官方的编译器。GCC作为开源世界的编译器标准一直做得不错，但Apple对编译工具会提出更高的要求。 一方面，是Apple对Objective-C语言（甚至后来对C语言）新增很多特性，但GCC开发者并不买Apple的帐——不给实现，因此索性后来两者分成两条分支分别开发，这也造成Apple的编译器版本远落后于GCC的官方版本。另一方面，GCC的代码耦合度太高，不好独立，而且越是后期的版本，代码质量越差，但Apple想做的很多功能（比如更好的IDE支持）需要模块化的方式来调用GCC，但GCC一直不给做。甚至最近，《GCC运行环境豁免条款 （英文版）》从根本上限制了LLVM-GCC的开发。 2-1-3、clang编译器Apple吸收Chris Lattner的目的要比改进GCC代码优化宏大得多——GCC系统庞大而笨重，而Apple大量使用的Objective-C在GCC中优先级很低。此外GCC作为一个纯粹的编译系统，与IDE配合得很差。加之许可证方面的要求，Apple无法使用LLVM 继续改进GCC的代码质量。于是，Apple决定从零开始写 C、C++、Objective-C语言的前端 Clang，完全替代掉GCC。 2-2、应用2-2-1、@synthesize,@property和@dynamic区别和联系@synthesize告诉编译器，自动生成@property的setter和getter方法，@dynamic告诉编译器，@property的setter和getter不用自动生成，会在子类实现，或者运行时的时候生成 2-2-2、三者和编译器的纠葛早先的xcode编译器使用的是GCC，所以用户需要手动的写@synthesize someThing = _something;后期使用clang编译器后，这个步骤在声明属性的时候，编译器自动就生成了，最早期的时候，属性的setter和getter都需要用户自己手动生成 2-2-3、常用的属性声明方法早期的属性和成员变量声明是，头文件中interface{NSString _name;},@property NSString name;，实现文件中implement,@synthesize name = _name;这样成员变量就和属性绑定在一起了，可以直接使用下划线的成员变量，如果将@synthesize name = _name;改为@synthesize name;这样相当于@synthesize name = name;成员变量就是name了，这样是很不好的写法，在clang编译器中，不用在写@synthesize的语法了，只有当需要更改成员变量名字的时候，才需要写@synthesize的语法 二者还有一个小区别，如果使用老版的写法，在interface{}大括号中写，成员变量，这样子类可以直接使用_xxx访问到父类的成员变量，如果使用现在的写法，直接声明属性的话，需要使用self.xxx才能访问到父类定义的成员变量]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[iOS类的本质]]></title>
      <url>%2FiOS%2FiOS%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8.html</url>
      <content type="text"><![CDATA[缘由：理解iOS中类和对象的关系，理顺oc这门语言的一些设计理念 一、类的本质 类的本质其实也是一个对象(类对象) 程序中第一次使用该类的时候被创建，在整个程序中只有一份。 此后每次使用都是这个类对象，它在程序运行时一直存在。 类对象是一种数据结构,存储类的基本信息:类大小,类名称,类的版本，继承层次，以及消息与函数的映射表等 类对象代表类,Class类型,对象方法属于类对象 如果消息的接收者是类名,则类名代表类对象 所有类的实例都由类对象生成,类对象会把实例的isa的值修改成自己的地址,每个实例的isa都指向该实例的类对象 二、OC实例对象 类对象 元对象之间关系 元类保存了类方法的列表。当一个类方法被调用时,元类会首先查找它本身是否有该类方法的实现,如果没有则该元类会向它的父类查找该方法,直到一直找到继承链的头。元类(metaclass)也是一个对象,那么元类的isa指针又指向哪里呢?为了设计上的完整,所有的元类的isa指针都会指向一个根元类(root metaclass)。根元类(root metaclass)本身的isa指针指向自己,这样就行成了一个闭环。上面说􏰀到,一个对象能够接收的消息列表是保存在它所对应的类中的。在实际编程中,我们几乎不会遇到向元类发消息的情况,那它的isa 指针在实际上很少用到。不过这么设计保证了面向对象的干净,即所有事物都是对象,都有isa指针。由于类方法的定义是保存在元类(metaclass)中,而方法调用的规则是,如果该类没有一个方法的实现,则向它的父类继续查找。所以为了保证父类的类方法可以在子类中可以被调用,所以子类的元类会继承父类的元类,换而言之,类对象和元类对象有着同样的继承关系。 三、详细讲解：（GSPerson类） 1.程序启动后，系统会将所有类加载进内存-即代码区。 2.当需要用到GSPerson类时，系统会先在堆中创建一个对象，俗称类对象。 2.1.内部创建一个isa指针指向源类对象 2.2系统会在类对象中包含该类的所有成员属性、对象方法 2.3源类对象： 2.3.1内部创建一个isa指针指向根源类对象－NSObject 2.3.2系统会在类对象中包含该类对象方法 2.3.3根源类对象－NSObject 2.3.3.1内部创建一个isa指针指向自己本身 3.[[GSPerson alloc] init]系统做了三件事： 3.1.alloc: 3.1.1.内部创建一个isa指针指向类对象 3.1.2.在堆中分配一块存储空间 3.1.3.初步初始化，将成员变量初始化为零 3.1.4.返回对象 3.2.init：对成员变量进行初始化 3.3.返回对象 四、核心图解元类，对象，实例，根元类举例： 实际应用情况举例： 参考简书上很好的讲解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python开发环境配置(window&mac)]]></title>
      <url>%2Fbackend%2Fpython%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      <content type="text"><![CDATA[缘由：现在用的mac电脑上系统自带的是2.7版本的python，想用python3.5，需要自行安装，电脑上可以同时有2.7和3.5的版本2个版本的兼容可以使用，虚拟环境的方式（virtualenv）【python三大神器virtualenv, fabric, pip】。 一、python在mac上的安装与配置1-1、安装操作1-1-1、使用homebrew安装python -&gt;brew install python3遇到的问题： 1、 【Error: The `brew link` step did not complete successfully The formula built, but is not symlinked into /usr/local Could not symlink . /usr/local/opt is not writable. You can try again using:【brew link gdbm】 参考信息： 【Following Alex&apos; answer I was able to resolve this issue; seems this to be an issue non specific to the packages being installed but of the permissions of homebrew folders. sudo chown -R `whoami`:admin /usr/local/bin】 FROM: http://stackoverflow.com/questions/26647412/homebrew-could-not-symlink-usr-local-bin-is-not-writable 我的尝试： sudo chown -R `whoami`:admin /usr/local/bin 2、 【python3 You must `brew link pkg-config gdbm` before python3 can be installed】 参考信息： http://www.dongcoder.com/detail-293244.html 我的尝试：输入：【brew link pkg-config gdbm】 出现：/usr/local/share/man/man3 is not writable. 输入：【sudo chown -R het /usr/local/share/man/man3/】 出现：/usr/local/opt is not writable. 输入：【sudo chown -R het /usr/local/opt/】 出现：Error: Could not symlink . 输入：brew link gdbm 出现：Linking /usr/local/Cellar/gdbm/1.12… 12 symlinks created 输入：brew install python3等待安装。。。心得：【查找Google，按照英文提示尝试】 3、 【Error: Your Xcode (8.0) is outdated.Please update to Xcode 8.2 (or delete it).Xcode can be updated from the App Store.】 参考信息： 【It was an overly strict move, and after some debate the decision has been vastly loosened in 12aad5c136. It will be made generally available with the 1.0.4 release, which will be cut fairly soon. For now there are at least three workarounds: Probably the easiest: set the TRAVIS environment variable: export TRAVIS=1 Manually check out the master branch; Manually check out the 1.0.2 tag. Sorry for the inconvenience.】 我的尝试： export TRAVIS=1 结果：出现问题4 4、 【Error: Permission denied - /usr/local/etc/openssl/misc/c_hash Warning: Bottle installation failed: building from source.】 参考信息： FROM:---http://www.jianshu.com/p/d96feb47b05b 我的尝试： 【chmod -R 755 /usr/local/etc/openssl/misc】 结果：还是有蛮多问题的，但是基本都是按照提示来处理就好，大多出现权限不够等等，如果755还是不可以，可以尝试777安装homebrew和python3基本耗时2个钟头，安装记录都在这里了，这个习惯需要坚持，这个习惯很好@——@ 1-2、虚拟开发环境，隔离版本1.安装Virtualenv，pip3 install virtualenv tip：在安装的时候，应该存在pip2和pip3，python2和python3，但是修改路径不是很好，所以我采用添加版本号的方式，不加的话，mac系统会逐层查找，所有会找到系统自带的python2 参考信息 1-3、虚拟开发环境使用创建虚拟环境：virtualenv caogao ##创建一个caogao的文件夹 也可以指定虚拟环境的版本 virtualenv caogao –python=python3.6 激活虚拟环境：source ./bin/activate 关闭虚拟环境：deactivate 二、python在window上的安装与配置2-1、安装配置 1、官网下载最新版的python，http://www.python.org/download/【python3.5自带pip】 2、修改python的环境配置，有2种方法，方法一：寻常的修改方法，我的计算机，属性…其实方法一还是挺简单的，直接在环境变量中的系统变量里面设置path为安装路径就可以了方法二，使用cmd操作，path=%path%;C:\Python ，其中 C:\Python 是Python的安装目录。注意：需要进入到C:\Python目录下操作，在cmd中进入的操作是【D:】 3、在cmd中使用python –version，查看是否有安装好 4、使用pip安装文件，pip install aiohttp，安装第三包【pip install aiohttp】包的时候容易报错【小坑】：在pip install的过程中，一直出现 Retrying (Retry(total=4, connect=None, read=None, redirect=None)) after connection broken by ‘ReadTimeoutError(“HTTPSConnectionPool(host=’pypi.python.org’, port=443): Read timed out. (read timeout=15)”,)’: /simple/netifaces/ the above should download, then fail as we don’t have python-dev .. but it can’t download it to start with times-out ReadTimeoutError: HTTPSConnectionPool(host=’pypi.python.org’, port=443): Read timed out. 其实就是外网被墙的原因【解法】：开始谷歌翻墙插件就好了。。。多用谷歌参考：https://github.com/pypa/pip/issues/1805【小坑】：在pip install 过程中，在python下的Scripts文件下运行，因为pip不是python的解释型下运行的 2-2、在git bash中使用python在git bash中使用python，需要在前面加上winpty python，才可以 在git bash中用pip安装插件，也需要在script下进行(最好的办法就是在环境变量中添加D:\python\Scripts;)，但是需要加上winpty，eg:winpty pip3 install virtualenv 但是这个都是很大，所以很慢，可以使用镜像来解决，winpty pip3 install -i url virtualenv 可使用:https://pypi.tuna.tsinghua.edu.cn/simple 参考1 在git bash中使用pip 的virtualenv，使用source venv/scripts/activate参考2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python]]></title>
      <url>%2Fbackend%2Fpython.html</url>
      <content type="text"><![CDATA[缘由：我所了解的python 一、python常用模块1-1、requests更多请参考 1-2、lxml英文资料 中文参考 1-3、mysqlclient【python于mysql的使用】 使用mysql-python包比较麻烦，其对python3的支持很不友好，在各种尝试和比较之后，选择使用mysqlclient包，这个包也是diagong所推荐的,其实mysqlclient包是mysql-python的一个分支 mysqlclient使用参考 1-4、系统自带模块1-4-1、datetime模块时间处理相关的模块，可参考 1-4-2、urlparse模块网址信息分析截取模块，可参考 1-4-3、re正则匹配模块正则匹配模块，和perl脚本的正则匹配很像可参考 正则匹配的demo What is the difference between .? and . regular expressions It is the difference between greedy and non-greedy quantifiers. Consider the input 101000000000100. Using 1.1, is greedy - it will match all the way to the end, and then backtrack until it can match 1, leaving you with 1010000000001..? is non-greedy. will match nothing, but then will try to match extra characters until it matches 1, eventually matching 101. All quantifiers have a non-greedy mode: .*?, .+?, .{2,6}?, and even .??. 二、项目2-1、美味不用等2-1-1、background周五下午要去吃海底捞，但是人太多要排队，生意太多火爆，所以借助美味不用等，这个应用来提前预约，然后用这个的人也多，而且不知道什么时候可以下预约的，所以需要自动通知提醒我 2-1-2、技术点一爬虫，这个我也写了一些了，基本没什么难度，但是要找到数据这才是爬虫难的，好嘛，这个美味不用等，没有网页端，在微信中内嵌的html5 用charles抓包，分析了这个请求，然后发现是post的，我不知道怎么去分析post的参数在手机端上，所以借助了一个网站 http请求在线分析网站 然后找出这个关键的参数是shopId，最后在去找所以的和美味不用等相关的接口，然后找到了这个字段的值 2-1-3、技术点二爬取到数据之后，定时运行这个脚本就可以了，但是怎么通知我呢，采用邮件和短信通知都是可以的 2-1-4、赶着吃饭，粗糙的源码1234567891011121314151617181920212223242526272829303132333435363738394041#-*- coding:utf-8 -*-import http.clientimport urllibimport requestsimport jsonimport timeurl = 'http://c-api.mwee.cn/wx_queue/shop/detail'payload = &#123;'shopId':'127113'&#125;host = "106.ihuyi.com"sms_send_uri = "/webservice/sms.php?method=Submit" #用户名是登录ihuyi.com账号名（例如：cf_demo123）account = "C1869xxxx"#密码 查看密码请登录用户中心-&gt;验证码、通知短信-&gt;帐户及签名设置-&gt;APIKEYpassword = "7e46204054e54435141546xxxxx" def send_sms(text, mobile): params = urllib.parse.urlencode(&#123;'account': account, 'password' : password, 'content': text, 'mobile':mobile,'format':'json' &#125;) headers = &#123;"Content-type": "application/x-www-form-urlencoded", "Accept": "text/plain"&#125; conn = http.client.HTTPConnection(host, port=80, timeout=30) conn.request("POST", sms_send_uri, params, headers) response = conn.getresponse() response_str = response.read().decode() conn.close() return response_str if __name__ == '__main__': mobile = "手机号码" text = "您的验证码是：000000。请不要把验证码泄露给其他人。" r = requests.post(url,data=payload) binary = r.content.decode() data = json.loads(binary) out = data['data']['queueInfo']['queueList'][1]['name'] print(out) if out == '中桌(晚市)': print(send_sms(text, mobile)) 参考资料模块参考资料系统自带库的官方文档 爬虫参考资料参考书籍《用python写网络爬虫》，可在脚本之家下载，使用微信关注，然后百度云下载 网络资源豆瓣电影top250爬虫 python学习资料 python中文开发社区 python学习教程 github-spider-dmoe python爬虫教程 python爬虫git版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[window系统使用]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2Fos%2Fwindow%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8.html</url>
      <content type="text"><![CDATA[缘由：虽然目前很少使用window系统，但是最近安装ssd，又重新安装了一次window系统，自己虽装过很多次，但是发现每次还是要网上找不少资料，这里一并总结，以慰来者。 一、ssd与操作系统安装1-1、ssd安装 拆开电脑底盖，更换硬盘 开机后提示，无法找到相应的启动盘 华硕电脑按f2进入bios中，找到advance（高级），在里面找到sata设置项，然后设置为AHCI模式，保存退出 插入U盘启动盘，进入U启动页面，选择列表的第二项，进入可视化安装系统中，warning：这里的进入列表第二项，不是直接安装了，而是进入可视化的操作系统中，进行安装，第二项一般是推荐的 进入可视化的安装系统中后，可以对硬盘进行分区，使用该系统中提供的DiskGenius进行分区操作，分区时，勾选对齐到下列扇区数的整数倍，完成以上操作后，可进行系统的安装。 1-2、window系统安装上述SSD安装过程，基本涵盖了接下来的window安装，只需注意以下几点即可： 自制的U盘启动盘，不要在做其他用途，不可再进行保存资料，删除资料等U盘操作 window镜像文件采用的是风火山林的版本，开机后，发现显示比较奇怪，可以设置win主题为azro主题 1-3、参考U启动使用指南 什么是分区什么是逻辑分区 DiskGenius使用指南 固态硬盘装系统 华硕进bios]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac系统使用]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2Fos%2Fmac%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8.html</url>
      <content type="text"><![CDATA[缘由：mac系统使用，该文档主要记录日常中使用的各种小技巧 一、mac终端使用1-1、自定义外观依据自己的审美，设置自己的外观 颜色：我选择黑底白字 字体sf mono regular 13 透明度：85% 背景图片：依据自己口味， 1-2、常用操作 进入全屏模式：cmd + ctrl + f 缩放到低栏：cmd + m 1-3、自定义快捷操作最能体现终端功效的，莫过于定义.bash_profile文件 查找自己电脑是否有此文件，终端输入cd，到根目录，然后输入ls -a，查看是否有.bash_profile文件，没有自己创建，设置自定义alias命令，保存后，输入source ~/.bash_profile，运行文件，然后才能生效。 我自己的配置文件在github上的软件配置文件夹中。 1-4、终端开始翻墙的功能对于程序员来说，终端是每天必备的利器。可是shadowsocks即使配置全局代理，终端还是不管用，接下来介绍一种简单实用的方法：如果是默认的 bash，则写入 ~/.bash_profile ，如果是 zsh，则写在 ~/.zshrc 12alias setproxy=&quot;export ALL_PROXY=socks5://127.0.0.1:1080&quot; alias unsetproxy=&quot;unset ALL_PROXY&quot; 上面的端口(1080)和具体的地址，自己可以使用浏览器访问谷歌，然后自己查看就可以了 二、文件操作相关2-1、强写ReadOnly文件有些文件系统设置为只读属性，这个时候chmod模式改写后，还是不行，这时，可以尝试使用vim打开，然后命令模式下输入： 1:w !sudo tee % &gt; /dev/null 参考 2-2、修改文件默认打开的方式右键点击需要修改的文件，点击显示简介，然后点击打开方式，最后设置完成。 三、软件操作相关3-1、设置xx软件直接在终端打开以sublime为例子 1alias subl=\&apos;&apos;/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl&apos;\&apos; alias为linux的个人偏好设置文件，silicongo中有用到过 四、mac软件使用推荐 macdown 编写markdown的一款软件 charles 抓包工具，设置相关配置后，可抓取https请求]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sublime3安装使用]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2Fsublime3%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8.html</url>
      <content type="text"><![CDATA[缘由：换一个电脑，换一个工作环境，都需要重新配置一次sublime，这里做下记录，以便以后方便移植配置 一、偏好设置1-1、setting user的配置1234567&#123; &quot;font_size&quot;: 16.0, &quot;ignored_packages&quot;: [ &quot;Vintage&quot; ]&#125; 1-2、key bindings user的配置1234567891011121314151617181920212223242526272829303132333435363738[ &#123; &quot;keys&quot;: [&quot;super+shift+a&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;command_palette&quot;&#125; &#125;, &#123; &quot;keys&quot;: [&quot;super+g&quot;], &quot;command&quot;: &quot;show_overlay&quot;, &quot;args&quot;: &#123;&quot;overlay&quot;: &quot;goto&quot;, &quot;text&quot;: &quot;:&quot;&#125; &#125;, &#123; &quot;keys&quot;: [ &quot;super+e&quot; ], &quot;args&quot;: &#123; &quot;action&quot;: &quot;expand_abbreviation&quot; &#125;, &quot;command&quot;: &quot;run_emmet_action&quot;, &quot;context&quot;: [&#123; &quot;key&quot;: &quot;emmet_action_enabled.expand_abbreviation&quot; &#125;] &#125;, &#123; &quot;keys&quot;: [&quot;tab&quot;], &quot;command&quot;: &quot;expand_abbreviation_by_tab&quot;, &quot;context&quot;: [&#123; &quot;operand&quot;: &quot;source.js&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;match_all&quot;: true, &quot;key&quot;: &quot;selector&quot; &#125;, &#123; &quot;key&quot;: &quot;preceding_text&quot;, &quot;operator&quot;: &quot;regex_contains&quot;, &quot;operand&quot;: &quot;(\\b(a\\b|div|span|p\\b|button)(\\.\\w*|&gt;\\w*)?([^&#125;]*?&#125;$)?)&quot;, &quot;match_all&quot;: true &#125;, &#123; &quot;key&quot;: &quot;selection_empty&quot;, &quot;operator&quot;: &quot;equal&quot;, &quot;operand&quot;: true, &quot;match_all&quot;: true &#125;] &#125;] 1-3、建立软链1ln -s &quot;/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl&quot; /usr/local/bin/sublime 如果之前有过软链，终端会提示exit，直接删除即可，rm XXX 二、插件相关 package control sublime安装插件的包管理工具安装：参考、我的简书 emmet 前端编写神器 sublimeCodeIntel 代码自动补全插件，配置 sublimelinter 代码检错插件，配置1、配置2 babel 支持es6与jsx语法高亮]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[网络基础]]></title>
      <url>%2Fnetworking%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.html</url>
      <content type="text"><![CDATA[缘由：网络通信中很多概念，比较容易弄混，一直没有系统整理过，在此，归纳网络通信中基本的概念和术语 一、通信协议介绍1-1、七层通信协议 应用层 –文件传输，电子邮件，文件下载上传等服务，HTTP,FTP,SMTP，DNS等 表示层 –数据格式化，代码转换，数据加密，没有协议 会话层 –解除或建立与别的接点的联系，没有协议 传输层 –提供端对端的接口，TCP，UDP 网络层 –为数据包选择路由 IP协议等 数据链路层 物理层 1-2、五层通信协议七层协议比较复杂，所以后续推出五层协议 应用层 传输层 网络层 数据链路层 物理层 二、http2-1、http简介http协议属于应用层的协议，用于web端和服务器端的数据交互和通信。HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充。 Keep-Alive是通知服务器，在这个HTTP Request/Responset结束后，不要立即断开TCP连接（注意是TCP连接，和HTTP没有关系），后面的HTTP Request仍然可以通过这个TCP连接继续传送。 但是！这只是个建议，服务器可能不支持，也可能忽略掉这个建议。也可能因为时间太久而直接断开TCP连接，下图展示了http几种不同链接： 三、socketsocket中文也译作套字节，是TCP/UDP通信协议的一层封装，这样让开发者，可以更快捷的使用tcp协议。 Socket 是电脑网络中进程间数据流的端点，也是传输层网络通信的 API。HTTP 作为一个应用层的协议，一般是基于传输层的 TCP 协议的。因此我们要在 TCP 协议上构建我们的程序，也就是使用 Socket 传输 HTTP 的消息。 下图展示了Socket TCP 通信的步骤： 四、websocketWebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算） 4-1、Websocket是什么样的协议，具体有什么优点首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。 简单的举个例子吧，用目前应用比较广泛的生命周期来解释。 HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。 在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。（但是服务器端，支不支持，这个看服务器端，节省建立tcp连接的成本） 但是请记住 Request = Response，在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。 其次，Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手 4-2、Websocket的作用，与HTTP的长轮询和ajax的比较在讲Websocket之前，我就顺带着讲下 long poll 和 ajax轮询 的原理。 ajax轮询 ，ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 场景再现： 客户端：啦啦啦，有没有新信息(Request) 服务端：没有（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：没有。。（Response） 客户端：啦啦啦，有没有新信息(Request) 服务端：你好烦啊，没有啊。。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：好啦好啦，有啦给你。（Response） 客户端：啦啦啦，有没有新消息（Request） 服务端：。。。。。没。。。。没。。。没有（Response） —- loop long poll long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。 场景再现 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） 服务端：额。。 等待到有消息的时候。。来 给你（Response） 客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop 从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。 说完这个，我们再来说一说上面的缺陷从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）所以ajax轮询 和long poll 都有可能发生这种情况。 客户端：啦啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 客户端：。。。。好吧，啦啦啦，有新信息么？ 服务端：月线正忙，请稍后再试（503 Server Unavailable） 所以在这种情况下出现了，Websocket出现了。 他解决了HTTP的这几个难题。 首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。 所以上面的情景可以做如下修改。 客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request） 服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched） 客户端：麻烦你有信息的时候推送给我噢。。 服务端：ok，有的时候会告诉你的。 服务端：balabalabalabala 服务端：balabalabalabala 服务端：哈哈哈哈哈啊哈哈哈哈 服务端：笑死我了哈哈哈哈哈哈哈 就变成了这样，只需要经过一次HTTP请求，就可以做到源源不断的信息传送了。 五、tcp/iptcp建连需要通过3次握手协议，具体图解： 在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。 第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据. eg: IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: S 3626544836:3626544836 IP 192.168.1.123.7788 &gt; 192.168.1.116.3337: S 1739326486:1739326486 ack 3626544837 IP 192.168.1.116.3337 &gt; 192.168.1.123.7788: ack 1739326487,ack 1 第一次握手：192.168.1.116发送位码syn＝1,随机产生seq number=3626544836的数据包到192.168.1.123,192.168.1.123由SYN=1知道192.168.1.116要求建立联机; 第二次握手：192.168.1.123收到请求后要确认联机信息，向192.168.1.116发送ack number=3626544837,syn=1,ack=1,随机产生seq=1739326486的包; 第三次握手：192.168.1.116收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，192.168.1.116会再发送ack number=1739326487,ack=1，192.168.1.123收到后确认seq=seq+1,ack=1则连接建立成功。 六、反向代理，隧道，网关，DNS6-1、正向代理和反向代理 正向代理 A同学在大众创业、万众创新的大时代背景下开启他的创业之路，目前他遇到的最大的一个问题就是启动资金，于是他决定去找马云爸爸借钱，可想而知，最后碰一鼻子灰回来了，情急之下，他想到一个办法，找关系开后门，经过一番消息打探，原来A同学的大学老师王老师是马云的同学，于是A同学找到王老师，托王老师帮忙去马云那借500万过来，当然最后事成了。不过马云并不知道这钱是A同学借的，马云是借给王老师的，最后由王老师转交给A同学。这里的王老师在这个过程中扮演了一个非常关键的角色，就是代理，，也可以说是正向代理，王老师代替A同学办这件事，这个过程中，真正借钱的人是谁，马云是不知道的，这点非常关键。 我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。 反向代理 大家都有过这样的经历，拨打10086客服电话，可能一个地区的10086客服有几个或者几十个，你永远都不需要关心在电话那头的是哪一个，叫什么，男的，还是女的，漂亮的还是帅气的，你都不关心，你关心的是你的问题能不能得到专业的解答，你只需要拨通了10086的总机号码，电话那头总会有人会回答你，只是有时慢有时快而已。那么这里的10086总机号码就是我们说的反向代理，客户不知道真正提供服务的人是谁。Nginx就是性能非常好的反向代理服务器，用来做负载均衡。 七、应用：搭建翻墙服务器（vpn,vps,虚拟主机）嗯，确实这几个概念挺饶人的。VPS，虚拟主机，云主机，独立服务器…… 独立服务器，顾名思义，就是一个躺在机房的实实在在的物理服务器，也可理解为你的游戏主机一样。优点：性能高缺点：价格高，高可用性低（比如断电，硬盘坏了……） VPSVirtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器。优点：价格便宜缺点：性能低，高可用性低（除了其所在的物理机出问题了会收到影响，虚拟化技术出问题也会收到影响） 云服务器Elastic Compute Service, 简称ECS 好多人理解云服务器和VPS一样，更有甚者说以前的VPS现在的说法就是云服务器，其实不然，云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合。优点：价格适中，使用灵活，高可用性（单个或多个物理离线不会对整个服务造成太大的影响）缺点：性能相对较低 虚拟主机Virtual hosts （Vhost）虚拟主机是通过，物理服务器，VPS或者云服务器安装例如CPanel，Plesk等面板搭建的。虚拟主机市场比较混乱，不同的厂商价格一般会有很大的差异，一般来说看一个虚拟主机的好坏可以从以下几点来看，主机系统：CloudLinux 更适合多租户虚拟主机，CPanel，Plesk 面板在市场上最受市场欢迎，一般来说价格相对较贵，使用云服务器最好（比如阿里云），物理服务器也可，一般不选择VPS作为虚拟主机的服务器。优点：价格低，使用方便缺点：一般来说只能做网站，或应用后端服务器，市场杂乱比较难选购总结：如过只是做一个小网站，个人博客等用虚拟主机就可，大点的应用建议用云服务器 VPN 虚拟专用网（英语：Virtual Private Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling Protocol）来达到保密、发送端认证、消息准确性等私人消息安全效果。这种技术可以用不安全的网络（例如：互联网）来发送可靠、安全的消息。需要注意的是，加密消息与否是可以控制的。没有加密的虚拟专用网消息依然有被窃取的危险。 以日常生活的例子来比喻，虚拟专用网就像：甲公司某部门的A想寄信去乙公司某部门的B。A已知B的地址及部门，但公司与公司之间的信不能注明部门名称。于是，A请自己的秘书把指定B所属部门的信（A可以选择是否以密码与B通信）放在寄去乙公司地址的大信封中。当乙公司的秘书收到从甲公司寄到乙公司的信件后，该秘书便会把放在该大信封内的指定部门信件以公司内部邮件方式寄给B。同样地，B会以同样的方式回信给A。 在以上例子中，A及B是身处不同公司（内部网路）的计算机（或相关机器），通过一般邮寄方式（公用网络）寄信给对方，再由对方的秘书（例如：支持虚拟专用网的路由器或防火墙）以公司内部信件（内部网络）的方式寄至对方本人。请注意，在虚拟专用网中，因应网络架构，秘书及收信人可以是同一人。许多现在的操作系统，例如Windows及Linux等因其所用传输协议，已有能力不用通过其它网络设备便能达到虚拟专用网连接。 搭建ss翻墙软件vps参考 八、应用：搭建web端多人在线聊天室参考《图解http》 《tcp/ip协议详解-卷一》 个人知乎网络相关收藏 websocket解释 知乎用户：Ovear http-socket解释 知乎用户：冯昱尧 tcp解释]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图解http学习笔记]]></title>
      <url>%2Fnetworking%2F%E5%9B%BE%E8%A7%A3http%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      <content type="text"><![CDATA[缘由：一开始的时候一直都未对http做过太多研究，只是将就够用，但是在写爬虫，被人反爬虫之后，发现不能熟悉掌握http协议，将在互联网世界举步维艰。 一、了解web及网络基础1-1、URI(统一资源标识符)URL(统一资源定位符)，我们比较熟悉，URI是3个单词的缩写，Uniform Resource Identifier URI用字符串表示某一互联网资源，而URL表示资源的地点，可见URL是URI的子集；采用HTTP协议时，协议方案就是http，除此之外，还有ftp、file等，标准的URI协议有30种方案左右。 登录信息：指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证），可选项。 查询字符串：针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数，可选项。 片段标识符：使用片段标识符通常可标识出已获取资源中的子资源，可选项。 1-2、HTTP协议基本规定一、HTTP发送规则：HTTP协议规定，请求从客户端发出，最后服务器端响应该请求并返回，换句话说，服务器端在没有收到请求的时候，不会发送响应，所以肯定是从客户端开始建立通信的。 二、HTTP无状态：HTTP是一种不保存状态，即无状态协议，不会对之前发送过的请求进行信息的保存。这样做的好处是可以快速处理大量事务。但是随着网络的不断发展，这种无状态的模式，出现了瓶颈，比如购物网站需要保持用户的登录状态，这样服务器才能知道是谁发送的请求。虽然HTTP1.1是无状态的协议，但是使用了cookie技术，可以保存用户的登录状态 1-3、使用方法下达命令 1-4、HTTP持久化链接在HTTP协议的初期版本中，每进行一次HTTP通信都要断开一次tcp链接，在早些时候，传输的都是文本类信息，但是目前请求都是含有大量图片的信息，这样tcp的不断断开重连会造成很大的开销。 为了解决上述tcp链接的问题，HTTP1.1和部分HTTP1.0相出了持久连接（HTTP keep-alive）的方法，持久化链接的特点是：只要任意一端没有明确提出断开链接，则保持TCP链接状态。http1.1默认都支持keep-alive 1-5、cookie的状态管理cookie会根据服务端发送的一个叫做Set-Cookie的首部字段信息，通知客服端保存Cookie，当下次客服端在往服务端发送请求的时候，客服端会自动在请求报文中加入Cookie然后发送过去，服务端接收到Cookie之后，对Cookie进行解析，然后找出是哪个用户。 eg: 一、请求报文（没有Cookie信息的状态） 123GET /reader/HTTP/1.1Host:hackr.jp*首部字段没有cookie的相关信息 二、响应报文（服务器端生成Cookie信息） 12345HTTP/1.1 200 OKDate:Thu ,12 JUl 2012 07:12:20 GMTServer: Apache&lt;Set-Cookie:sid=1342077140;path=/;expires=wed&gt;Content-Type:text/plain;charset=UTF-8 三、请求报文（自动发送保存的Cookie信息） 123GET /image/ HTTP/1.1Host hackr.jpCookie:sid=1342077140 二、HTTP报文内的信息2-1、HTTP报文用于HTTP协议交互的信息 请求行：包含用于请求的方法，请求的URI和HTTP版本 状态行：包含表明响应结果的状态码，原因短语和HTTP版本 首部字段：包含表示请求和响应的各种条件和属性的各类首部，一般有4中首部，通用首部，请求首部，响应首部，实体首部。 2-2、编码提升传输效率常用的内容编码有这几种: gzip (GNU zip) compress (UNIX 系统的标准压缩) deflate (zlib) identity (不进行编码) 2-3、分割发送的分块传输编码在传输大容量数据的时候，经常采用分块传输的方式 2-4、发送多种数据的多部分对象集合例如在写邮件的时候，可以在邮件中插入音频和视频，还有文字多种不同类型的数据，这个时候就需要用到多种数据的多部分对象集合发送 2-5、获取指定范围的请求数据例如在下载电影的时候，突然断网了，之前是需要重新下载的，但是可以使用Range: bytes=5001-，从5001字节之后开始下载 2-6、内容协商，返回最合适的内容同一个网站，有多份内容相同的页面，比如中文和英文，虽然内容是一样的，但是使用的语言不同，这个时候需用内容协商。Accept，Accept-Charset等等 三、HTTP首部字段 四、HTTPS协议4-1、HTTPS协议介绍http协议未对信息进行加密，所以需要采用加密的形式进行传输，常用的加密方法有：ssl,tls，（secure socket layer）(transport layer security)，在http协议上使用ssl就是https协议。 4-2、不验证通信方的身份可能遇到身份伪装http通信不会进行身份的确认，所以可能出现双方身份的伪装，比如客户端使用URI访问服务器的时候，响应的数据一定是指定的服务器发出的数据嘛？服务器发送给客服端，一定是指定的客户端嘛？ 比如常见的DoS攻击，就算是无意义的请求，也会响应。 ssl不仅可以加密信息，还有身份验证的作用（证书验证） 4-3、信息完整性收到的信息，可能被人为篡改，http无法证明通信的完整性。像这种，在响应传输的过程中发起的攻击，称为中间人攻击（man in the middle attack,MITM） 常用的http协议为了保证信息完整性，一般采用MD5或者证书签名，但是当签名证书和md5信息被人篡改，则无法保证信息完整性。 4-4、HTTP+加密+认证+信息完整性=HTTPS 五、确认访客的身份确认http使用的身份认证： BASIC认证（基本认证）–服务端放回401说明需要认证，然后输入用户名和密码，使用base64加密，发送给服务端，然后进行身份认证。 DIGEST认证（摘要认证）–服务端发送随机数，客户端发送摘要和计算结果。 SSL客服端认证 FormBase认证（基于表单认证） 由于使用上的便利性和安全性的问题，http协议标准提供的basic认证和digest认证几乎不怎么使用，另外ssl使用成本高，一般使用基于表单认证。 5-1、基于表单认证基于表单的认证标准规范尚未有定论，一般会使用cookie管理session（会话） 六、网站安全5-1、跨站脚本攻击5-2、SQL脚本注入攻击]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我所了解的git]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2F%E6%88%91%E6%89%80%E4%BA%86%E8%A7%A3%E7%9A%84git.html</url>
      <content type="text"><![CDATA[缘由：git相关资料，我自己写的比较杂乱，在此合并一处，以后git看这里就够了 一、git基本使用1-1、常用操作 查看分支：git branch 创建分支：git branch 远端拉取分支到本地：git checkout -b master origin/master 切换分支：git checkout 创建本地分支：git checkout -b [branch-name] 将创建的本地分支上传到远端服务器：git push origin [branch-name] 删除本地分支：git branch -D [branch-name] 删除远端分支：git push origin :[branch-name] –注意origin后面接一个空格 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 关联邮箱：git config –global user.email “你的邮件地址” 关联用户名：git config –global user.name “你的Github用户名” 1-2、版本回退与放弃修改 放弃本地所有修改：git checkout . 回退到指定版本：git reset –hard commit_id 1-3、推送远端操作 拉取更新操作：git pull 本地代码更新或有新文件加入：git add . 查看git的状态：git status 提交修改的文件到远端：git commit -m “xxx(备注)” 推送到远端服务器：git push 二、提升git clone的办法2-1、使用浅复制1git clone --depth=1 [url] 这样的操作，不会记录历史的版本，只会下载最新的版本，所有下载下来的内容会小的多 2-2、使用终端代理的方法git-clone太慢怎么办 三、遇到的问题3-1、vps的ssh中使用git遇到的坑3-1-1、一些没注意到的知识git的clone其实是分2种的，网上很多的说法也不靠谱，最靠谱的还是需要自己去理解其原理，追本溯源，方得始终。 git的clone操作有ssh模式和https模式，在vps操作下其实使用的是ssh，故clone的时候需要选中ssh模式的外链 github的ssh模式和https模式 3-1-2、在vps中使用git提交不上去一、修改.git中的config文件，将https改为ssh 二、查看.ssh文件夹下面有没有id_rsh.pub文件，就是ssh加密的公钥文件，git使用ssh加密上传的，这里我目前也不太懂，有空自己搭建一个git就知道了 .ssh配置相关 在有官方的参考文件后，我还是一直遇到坑，就是一直报我提交的公钥有问题，自己没有办法解决，还是网上找的，有时候遇到问题自己还是先搜搜吧，就是应为vim复制的问题 使用cat命令打印到终端，然后在复制就好了，orz 【cat ~/.ssh/id_rsa.pub】]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js疑难点总结]]></title>
      <url>%2Fweb%2Fjs%E7%96%91%E9%9A%BE%E7%82%B9%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[缘由：javascript的疑难点大概有闭包、作用域、this指向、回调函数和原型链等等，在此做个总结 一、js作用域1-1、概览 块级作用域 （es6才支持的）=&gt;{}，在大括号内的就是块级作用域 函数作用域 =&gt;就是在函数的实现中的，变量 全局作用域 =&gt;在外部声明的变量，如果声明变量的时候，不添加var关键字，则都是全局作用域 本地作用域（函数作用域）的优先级高于全局作用域 1-2、常见认知误区1-2-1、在es6之前，块级作用域的一个常见认知错误1234567891011for (var i = 1; i &lt;= 10; i++) &#123; console.log (i); // outputs 1, 2, 3, 4, 5, 6, 7, 8, 9, 10;​&#125;;​​// The variable i is a global variable and it is accessible in the following function with the last value it was assigned above ​​function aNumber () &#123;console.log(i);&#125;​​// The variable i in the aNumber function below is the global variable i that was changed in the for loop above. Its last value was 11, set just before the for loop exited:​aNumber (); // 11​ ​解释：在es6之前没有块级作用域这个概念，所以在块级作用域中声明的变量和赋值的变量，其实就是全局变量。 1-2-2、setTimeout中的函数在全局scope中执行123456789101112131415161718// The use of the "this" object inside the setTimeout function refers to the Window object, not to myObj​​​var highValue = 200;​var constantVal = 2;​var myObj = &#123; highValue: 20, constantVal: 5, calculateIt: function () &#123; setTimeout (function () &#123; console.log(this.constantVal * this.highValue);&#125;, 2000); &#125;&#125;​​// The "this" object in the setTimeout function used the global highValue and constantVal variables, because the reference to "this" in the setTimeout function refers to the global window object, not to the myObj object as we might expect.​​myObj.calculateIt(); // 400​​// This is an important point to remember. 1-3、注意事项1-3-1、不要过多的声明全局变量wrong way 123456// These two variables are in the global scope and they shouldn't be here​​var firstName, lastName;​​function fullName () &#123; console.log ("Full Name: " + firstName + " " + lastName );&#125; right way 1234567// Declare the variables inside the function where they are local variables​​​function fullName () &#123; var firstName = "Michael", lastName = "Jackson";​ console.log ("Full Name: " + firstName + " " + lastName );&#125; 1-3-2、使用变量的时候，需要提前声明，虽然有声明提前的功能，但是建议不要这么做1234567891011121314151617181920212223function showName () &#123;console.log ("First Name: " + name);​var name = "Ford";console.log ("Last Name: " + name);&#125;​showName (); ​// First Name: undefined​​// Last Name: Ford​​​// The reason undefined prints first is because the local variable name was hoisted to the top of the function​​// Which means it is this local variable that get calls the first time.​​// This is how the code is actually processed by the JavaScript engine:​​​function showName () &#123; var name; // name is hoisted (note that is undefined at this point, since the assignment happens below)​console.log ("First Name: " + name); // First Name: undefined​​name = "Ford"; // name is assigned a value​​​// now name is Ford​console.log ("Last Name: " + name); // Last Name: Ford​&#125; 外文原稿 二、闭包2-1、闭包的基本概念闭包就是内部函数获取外部函数的变量（来自scope chain），闭包有3中scope chain，一种是自身的作用域，还有一种是外部函数的作用域，最后是全局的作用域。 闭包（inner function）不仅可以获取外部函数（outer function）的变量还可以获取外部函数的参数。 最简单的闭包如下： 123456789function showName (firstName, lastName) &#123;​var nameIntro = "Your name is "; // this inner function has access to the outer function's variables, including the parameter​​function makeFullName () &#123;​ return nameIntro + firstName + " " + lastName;&#125;​return makeFullName ();&#125;showName ("Michael", "Jackson"); // Your name is Michael Jackson 2-2、闭包的规则和副作用2-2-1、闭包可以获取外部函数的变量，即使外部函数调用完成（就是执行完成）后。1234567891011121314function celebrityName (firstName) &#123; var nameIntro = "This celebrity is "; // this inner function has access to the outer function's variables, including the parameter​ function lastName (theLastName) &#123; return nameIntro + firstName + " " + theLastName; &#125; return lastName;&#125;​​var mjName = celebrityName ("Michael"); // At this juncture, the celebrityName outer function has returned.​​​// The closure (lastName) is called here after the outer function has returned above​​// Yet, the closure still has access to the outer function's variables and parameter​mjName ("Jackson"); // This celebrity is Michael Jackson 2-2-2、闭包获取的外部函数的变量值，会实时改变Closures store references to the outer function’s variables; they do not store the actual value.Closures get more interesting when the value of the outer function’s variable changes before the closure is called. And this powerful feature can be harnessed in creative ways, such as this private variables example first demonstrated by Douglas Crockford: 12345678910111213141516171819202122function celebrityID () &#123; var celebrityID = 999; // We are returning an object with some inner functions​ // All the inner functions have access to the outer function's variables​ return &#123; getID: function () &#123; // This inner function will return the UPDATED celebrityID variable​ // It will return the current value of celebrityID, even after the changeTheID function changes it​ return celebrityID; &#125;, setID: function (theNewID) &#123; // This inner function will change the outer function's variable anytime​ celebrityID = theNewID; &#125; &#125;​&#125;​​var mjID = celebrityID (); // At this juncture, the celebrityID outer function has returned.​mjID.getID(); // 999​mjID.setID(567); // Changes the outer function's variable​mjID.getID(); // 567: It returns the updated celebrityId variable 2-2-3、最常见的循环导致闭包出的bug需要结合2来看，因为闭包获取的外部函数的变量会实时改变 这个例子需要仔细看，其实就是结合了例子1和例子2，最后形成的一个套路1234567891011121314​function celebrityIDCreator (theCelebrities) &#123; var i; var uniqueID = 100; for (i = 0; i &lt; theCelebrities.length; i++) &#123; theCelebrities[i]["id"] = function () &#123; return uniqueID + i; &#125; &#125; return theCelebrities;&#125;var actionCelebs = [&#123;name:"Stallone", id:0&#125;, &#123;name:"Cruise", id:0&#125;, &#123;name:"Willis", id:0&#125;];​var createIdForActionCelebs = celebrityIDCreator (actionCelebs);​var stalloneID = createIdForActionCelebs[0];​console.log(stalloneID.id()); // 103 解决办法：核心就是使用立即执行函数，这样返回的就不是一个函数了，而是执行完成的结果12345678910111213141516171819202122function celebrityIDCreator (theCelebrities) &#123; var i; var uniqueID = 100; for (i = 0; i &lt; theCelebrities.length; i++) &#123; theCelebrities[i]["id"] = function (j) &#123; // the j parametric variable is the i passed in on invocation of this IIFE​ return function () &#123; return uniqueID + j; // each iteration of the for loop passes the current value of i into this IIFE and it saves the correct value to the array​ &#125; () // BY adding () at the end of this function, we are executing it immediately and returning just the value of uniqueID + j, instead of returning a function.​ &#125; (i); // immediately invoke the function passing the i variable as a parameter​ &#125;​ return theCelebrities;&#125;​​var actionCelebs = [&#123;name:"Stallone", id:0&#125;, &#123;name:"Cruise", id:0&#125;, &#123;name:"Willis", id:0&#125;];​​var createIdForActionCelebs = celebrityIDCreator (actionCelebs);​​var stalloneID = createIdForActionCelebs [0];console.log(stalloneID.id); // 100​​var cruiseID = createIdForActionCelebs [1];​console.log(cruiseID.id); // 101 三、回调函数3-1、基本概念在javascript语法中，函数即使对象，就像String,Array,Number等其他对象一样。所以: function可以被赋值给变量，可以作为函数的参数进行传递，可以在函数内创建新的function，可以被函数作为返回值，这些情况其实就是回调函数。 因为函数是first-class对象，我们可以将其作为参数传递给其他函数，然后在该函数内部执行传递进去的函数，也可以将其作为返回值，然后在执行该返回值函数。 3-2、常见的回调函数12345var friends = ["Mike", "Stacy", "Andy", "Rick"];​friends.forEach(function (eachName, index)&#123;console.log(index + 1 + ". " + eachName); // 1. Mike, 2. Stacy, 3. Andy, 4. Rick​&#125;); 3-3、实现回调函数的基本准则3-3-1、Use Named OR Anonymous Functions as Callbacks12345678910111213141516171819202122232425262728293031// global variable​​var allUserData = [];​​// generic logStuff function that prints to console​​function logStuff (userData) &#123; if ( typeof userData === "string") &#123; console.log(userData); &#125; else if ( typeof userData === "object") &#123; for (var item in userData) &#123; console.log(item + ": " + userData[item]); &#125;​ &#125;​&#125;​​// A function that takes two parameters, the last one a callback function​​function getInput (options, callback) &#123; allUserData.push (options); callback (options);​&#125;​​// When we call the getInput function, we pass logStuff as a parameter.​​// So logStuff will be the function that will called back (or executed) inside the getInput function​getInput (&#123;name:"Rich", speciality:"JavaScript"&#125;, logStuff);​// name: Rich​​// speciality: JavaScript 3-3-2、Make Sure Callback is a Function Before Executing It123456789function getInput(options, callback) &#123; allUserData.push(options);​ // Make sure the callback is a function​ if (typeof callback === "function") &#123; // Call it, since we have confirmed it is callable​ callback(options); &#125;&#125; 3-3-3、Problem When Using Methods With The this Object as Callbacks12345678910111213141516171819202122232425// Define an object with some properties and a method​​// We will later pass the method as a callback function to another function​​var clientData = &#123; id: 094545, fullName: "Not Set", // setUserName is a method on the clientData object​ setUserName: function (firstName, lastName) &#123; // this refers to the fullName property in this object​ this.fullName = firstName + " " + lastName; &#125;&#125;​​function getUserInput(firstName, lastName, callback) &#123; // Do other stuff to validate firstName/lastName here​​ // Now save the names​ callback (firstName, lastName);&#125;getUserInput ("Barack", "Obama", clientData.setUserName);​console.log (clientData.fullName);// Not Set​​​// The fullName property was initialized on the window object​console.log (window.fullName); // Barack Obama Use the Call or Apply Function To Preserve this 123456789101112//Note that we have added an extra parameter for the callback object, called "callbackObj"​​function getUserInput(firstName, lastName, callback, callbackObj) &#123; // Do other stuff to validate name here​​ // The use of the Apply function below will set the this object to be callbackObj​ callback.apply (callbackObj, [firstName, lastName]);&#125; // We pass the clientData.setUserName method and the clientData object as parameters. The clientData object will be used by the Apply function to set the this object​getUserInput ("Barack", "Obama", clientData.setUserName, clientData);// the fullName property on the clientData was correctly set​console.log (clientData.fullName); // Barack Obama 译文参考 四、特殊函数答疑4-1、bind函数应用分析4-1-1、bind函数功能bind()方法会创建一个新函数，当这个新函数被调用时，它的this值是传递给bind()的第一个参数, 它的参数是bind()的其他参数和其原本的参数. react应用：1234567891011121314151617181920212223class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125; 4-1-2、bind函数demobind() 最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的 this 值。JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，希望方法中的 this 是原来的对象。（比如在回调中传入这个方法。）如果不做特殊处理的话，一般会丢失原来的对象。从原来的函数和原来的对象创建一个绑定函数，则能很漂亮地解决这个问题： 123456789101112131415this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，"this"指向全局作用域// 创建一个新函数，将"this"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 4-2、call,apply函数应用分析4-2-1、call与apply基本使用在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。 eg: 1234567891011function fruits() &#123;&#125; fruits.prototype = &#123; color: &quot;red&quot;, say: function() &#123; console.log(&quot;My color is &quot; + this.color); &#125;&#125; var apple = new fruits;apple.say(); //My color is red 但是如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法： 12345banana = &#123; color: &quot;yellow&quot;&#125;apple.say.call(banana); //My color is yellowapple.say.apply(banana); //My color is yellow 4-2-2、call和apply使用区别JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时用 call 。而不确定的时候用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个伪数组来遍历所有的参数。 123var numbers = [5, 458 , 120 , -215 ]; var maxInNumbers = Math.max.apply(Math, numbers), //458 maxInNumbers = Math.max.call(Math,5, 458 , 120 , -215); //458 4-3、参考资料妙用Javascript中apply、call、bind 五、js原型，原型链，继承，构造函数归纳总结写在前面：这些概念，对于理解js这一门语言非常重要，要清楚的理解上述概念，需要记住以下几点原则： 在js世界中，一切皆对象，函数也是对象，对象都有proto 函数（fn）都有一个prototype属性，该属性（prototype）有一个属性contructor指向该函数（fn） 继承在设计中一定要明白一个原则，公用性【多个对象公用方法或者属性，节约资源】，独立性【各个对象有自己私有的属性和方法，修改它只会影响到自己】 记住以上三点，就可以开始学习下面的内容了 5-1、原型、原型链和构造函数1234// var a = new A(&apos;hehe&apos;) =&gt;var a = new Object();a.__proto__ = A.prototype; (proto)A.call(a, &apos;hehe&apos;); 下面用一个例子来理解一下 12345678910111213141516171819202122232425262728293031323334function Boss(name,money)&#123; this.name = name ; this.money = money ;&#125;;Boss.prototype = &#123; constructor:Boss , business:function()&#123; console.log(this.name+&quot;生意做的不错&quot;) ; &#125;&#125; ;function RichSecondGeneration(name,money,graceful)&#123; Boss.call(this,name,money) ; this.graceful = graceful ;&#125; ;RichSecondGeneration.prototype = new Boss() ;RichSecondGeneration.prototype.pickUpGirl = function()&#123; if(this.graceful)&#123; console.log(this.name + &quot;把妹很厉害&quot;) ; &#125;else&#123; console.log(this.name + &quot;把妹方式很下流&quot;) ; &#125;&#125; ;var wangsicong = new RichSecondGeneration(&quot;王思聪&quot;,100000000000,true) ; console.log(wangsicong.name,wangsicong.money,wangsicong.graceful) ; wangsicong.business() ; wangsicong.pickUpGirl() ;var lizongrui = new RichSecondGeneration(&quot;李宗瑞&quot;,1000000000,false) ; console.log(lizongrui.name,lizongrui.money,lizongrui.graceful) ; lizongrui.business() ; lizongrui.pickUpGirl() ; 上面代码是最常见的继承实现，常用的继承方式是 原型链继承加借用构造函数构造函数继承。 构造函数可以使得实例对象的属性互不相干，原型链继承可以使得实例对象共享已定义好的方法 ； 属性继承原理：(new + call); 方法继承原理：原型链 但是大家有没有想过一个问题，为什么需要new + call这个语句呢，如果不加上【Boss.call(this,name,money);】会怎样？ 5-2、继承 参考资料js继承设计思想 理解JavaScript的原型链和继承]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[es6语法特性总结]]></title>
      <url>%2Fweb%2Fes6%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[缘由：es6的书籍从来还没有系统的看过，这几天系统看看es6吧，顺便写写总结 一、let和const命令1-1、块级作用域在es6之前js是没有块级作用域的，es6之后，js引入块级作用域 使用let申明变量的时候就有隐形的块级作用域，使用const定义常量也有块级作用域 具体的细节我在《你不知道的js》学习笔记中已经写过了 二、变量的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解（Destructuring）。 2-1、数组的解构赋值本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 2-2、对象的解构赋值对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 2-3、字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 2-4、数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 2-5、函数参数的解构赋值12[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 三、字符串的扩展3-1、基础知识–UTF-8、Unicode和ASCIIASCII：（American Standard Code for Information Interchange，美国信息互换标准代码），开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 unicode：随着时代的发展，很多非英语国家都有了计算机，各国也需要保存自己的文字，所以各地区都有自己的标准。正在这时，大天使加百列及时出现了——一个叫 ISO，（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。 UTF：unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。 eg: 12345678910unicode编码方式：I 0049t 0074&apos; 0027s 0073 0020知 77e5乎 4e4e日 65e5报 62a5 12345678910UTF-8编码方式：I 01001001t 01110100&apos; 00100111s 01110011 00100000知 11100111 10011111 10100101乎 11100100 10111001 10001110日 11100110 10010111 10100101报 11100110 10001010 10100101 3-2、模板字符串实例代码如下，一看便明了： 12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量var name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 四、函数的扩展4-1、函数参数的默认值4-1-1、基本用法es5用法： 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World es6用法： 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 4-1-2、注意事项参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 4-1-3、与解构赋值默认值结合使用12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5foo(&#123;x: 1&#125;) // 1, 5foo(&#123;x: 1, y: 2&#125;) // 1, 2foo() // TypeError: Cannot read property 'x' of undefined 上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。如果参数对象没有y属性，y的默认值5才会生效。 4-1-4、函数length属性的影响123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 4-2、rest参数ES6 引入 rest 参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 下面是一个 rest 参数代替arguments变量的例子。 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 4-3、扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 实例使用： 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers) // 42 替代数组的apply方法 12345678910111213// ES5的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f(...args); 4-4、箭头函数123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 使用注意事项： （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 五、对象的扩展5-1、属性和方法的简洁表示法5-1-1、属性的简洁表示ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 123456var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于var baz = &#123;foo: foo&#125;; 注：上述的{}其实就是表示这是个对象而已，和[]表示数组一样。 下面是另一个例子： 1234567891011function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 5-1-2、方法的简洁表示12345678910111213var o = &#123; method() &#123; return "Hello!"; &#125;&#125;;// 等同于var o = &#123; method: function() &#123; return "Hello!"; &#125;&#125;; 另一个例子： 12345678910111213var birth = '2000/01/01';var Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; 5-2、Object.assignObject.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 5-3、对象的扩展运算符5-3-1、解构赋值对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 5-3-2、扩展运算符扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 六、SymbolSymbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 七、Promise对象Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 7-1、基本用法ES6规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 下面是异步加载图片的例子。 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; var image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的Ajax操作的例子。 1234567891011121314151617181920212223242526272829var getJSON = function(url) &#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); function handler() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 八、Class8-1、概述JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。 12345678910function Point(x, y) &#123; this.x = x; this.y = y;&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Point(1, 2); ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。 1234567891011//定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 注意： ES6的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // "function"Point === Point.prototype.constructor // true 构造函数的prototype属性，在ES6的“类”上面继续存在。【事实上，类的所有方法都定义在类的prototype属性上面。】 1234567891011121314151617181920class Point &#123; constructor()&#123; // ... &#125; toString()&#123; // ... &#125; toValue()&#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; toString()&#123;&#125;, toValue()&#123;&#125;&#125;; 在类的实例上面调用方法，其实就是调用原型上的方法。 1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 8-2、私有方法私有方法是常见需求，但 ES6 不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 1234567891011121314class Widget &#123; // 公有方法 foo (baz) &#123; this._bar(baz); &#125; // 私有方法 _bar(baz) &#123; return this.snaf = baz; &#125; // ...&#125; 8-3、this的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 12345678910111213class Logger &#123; printName(name = 'there') &#123; this.print(`Hello $&#123;name&#125;`); &#125; print(text) &#123; console.log(text); &#125;&#125;const logger = new Logger();const &#123; printName &#125; = logger;printName(); // TypeError: Cannot read property 'print' of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 1234567class Logger &#123; constructor() &#123; this.printName = this.printName.bind(this); &#125; // ...&#125; 另一种解决方法是使用箭头函数。 123456789class Logger &#123; constructor() &#123; this.printName = (name = 'there') =&gt; &#123; this.print(`Hello $&#123;name&#125;`); &#125;; &#125; // ...&#125; 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。 12345678910111213141516171819function selfish (target) &#123; const cache = new WeakMap(); const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key); if (typeof value !== 'function') &#123; return value; &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)); &#125; return cache.get(value); &#125; &#125;; const proxy = new Proxy(target, handler); return proxy;&#125;const logger = selfish(new Logger()); 8-4、Class的继承Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 1class ColorPoint extends Point &#123;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 12345678910class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125; toString() &#123; return this.color + ' ' + super.toString(); // 调用父类的toString() &#125;&#125; 8-5、Class继承详解（es5、es6）8-5-1、es5时代下的继承123456789101112131415161718192021222324252627282930313233343536function Boss(name,money)&#123; this.name = name ; this.money = money ;&#125;;Boss.prototype = &#123; constructor:Boss , business:function()&#123; console.log(this.name+"生意做的不错") ; &#125;&#125; ;function RichSecondGeneration(name,money,graceful)&#123; Boss.call(this,name,money) ; this.graceful = graceful ;&#125; ;RichSecondGeneration.prototype = new Boss() ;RichSecondGeneration.prototype.pickUpGirl = function()&#123; if(this.graceful)&#123; console.log(this.name + "把妹很厉害") ; &#125;else&#123; console.log(this.name + "把妹方式很下流") ; &#125;&#125; ;var wangsicong = new RichSecondGeneration("王思聪",100000000000,true) ; console.log(wangsicong.name,wangsicong.money,wangsicong.graceful) ; wangsicong.business() ; wangsicong.pickUpGirl() ;var lizongrui = new RichSecondGeneration("李宗瑞",1000000000,false) ; console.log(lizongrui.name,lizongrui.money,lizongrui.graceful) ; lizongrui.business() ; lizongrui.pickUpGirl() ; console.log(lizongrui.__proto__); 上述代码是es5时候的写法 继承 常用的继承方式是 原型链继承加借用构造函数构造函数继承 构造函数可以使得实例对象的属性互不相干，原型链继承可以使得实例对象共享已定义好的方法 ； 【属性继承原理】：(new + call); 【方法继承原理】：原型链 8-5-2、es6时代下的继承12345678class A &#123;&#125;class B extends A &#123;&#125;B.__proto__ === A // trueB.prototype.__proto__ === A.prototype // true 上述代码是es6下的写法 （1）子类的proto属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 8-5-3、综述其实es5和es6下的继承实现原理是一样的，es6更多的是语法糖 下面，讨论三种继承的情况： 第一种情况，子类继承Object类 12345class A extends Object &#123;&#125;A.__proto__ === Object // trueA.prototype.__proto__ === Object.prototype // true 第二种情况，不存在任何继承。 12345class A &#123;&#125;A.__proto__ === Function.prototype // trueA.prototype.__proto__ === Object.prototype // true [特别注意]：这个情况其实困惑我好久，关于这个情况详见我做的笔记 第三种情况，子类继承null。 12345class A extends null &#123;&#125;A.__proto__ === Function.prototype // trueA.prototype.__proto__ === undefined // true 九、Module9-1、概述历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 9-2、模块的基本使用9-2-1、export命令使用模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。【也可以输出函数和类】 1234// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; || export &#123;firstName, lastName, year&#125;; 9-2-2、import命令使用123456// main.jsimport &#123;firstName, lastName, year&#125; from './profile';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 9-3、跨模块常量本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。 1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import &#123;A, B&#125; from './constants';console.log(A); // 1console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 123456789// constants/db.jsexport const db = &#123; url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'&#125;;// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator']; 然后，将这些文件输出的常量，合并在index.js里面。 123// constants/index.jsexport &#123;db&#125; from './db';export &#123;users&#125; from './users'; 使用的时候，直接加载index.js就可以了。 12// script.jsimport &#123;db, users&#125; from './constants';]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[你不知道的js（读书笔记）]]></title>
      <url>%2Fweb%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%EF%BC%88%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%89.html</url>
      <content type="text"><![CDATA[缘由：初期学习JavaScript的时候，一直对其运行源码十分感兴趣，但是网上关于这些的博客或者说资源都写的太随意，有阅读过一个JavaScript的编译器源码（小型），更对底层点的js更感兴趣，无意间看到此书，隧写点读书笔记。 一、作用域和闭包1-1、基本概念1-1-1、引擎—-从头到尾负责整个 JavaScript 程序的编译及执行过程1-1-2、作用域引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。 1-1-3、编译器—-引擎的好朋友之一，负责语法分析及代码生成等脏活累活编译主要有3个部分构成如下： 1、词法分析 这个过程将输入的代码（字符串）转换成词法单元，栗子：var a = 2; 转换成”var” “a” “=” “2” “;”这些词法单元 2、语法分析 这个阶段主要将上一个阶段生成的词法单元，转换成“抽象语法树”，类似于html文档结构中的，父节点，子节点之类的概念。 3、代码生成 这个阶段将抽象语法树转换成机器可以理解的机器执行码 总结： 上述编译3个步骤，是大部分编译器所执行的主要工作流，JavaScript引擎不会花费太多时间来优化编译过程，因为它不像其他编译器，编译是发生在执行前。JavaScript编译是发生在执行前的几微秒。 简单地说，任何 JavaScript 代码片段在执行前都要进行编译(通常就在执行前)。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且 通常马上就会执行它。 1-2、块级作用域的重认识1-2-1、let的块级作用域使用123for (var i=0; i&lt;10; i++) &#123; console.log( i );&#125; 我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域(函数或全局)中的事实。 这就是块作用域的用处。变量的声明应该距离使用的地方越近越好，并最大限度地本地化。作用域泡都是用完就丢掉的，变量应该尽量本地化，不能污染其他作用域。 反面案例： 1234567var a = 2;function bar (c) &#123; a = 3; console.log(c+a);&#125;bar(1);console.log(a); let的块级作用域使用，栗子： 1234for (let i=0; i&lt;10; i++) &#123; console.log( i );&#125;console.log( i ); // ReferenceError 1-2-2、const块级作用域使用除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的 (常量)。之后任何试图修改值的操作都会引起错误。 123456789var foo = true;if (foo) &#123; var a = 2; const b = 3; // 包含在 if 中的块作用域常量 a = 3; // 正常! b = 4; // 错误! &#125;console.log( a ); // 3console.log( b ); // ReferenceError! 1-3、作用域提升其实我一开始的时候，也只是知其然，不知其所以然，但是看了这本书介绍后，还是有点明白了，这个问题需要从编译器的角度看，还记得第一章的时候说过，js引擎，不会对编译阶段做过多的优化，因为编译的阶段就是执行前的几微秒，所以，编译器，第一步的词法分析就是找到所有所有的变量和函数定义，然后在运行阶段，执行代码，所以变量和函数的声明都会进行提升。 1-4、闭包，何为闭包1-4-1、闭包基本认识之前在学习iOS初期的时候，也一直有这个疑问，在oc中什么叫做闭包呢，在第一遍看oc内存管理的书籍时候，看完觉得晦涩难懂，之后每隔一段时间又重看一遍，基本没次都有新的感悟，对闭包有了诸多的理解，其实js的闭包和oc的闭包的核心思想是一致的，只是语法和实现上有点不同。 我觉得闭包和回调函数一起理解和消化才是最好的，或者说回调函数是一种利用闭包的技术，是回调函数最大程度的发挥了闭包的作用。 下面一起来看一个栗子（js）： 123456789function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar; &#125;var baz = foo();baz(); // 2 —— 朋友，这就是闭包的效果。 在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃 圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行回收。 而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域?原来是 bar() 本身在使用。 拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。 bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 因此，在几微秒之后变量 baz 被实际调用(调用内部函数 bar)，不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。 1-4-2、闭包联合块级作用域的demo12345for (var i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。 但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。 这是为什么? 首先解释 6 是从哪里来的。这个循环的终止条件是 i 不再 &lt;=5。条件首次成立时 i 的值是 6。因此，输出显示的是循环结束时 i 的最终值。 仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上， 当定时器运行时即使每个迭代中执行的是setTimeout(.., 0)，所有的回调函数依然是在循 环结束后才会被执行，因此会每次输出一个 6 出来。 【代码运行起来很快，延迟函数放在另一队列中，等到循环5次后，才来的急执行队列中的函数】 解决办法： 12345for (let i=1; i&lt;=5; i++) &#123; setTimeout( function timer() &#123; console.log( i ); &#125;, i*1000 );&#125; 1-5、模块1234567891011121314151617function CoolModule() &#123; var something = "cool"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother()&#123; console.log( another.join( " ! " ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;; &#125;var foo = CoolModule(); foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3 这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露， 这里展示的是其变体。 ES6 的模块没有“行内”格式，必须被定义在独立的文件中(一个文件一个模块)。浏览 器或引擎有一个默认的“模块加载器”(可以被重载，但这远超出了我们的讨论范围)可 以在导入模块时异步地加载模块文件。 12345678910111213141516171819202122232425bar.jsfunction hello(who) &#123; return "Let me introduce: " + who;&#125; export hello; foo.js // 仅从 "bar" 模块导入 hello() import hello from "bar";var hungry = "hippo";function awesome() &#123; console.log( hello( hungry ).toUpperCase() );&#125; export awesome;baz.js// 导入完整的 "foo" 和 "bar" 模块module foo from "foo";module bar from "bar";console.log( bar.hello( "rhino" )); // Let me introduce: rhinofoo.awesome(); // LET ME INTRODUCE: HIPPO import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量 上(在我们的例子里是 hello)。module 会将整个模块的 API 导入并绑定到一个变量上(在 我们的例子里是 foo 和 bar)。export 会将当前模块的一个标识符(变量、函数)导出为公 共 API。这些操作可以在模块定义中根据需要使用任意多次。 二、this和对象原型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack基本使用]]></title>
      <url>%2Fweb%2Fwebpack%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</url>
      <content type="text"><![CDATA[缘由：webpack是一个很不错的前端流程化的解决方案，但是配置也需要花点时间掌握，在此做个小总结 1、基本概念了解 webpack WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 glup与grunt 其实Webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。 Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。 2、最基本的webpack环境搭建2-1、初始化webpack环境//全局安装 npm install -g webpack //安装到你的项目目录 npm install --save-dev webpack 2-2、创建package.json配置文件package.json包括当前的依赖模块，自定义的脚本任务 使用npm init，自动创建package.json文件 2-3、创建项目目录，文件回到之前的空文件夹，创建app文件夹和public文件夹，app文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放准备给浏览器读取的数据（包括使用webpack生成的打包后的js文件以及一个index.html文件）。在这里还需要创建三个文件，index.html 文件放在public文件夹中，两个js文件（Greeter.js和main.js）放在app文件夹中 index.html文件只有最基础的html代码，它唯一的目的就是加载打包后的js文件（bundle.js） 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&apos;root&apos;&gt; &lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Greeter.js只包括一个用来返回包含问候信息的html元素的函数。 123456// Greeter.jsmodule.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = &quot;Hi there and greetings!&quot;; return greet;&#125;; main.js用来把Greeter模块返回的节点插入页面。 123//main.js var greeter = require(&apos;./Greeter.js&apos;);document.getElementById(&apos;root&apos;).appendChild(greeter()); 2-4、正式开始运行webpack12//webpack非全局安装的情况node_modules/.bin/webpack app/main.js public/bundle.js 在node_modules文件夹下存在.bin文件夹 2-5、通过配置文件来使用webpackWebpack拥有很多其它的比较高级的功能（比如说本文后面会介绍的loaders和plugins），这些功能其实都可以通过命令行模式实现，但是正如已经提到的，这样不太方便且容易出错的，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。 还是继续上面的例子来说明如何写这个配置文件，在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，并在其中进行最最简单的配置，如下所示，它包含入口文件路径和存放打包后文件的地方的路径。 1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//已多次提及的唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 操作:现在如果你需要打包文件只需要在终端里你运行webpack(非全局安装需使用node_modules/.bin/webpack)命令就可以了，这条命令会自动参考webpack.config.js文件中的配置选项打包你的项目。 warning：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。 2-6、更快捷的执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，不过值得庆幸的是npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可，设置方法如下： 12345678910111213&#123; &quot;name&quot;: &quot;webpack-sample-project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;Sample webpack project&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, &quot;author&quot;: &quot;zhang&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^1.12.9&quot; &#125;&#125; warning:package.json中的脚本部分已经默认在命令前添加了node_modules/.bin路径，所以无论是全局还是局部安装的Webpack，你都不需要写前面那指明详细的路径了。 npm的start是一个特殊的脚本名称，它的特殊性表现在，在命令行中使用npm start就可以执行相关命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build。 3、webpack进阶使用1、生成Source Maps（使调试更容易） 2、使用webpack构建本地服务器 3、Loaders–（可以使用react开发） 4、小技巧在文件夹中配置好package.json之后，使用npm install安装，但是速度太慢，怎么办，当然可以使用镜像文件安装啦，和python,php一样都有国内镜像 1sudo npm install -gd express --registry=http://registry.npm.taobao.org 【详细步骤移步参考资料】 参考资料简书基本资料参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reflux基本使用]]></title>
      <url>%2Fweb%2Freflux%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html</url>
      <content type="text"><![CDATA[缘由：写项目的时候需要用到这个第三方，故在这里总结一下 一、简介12345+---------+ +--------+ +-----------------+¦ Actions ¦------&gt;¦ Stores ¦------&gt;¦ View Components ¦+---------+ +--------+ +-----------------+ ^ ¦ +--------------------------------------+ 组件（视图），接收到用户手势操作后（点击，滑动），触发Actions，eg：Actions.someAction Actions被触发后，然后激发Stores中写好的方法，eg：OnSomeAction(Actions组件只是声明，具体的实现在Stores) Stores中有存储view中的state数据，写好的方法更新state数据，新版本的reflux.Compoment组件有直接继承react.Compoment，所以新版的reflux可以同步存储view的state，具体的看例子 更新的state触发view中的render方法，然后重新渲染view 二、基本组件介绍2-1、组件Actions使用12345var Actions = Reflux.createActions([ &quot;statusUpdate&quot;, &quot;statusEdited&quot;, &quot;statusAdded&quot;]); 2-2、组件Stores使用123456789101112131415class StatusStore extends Reflux.Store&#123; constructor() &#123; super(); this.state = &#123;flag:&apos;OFFLINE&apos;&#125;; // &lt;- set store&apos;s default state much like in React this.listenTo(statusUpdate, this.onStatusUpdate); // listen to the statusUpdate action &#125; onStatusUpdate(status) &#123; var newFlag = status ? &apos;ONLINE&apos; : &apos;OFFLINE&apos;; this.setState(&#123;flag:newFlag&#125;); &#125;&#125; 三、使用demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var Actions = Reflux.createActions([ &apos;increment&apos;, &apos;decrement&apos;, &apos;changeBy&apos;]);class CounterStore extends Reflux.Store&#123; constructor() &#123; super(); this.state = &#123;count: 0&#125;; this.listenables = Actions; &#125; onIncrement() &#123; this.setState(&#123;count: this.state.count+1&#125;); &#125; onDecrement() &#123; this.setState(&#123;count: this.state.count-1&#125;); &#125; onChangeBy(amount) &#123; this.setState(&#123;count: this.state.count+amount&#125;); &#125;&#125;class Counter extends Reflux.Component&#123; constructor(props) &#123; super(props); this.store = CounterStore; &#125; render() &#123; return &lt;div&gt;&#123;this.state.count&#125;&lt;/div&gt;; &#125;&#125;ReactDOM.render( &lt;Counter/&gt;, document.querySelector(&apos;#react-root&apos;));setInterval(Actions.increment, 1000); 官方demo地址–亲测有效 四、遇到的问题4-1、Actions无法被触发详细描述：按照官方给的demo进行修改后，发现点击写好的div后，无法触发方法 问题定位：使用react官方给的工具，在google浏览器中安装插件，然后右键找到源码，在源码处打断点，发现不走这个断点，逐步排除，发现是onsomeAction写错，应该大写，onSomeAction 问题解决：定位出来后，直接解决]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css基础]]></title>
      <url>%2Fweb%2Fcss%E5%9F%BA%E7%A1%80.html</url>
      <content type="text"><![CDATA[缘由：前期有看过一些css相关的书籍，但是一直都没有做总结和记录，现在开始吧~~ 1.Html标记与文档结构1-1.Html标记基础1-1-1.html标签的2种写法 闭合标签 &lt;标签名 属性_1=”属性值” 属性_2=”属性值”&gt;文本内容&lt;/标签名&gt; 12&lt;h1&gt;Words by Dogsworth&lt;/h1&gt;&lt;p&gt;I wandered lonely as a dog.&lt;/p&gt; 自闭合标签 &lt;标签名 属性_1=”属性值” 属性_2=”属性值” /&gt; 1&lt;img src="images/cisco.jpg" alt="My dog Cisco" /&gt; 1-1-2.基本的块级标签和行内标签 块级标签 12345&lt;h1&gt;-&lt;h6&gt; :6 级标签，&lt;h1&gt;表示最重要 &lt;p&gt;:段落&lt;ol&gt;:有序列表&lt;li&gt;:列表项&lt;blockquote&gt;:独立引用 行内标签 1234567&lt;a&gt;:链接(anchor，锚) &lt;img&gt;:图片&lt;em&gt;:斜体&lt;strong&gt;:重要&lt;abbr&gt;:简写&lt;cite&gt;:引证&lt;q&gt;:文本内引用 1-2.Html文档结构 Html文档结构概览（流布局，块级元素，行内元素） 所谓“文档流”的效果，也就是 HTML 元素会按照它们各自在标记中 出现的先后顺序，依次从页面上方“流向”下方。 几乎所有 HTML 元素的 display 属性值要么为 block，要么为 inline。最明显的一 个例外是 table 元素，它有自己特殊的 display 属性值。 块级元素(比如标题和段落)会相互堆叠在一起沿页面向下排列，每个元素分别占 一行。而行内元素(比如链接和图片)则会相互并列，只有在空间不足以并列的情 况下才会折到下一行显示。 块级元素（块级元素盒子会扩展到与父元素同宽） 显示块级元素的轮廓之后，可以发现元素盒子比它们包含的文本要 大一些。每个盒子的高度比内容稍微高一点，而宽度跟浏览器窗口一样宽! 在简易页面中，所有块级元素的父元素都是 body，而它的宽度默认与浏览器窗 口一样宽(当然有少量边距)。因此，所有块级元素就与浏览器窗口一样宽了。说到 这，相信你就能理解为什么块级元素始终会占一行了。对了，就是因为它们始终会 保持与浏览器窗口同宽。这样一来，一个块级元素旁边也就没有空间容纳另一个块 级元素了。 行内元素（行内元素盒子会“收缩包裹”其内容，并且会尽可能包紧） 说到这，你就可以理解为什么几个行内元素会并排显示在一行，而每个块级元素都 会另起一行了。 2、css工作原理2-1.css基本使用2-1-1.Html添加样式的3种方法(代码放在何处) 行内样式 1&lt;p style="font-size: 12px; font-weight:bold; font-style:italic; color:red;"&gt;By adding inline CSS styling to this paragraph, you override the default styles.&lt;/p&gt; 嵌入样式 1234567&lt;head&gt; &lt;!-- 其他 head 元素(如 meta、title)放在这里 --&gt; &lt;style type="text/css"&gt; h1 &#123;font-size:16px;&#125; p &#123;color:blue;&#125; &lt;/style&gt;&lt;/head&gt; 链接样式 1&lt;link href="styles.css" rel="stylesheet" type="text/css" /&gt; 2-1-2.css命名使用规则（最简单的例子） 类似键值对的形式 1p &#123;color:red; font-size:12px; font-weight:bold;&#125; 多个选择符组合在一起使用 1h1, h2, h3 &#123;color:blue; font-weight:bold;&#125; 2-2.选中Html标签的方法（id,属性，上下文选择符）2-2-1.上下文选择符上下文选择符（后代组合式选择符）的格式如下: 标签 1 标签 2 {声明} 其中，标签 2 就是我们想要选择目标，而且只有在标签 1 是其祖先元素(不一定是父元素)的情况下才会被选中。无论从该标签到作为 祖先的上下文之间隔着多少层次都没有关系。 1article p &#123;font-weight:bold;&#125; 2-2-2.子选择符&gt;标签 1 &gt; 标签 2 标签 2 必须是标签 1 的子元素，或者反过来说，标签 1 必须是标签 2 的父元素。与常 规的上下文选择符不同，这个选择符中的标签 1 不能是标签 2 的父元素之外的其他 祖先元素。 1section &gt; h2 &#123;font-style:italic;&#125; 2-2-3.紧邻同胞选择符+标签 1 + 标签 2 标签 2 必须紧跟在其同胞标签 1 的后面。 1h2 + p &#123;font-variant:small-caps;&#125; 2-2-4.通用选择符*通用选择符*(常被称为星号选择符)是一个通配符，它匹配任何元素，因此下面这条规则 1* &#123;color:green;&#125; 会导致所有元素(的文本和边框)都变成绿色。 2-2-5.ID 和类选择符ID 和类为我们选择元素提供了另一套手段，利用它们可以不用考虑文档的层次结构。 只要你在 HTML 标记中为元素添加了 id 和 class 属性，就可以在 CSS 选择符中使用 ID 和类名，直接选中文档中特定的区域。 ID 的用途是在页面中唯一地标识一个元素。正因为如此，同一个页面中的每一个 ID 属性，都必须有独一无二的值(名字)。好吧，换一个角度讲，每个 ID 名在页面中 都只能用一次。 类的目的是为了标识一组具有相同特征的元素，比如本章前面例子中的那个specialtext 类。 类选择符 1.通用类选择符 12&lt;p class="specialtext"&gt; When a tag has a class attribute, you can target it&lt;span&gt;regardless&lt;/span&gt; of its position in the hierarchy.&lt;/p&gt;.specialtext &#123;font-style:italic;&#125; 2.标签带类选择符 12345p &#123;font-family:helvetica, sans-serif; font-size:1.2em;&#125;.specialtext &#123;font-style:italic;&#125;p.specialtext &#123;color:red;&#125;该规则只选择带 specialtext 类的段落。像这样组合标签 名和类选择符，可以让你更精确地选择特定的标签。 ID选择符 ID 与类的写法相似，而且表示 ID 选择符的#(井号)的用法，也跟表示类选择符的. (句号)类似。如果有一个段落像下面这样设定了 ID 属性 12345&lt;p id="specialtext"&gt;This is the special text.&lt;p&gt;那么，相应的 ID 选择符就是这样的:#specialtext &#123;CSS样式声明&#125;或者这样的:p#specialtext &#123;CSS样式声明&#125; 2-3.伪类和伪元素2-3-1.伪类伪类这个叫法源自它们与类相似，但实际上并没有类会附加到标记中的标签上。伪类分两种。 1.UI(User Interface，用户界面)伪类会在 HTML 元素处于某个状态时(比如鼠标 指针位于链接上)，为该元素应用 CSS 样式。 2.结构化伪类会在标记中存在某种结构上的关系时(如某个元素是一组元素中的第 一个或最后一个)，为相应元素应用 CSS 样式。 UI伪类 1、链接伪类 Link。此时，链接就在那儿等着用户点击。 Visited。用户此前点击过这个链接。 Hover。鼠标指针正悬停在链接上。 Active。链接正在被点击(鼠标在元素上按下，还没有释放)。 a:link {color:black;} a:visited {color:gray;} a:hover {text-decoration:none;} a:active {color:red;} warning：一个冒号(:)表示伪类，两个冒号(::)表示 CSS3 新增的伪元素。尽管浏览器目 前都支持对 CSS 1 和 CSS 2 的伪元素使用一个冒号，但希望你能习惯于用双冒号代 替单冒号，因为这些单冒号的伪元素最终可能都会被淘汰掉。 2、:focus 伪类 input:focus {border:1px solid blue;} 会在光标位于 input 字段中时，为该字段添加一个蓝色边框。这样可以让用户明确地知道输入的字符会出现在哪里。 3、:target 伪类 如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标(target)，可以 用:target 伪类选中它。 结构化伪类 1、:first-child 和:last-child :first-child 代表一组同胞元素中的第一个元素，而:last-child 则代表最后一个。 2、:nth-child e:nth-child(n) e 表示元素名，n 表示一个数值(也可以使用 odd 或 even)。 2-3-2.伪元素顾名思义，伪元素就是你的文档中若有实无的元素。以下我们介绍几个最有用的伪 元素 1、::first-letter 伪元素 p::first-letter {font-size:300%;} 段落首字符放大的效果。 2、::first-line 伪元素 p::first-line {font-variant:small-caps;} 可以把第一行以小型大写字母显示 3、::before 和::after 伪元素 &lt;p class=&quot;age&quot;&gt;25&lt;/p&gt; p.age::before {content:&quot;Age: &quot;;} p.age::after {content:&quot; years.&quot;;} Age: 25 years. 3、定位元素3-1、盒子模型3-1-1、盒子模型属性1、边框(border)。可以设置边框的宽窄、样式和颜色。 宽度(border-width)。可以使用 thin、medium 和 thick 等文本值，也可以使用 除百分比和负值之外的任何绝对值。 样式(border-style)。有 none、hidden、dotted、dashed、solid、double、groove、 ridge、inset 和 outset 等文本值。 颜色(border-color)。可以使用任意颜色值，包括 RGB、HSL、十六进制颜色 值和颜色关键字。 2、内边距(padding)。可以设置盒子内容区与边框的间距。 3、外边距(margin)。可以设置盒子与相邻元素的间距。 垂直方向上的外边距会叠加，这可是你必须得知道的一件事。 p {height:50px; border:1px solid #000; backgroundcolor:#fff; margin-top:50px;margin-bottom:30px;} warning： 由于第一段的下外边距与第二段的上外边距相邻，你自然会认为它们之间的外边距 是 80 像素(50+30)，但是你错啦!它们实际的间距是 50 像素。像这样上下外边距 相遇时，它们就会相互重叠，直至一个外边距碰到另一个元素的边框。就上面的例 子而言，第二段较宽的上外边距会碰到第一段的边框。也就是说，较宽的外边距决 定两个元素最终离多远，没错——50 像素。这个过程就叫外边距叠加。 外边距的左右边距则和外边距的上下边距原理相反，左右边距是2者相加。 3-1-2、盒子有多大首先，谈一谈设定盒子的宽度，因为控制元 素的宽度是创建多栏布局的头等大事。一开始我们会看到给没有宽度的元素添加边 框、内边距和外边距的效果，然后再看看通过 CSS 给它设置了宽度之后，它的行为有什么不同。 没有宽度的盒子 盒模型结论一:没有(就是没有设置 width 的)宽度的元素始终会扩展到填满其父 元素的宽度为止。添加水平边框、内边距和外边距，会导致内容宽度减少，减少量 等于水平边框、内边距和外边距的和。 有宽度的盒子 盒模型结论二:为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子扩展 得更宽。实际上，盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子要占 据的水平宽度。 3-2、浮动与清除3-2-1、浮动CSS 设计 float 属性的主要目的，是为了实现文本绕排图片的效果。然而，这个属 性居然也成了创建多栏布局最简单的方式。 说得形象一点，在你浮动一张图片或者其他元素时，你是在要求浏览器把它往上方 推，直到它碰到父元素(也就是 body 元素)的内边界。后面的段落(带灰色边框) 不再认为浮动元素在文档流中位于它的前面了，因而它会占据父元素左上角的位置。 不过，它的内容(文本)会绕开浮动的图片。 接下来我们再看看浮动的另一面，这也是必须得理解的。浮动元素位于“文档流外 部”，因而它已经不被包含在标记中的父元素之内了。正因为如此，它对布局可能产 生破坏性影响。 围住浮动元素的三种方法 1、为父元素添加 overflow:hidden &lt;section&gt; &lt;img src=&quot;images/rubber_duck2.jpg&quot;&gt; &lt;p&gt;It&apos;s fun to float.&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; Here is the footer element that runs across the bottom of the page. &lt;/footer&gt; section {border:1px solid blue; margin:0 0 10px 0; overflow:hidden;} img {float:left;} p {border:1px solid red;} 2、同时浮动父元素 section {border:1px solid blue; float:left; width:100%;} img {float:left;} footer {border:1px solid red; clear:left;} 3、添加非浮动的清除元素 方案一： &lt;section&gt; 4 &lt;img src=&quot;images/rubber_duck.jpg&quot;&gt; &lt;p&gt;It&apos;s fun to float.&lt;/p&gt; &lt;div class=&quot;clear_me&quot;&gt;&lt;/div&gt; &lt;/section&gt; &lt;footer&gt; Here is the footer element...&lt;/footer&gt; section {border:1px solid blue;} img {float:left;} .clear_me {clear:left;} footer {border:1px solid red;} 方案二： &lt;section class=&quot;clearfix&quot;&gt; &lt;img src=&quot;images/rubber_duck.jpg&quot;&gt; &lt;p&gt;It&apos;s fun to float.&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; Here is the footer element...&lt;/footer&gt; .clearfix:after { content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:both; } 3-2-3、浮动与清除的例子（源码中也有解释）浮动与清除Demo 3-3、定位3-3-1、相对定位相对定位是相对哪里定位的呢？相对的是原来它在文档流中的位置，发生移动，不影响其他的元素布局，原来自身所在的空间保留不动，也可能超过body的边界 3-3-2、绝对定位与相对定位相反，绝对定位是将元素连根拔起，然后在相对定位上下文（默认是body,当将其某个祖先元素设置为position:relative之后，该元素就是定位上下文了），来进行位置确定。 3-3-3、固定定位和绝对定位类似，也是完全将元素连根拔起，但是它参考的浏览器的边界或者手机的屏幕，不会随着滚动发生偏移。 3-3-4、显示属性（display：inline||block） 把块级元素变成行内元素(或者相反)的魔法如下 /*默认为 block*/ p {display:inline;} /*默认为 inline*/ a {display:block;} warning： Top的值表示对象相对原位置向下偏移的距离，bottom的值表示对象相对原位置向上偏移的距离，两者同时存在时，只有Top起作用。 left的值表示对象相对原位置向右偏移的距离，right的值表示对象相对原位置向左偏移的距离，两者同时存在时，只有left起作用。 4、页面布局4-1、布局的基本概念4-1-1、多栏布局的实现方案 固定宽度 流动（主流） 弹性（较为复杂，暂不考虑） 4-1-2、布局高度和布局宽度 布局高度 多数情况下，布局高度不需要我们考虑，事实上，我们不应该给元素设置高度。 布局宽度 布局宽度比较重要，需要仔细考虑设置 4-2、三栏布局只要掌握了创建三栏布局的技术，你想搞多少栏就 能搞多少栏。 4-2-1、三栏固定宽度布局例子详解 4-2-2、三栏中栏流动布局例子详解 4-3、多栏布局参考1、网络资源css布局-dispaly,position,float css布局-float详解，英文 css相对定位和绝对定位 关于css position: absolute、relative定位问题 HTML、CSS知识点总结，浅显易懂 2、书籍相关css设计指南3 3、练手项目百度前端技术学院]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[博客搭建]]></title>
      <url>%2F%E9%80%9A%E7%94%A8%E6%8A%80%E8%83%BD%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA.html</url>
      <content type="text"><![CDATA[缘由：一直都想有一个自己的博客，可以记录下自己的学习和生活，也尝试过好几种搭建博客的方式，今天在此总结记录下吧。 方案一我最早的博客是用的hostinger，一个免费的虚拟主机搭建的。第一个版本是用的WordPress，搭建完成后还是挺开心的，但是根本都没用几天。之后另外一个版本是用php做后端，自己手写前端界面，但是自己做的界面一直都不能让自己满意 方案二随着技能树的增多，我想有一个自己的vps，这样方便开发，方便多平台无缝隙切换，这次我是在vps上搭建的博客，起初第一个版本是用的python搭建的后端，之后因为python3在centos6上环境有问题，所以还是作罢，采用php的codeigniter框架从写了博客，前端采用react，做到前后端分离，基本的框架和想法以及自己的技能都够了，但是我发现这还不是我想要的，我写博客，只是方便记录自己而已。没必要弄这么复杂，文字在博客中重要性才是第一的 方案三好的。我现在选用hexo与next来搭建了，下面记录下我使用它遇到的一些问题。 ico图标设置问题使用官网的文档，很快就搭建完成了，但是想用自己设计的ico，但是一直弄不成功 解决办法： favicon.ico放在主题的source\images下 修改主题配置文件：的favicon为images/favicon.ico 设置项失效 很多的设置项我开始设置的时候都是无效的 解决办法： 配置文件中如： 1234language:zh-Hans上述设置就将无效language: zh-Hans上述设置将成功，区别在于冒号后的空格！！！ 参考资料hexo下的next搭建]]></content>
    </entry>

    
  
  
</search>
